var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod5) => function __require2() {
  return mod5 || (0, cb[__getOwnPropNames(cb)[0]])((mod5 = { exports: {} }).exports, mod5), mod5.exports;
};
var __export = (target, all3) => {
  for (var name14 in all3)
    __defProp(target, name14, { get: all3[name14], enumerable: true });
};
var __copyProps = (to, from46, except, desc) => {
  if (from46 && typeof from46 === "object" || typeof from46 === "function") {
    for (let key of __getOwnPropNames(from46))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from46[key], enumerable: !(desc = __getOwnPropDesc(from46, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod5, isNodeMode, target) => (target = mod5 != null ? __create(__getProtoOf(mod5)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod5 || !mod5.__esModule ? __defProp(target, "default", { value: mod5, enumerable: true }) : target,
  mod5
));
var __toCommonJS = (mod5) => __copyProps(__defProp({}, "__esModule", { value: true }), mod5);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong2(val) : fmtShort2(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y2;
        case "weeks":
        case "week":
        case "w":
          return n * w2;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse3, "parse");
    function fmtShort2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    __name(fmtShort2, "fmtShort");
    function fmtLong2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural2(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural2(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural2(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural2(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    __name(fmtLong2, "fmtLong");
    function plural2(ms2, msAbs, n, name14) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name14 + (isPlural ? "s" : "");
    }
    __name(plural2, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup2(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce32;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash3 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug19(...args) {
          if (!debug19.enabled) {
            return;
          }
          const self2 = debug19;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format14) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format14];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug19, "debug");
        debug19.namespace = namespace;
        debug19.useColors = createDebug.useColors();
        debug19.color = createDebug.selectColor(namespace);
        debug19.extend = extend;
        debug19.destroy = createDebug.destroy;
        Object.defineProperty(debug19, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug19);
        }
        return debug19;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i = 0; i < len; i++) {
          if (!split2[i]) {
            continue;
          }
          namespaces = split2[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name14) {
        if (name14[name14.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name14)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name14)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      function coerce32(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce32, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup2, "setup");
    module2.exports = setup2;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs2;
    exports2.save = save2;
    exports2.load = load2;
    exports2.useColors = useColors2;
    exports2.storage = localstorage2();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors2() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors2, "useColors");
    function formatArgs2(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs2, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save2(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save2, "save");
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load2, "load");
    function localstorage2() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage2, "localstorage");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    __name(assign, "assign");
    function createError(err, code16, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code16 === "object") {
        props = code16;
        code16 = "";
      }
      if (code16) {
        props.code = code16;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = /* @__PURE__ */ __name(function() {
        }, "ErrClass");
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output3 = assign(new ErrClass(), props);
        return output3;
      }
    }
    __name(createError, "createError");
    module2.exports = createError;
  }
});

// node_modules/varint-decoder/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode79;
    var MSB21 = 128;
    var REST21 = 127;
    var MSBALL19 = ~REST21;
    var INT19 = Math.pow(2, 31);
    function encode79(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT19) {
        out[offset++] = num & 255 | MSB21;
        num /= 128;
      }
      while (num & MSBALL19) {
        out[offset++] = num & 255 | MSB21;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode79.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode79, "encode");
  }
});

// node_modules/varint-decoder/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read21;
    var MSB21 = 128;
    var REST21 = 127;
    function read21(buf3, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
      do {
        if (counter >= l) {
          read21.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST21) << shift : (b & REST21) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB21);
      read21.bytes = counter - offset;
      return res;
    }
    __name(read21, "read");
  }
});

// node_modules/varint-decoder/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/length.js"(exports2, module2) {
    var N122 = Math.pow(2, 7);
    var N222 = Math.pow(2, 14);
    var N322 = Math.pow(2, 21);
    var N422 = Math.pow(2, 28);
    var N522 = Math.pow(2, 35);
    var N622 = Math.pow(2, 42);
    var N722 = Math.pow(2, 49);
    var N821 = Math.pow(2, 56);
    var N921 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N122 ? 1 : value < N222 ? 2 : value < N322 ? 3 : value < N422 ? 4 : value < N522 ? 5 : value < N622 ? 6 : value < N722 ? 7 : value < N821 ? 8 : value < N921 ? 9 : 10;
    };
  }
});

// node_modules/varint-decoder/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/varint-decoder/src/index.js
var require_src = __commonJS({
  "node_modules/varint-decoder/src/index.js"(exports2, module2) {
    "use strict";
    var varint22 = require_varint();
    module2.exports = (buf3) => {
      if (!(buf3 instanceof Uint8Array)) {
        throw new Error("arg needs to be a Uint8Array");
      }
      const result = [];
      while (buf3.length > 0) {
        const num = varint22.decode(buf3);
        result.push(num);
        buf3 = buf3.slice(varint22.decode.bytes);
      }
      return result;
    };
  }
});

// node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode79;
    var MSB21 = 128;
    var REST21 = 127;
    var MSBALL19 = ~REST21;
    var INT19 = Math.pow(2, 31);
    function encode79(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode79.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT19) {
        out[offset++] = num & 255 | MSB21;
        num /= 128;
      }
      while (num & MSBALL19) {
        out[offset++] = num & 255 | MSB21;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode79.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode79, "encode");
  }
});

// node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read21;
    var MSB21 = 128;
    var REST21 = 127;
    function read21(buf3, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
      do {
        if (counter >= l || shift > 49) {
          read21.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST21) << shift : (b & REST21) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB21);
      read21.bytes = counter - offset;
      return res;
    }
    __name(read21, "read");
  }
});

// node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    var N122 = Math.pow(2, 7);
    var N222 = Math.pow(2, 14);
    var N322 = Math.pow(2, 21);
    var N422 = Math.pow(2, 28);
    var N522 = Math.pow(2, 35);
    var N622 = Math.pow(2, 42);
    var N722 = Math.pow(2, 49);
    var N821 = Math.pow(2, 56);
    var N921 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N122 ? 1 : value < N222 ? 2 : value < N322 ? 3 : value < N422 ? 4 : value < N522 ? 5 : value < N622 ? 6 : value < N722 ? 7 : value < N821 ? 8 : value < N921 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/retimer/time-browser.js
var require_time_browser = __commonJS({
  "node_modules/retimer/time-browser.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function getTime() {
      return Date.now();
    }, "getTime");
  }
});

// node_modules/retimer/retimer.js
var require_retimer = __commonJS({
  "node_modules/retimer/retimer.js"(exports2, module2) {
    "use strict";
    var getTime = require_time_browser();
    var Retimer = class {
      static {
        __name(this, "Retimer");
      }
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    __name(retimer, "retimer");
    module2.exports = retimer;
  }
});

// node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS({
  "node_modules/timeout-abort-controller/index.js"(exports2, module2) {
    "use strict";
    var { AbortController: AbortController2 } = globalThis;
    var retimer = require_retimer();
    var TimeoutController2 = class _TimeoutController extends AbortController2 {
      static {
        __name(this, "TimeoutController");
      }
      /**
       * @constructor
       * @param {number} ms milliseconds
       */
      constructor(ms2) {
        super();
        this._ms = ms2;
        this._timer = retimer(() => this.abort(), ms2);
        Object.setPrototypeOf(this, _TimeoutController.prototype);
      }
      /**
       * Aborts the controller and clears the timer
       */
      abort() {
        this._timer.clear();
        return super.abort();
      }
      /**
       * Clears the timer
       */
      clear() {
        this._timer.clear();
      }
      /**
       * Resets the timer
       */
      reset() {
        this._timer.clear();
        this._timer = retimer(() => this.abort(), this._ms);
      }
    };
    module2.exports = {
      TimeoutController: TimeoutController2
    };
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : /* @__PURE__ */ __name(function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    }, "ReflectApply");
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      }, "ReflectOwnKeys");
    } else {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      }, "ReflectOwnKeys");
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    __name(ProcessEmitWarning, "ProcessEmitWarning");
    var NumberIsNaN = Number.isNaN || /* @__PURE__ */ __name(function NumberIsNaN2(value) {
      return value !== value;
    }, "NumberIsNaN");
    function EventEmitter10() {
      EventEmitter10.init.call(this);
    }
    __name(EventEmitter10, "EventEmitter");
    module2.exports = EventEmitter10;
    module2.exports.once = once;
    EventEmitter10.EventEmitter = EventEmitter10;
    EventEmitter10.prototype._events = void 0;
    EventEmitter10.prototype._eventsCount = 0;
    EventEmitter10.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    __name(checkListener, "checkListener");
    Object.defineProperty(EventEmitter10, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter10.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter10.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners10(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    }, "setMaxListeners");
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter10.defaultMaxListeners;
      return that._maxListeners;
    }
    __name(_getMaxListeners, "_getMaxListeners");
    EventEmitter10.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
      return _getMaxListeners(this);
    }, "getMaxListeners");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    }, "emit");
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    __name(_addListener, "_addListener");
    EventEmitter10.prototype.addListener = /* @__PURE__ */ __name(function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    }, "addListener");
    EventEmitter10.prototype.on = EventEmitter10.prototype.addListener;
    EventEmitter10.prototype.prependListener = /* @__PURE__ */ __name(function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    }, "prependListener");
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    __name(onceWrapper, "onceWrapper");
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    __name(_onceWrap, "_onceWrap");
    EventEmitter10.prototype.once = /* @__PURE__ */ __name(function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    }, "once");
    EventEmitter10.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    }, "prependOnceListener");
    EventEmitter10.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    }, "removeListener");
    EventEmitter10.prototype.off = EventEmitter10.prototype.removeListener;
    EventEmitter10.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    }, "removeAllListeners");
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    __name(_listeners, "_listeners");
    EventEmitter10.prototype.listeners = /* @__PURE__ */ __name(function listeners(type) {
      return _listeners(this, type, true);
    }, "listeners");
    EventEmitter10.prototype.rawListeners = /* @__PURE__ */ __name(function rawListeners(type) {
      return _listeners(this, type, false);
    }, "rawListeners");
    EventEmitter10.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter10.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    __name(listenerCount, "listenerCount");
    EventEmitter10.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    }, "eventNames");
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    __name(arrayClone, "arrayClone");
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    __name(spliceOne, "spliceOne");
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    __name(unwrapListeners, "unwrapListeners");
    function once(emitter, name14) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name14, resolver);
          reject(err);
        }
        __name(errorListener, "errorListener");
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        __name(resolver, "resolver");
        ;
        eventTargetAgnosticAddListener(emitter, name14, resolver, { once: true });
        if (name14 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    __name(once, "once");
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    __name(addErrorHandlerIfEventEmitter, "addErrorHandlerIfEventEmitter");
    function eventTargetAgnosticAddListener(emitter, name14, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name14, listener);
        } else {
          emitter.on(name14, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name14, /* @__PURE__ */ __name(function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name14, wrapListener);
          }
          listener(arg);
        }, "wrapListener"));
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  }
});

// node_modules/@vascosantos/moving-average/index.js
var require_moving_average = __commonJS({
  "node_modules/@vascosantos/moving-average/index.js"(exports2, module2) {
    "use strict";
    var exp = Math.exp;
    exports2 = module2.exports = /* @__PURE__ */ __name(function MovingAverage2(timespan) {
      if (typeof timespan !== "number") {
        throw new Error("must provide a timespan to the moving average constructor");
      }
      if (timespan <= 0) {
        throw new Error("must provide a timespan > 0 to the moving average constructor");
      }
      let ma;
      let v = 0;
      let d2 = 0;
      let f = 0;
      let previousTime;
      let ret = {};
      function alpha(t, pt) {
        return 1 - exp(-(t - pt) / timespan);
      }
      __name(alpha, "alpha");
      ret.push = /* @__PURE__ */ __name(function push(time, value) {
        if (previousTime) {
          const a = alpha(time, previousTime);
          const diff = value - ma;
          const incr = a * diff;
          ma = a * value + (1 - a) * ma;
          v = (1 - a) * (v + diff * incr);
          d2 = Math.sqrt(v);
          f = ma + a * diff;
        } else {
          ma = value;
        }
        previousTime = time;
      }, "push");
      ret.movingAverage = /* @__PURE__ */ __name(function movingAverage() {
        return ma;
      }, "movingAverage");
      ret.variance = /* @__PURE__ */ __name(function variance() {
        return v;
      }, "variance");
      ret.deviation = /* @__PURE__ */ __name(function deviation() {
        return d2;
      }, "deviation");
      ret.forecast = /* @__PURE__ */ __name(function forecast() {
        return f;
      }, "forecast");
      return ret;
    }, "MovingAverage");
  }
});

// node_modules/helia/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/helia/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    __name(Events, "Events");
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    function EventEmitter10() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    __name(EventEmitter10, "EventEmitter");
    EventEmitter10.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      var names4 = [], events2, name14;
      if (this._eventsCount === 0)
        return names4;
      for (name14 in events2 = this._events) {
        if (has.call(events2, name14))
          names4.push(prefix ? name14.slice(1) : name14);
      }
      if (Object.getOwnPropertySymbols) {
        return names4.concat(Object.getOwnPropertySymbols(events2));
      }
      return names4;
    }, "eventNames");
    EventEmitter10.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    }, "listeners");
    EventEmitter10.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    }, "listenerCount");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length21 = listeners.length, j;
        for (i = 0; i < length21; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    }, "emit");
    EventEmitter10.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    }, "on");
    EventEmitter10.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    }, "once");
    EventEmitter10.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length21 = listeners.length; i < length21; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    }, "removeListener");
    EventEmitter10.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners");
    EventEmitter10.prototype.off = EventEmitter10.prototype.removeListener;
    EventEmitter10.prototype.addListener = EventEmitter10.prototype.on;
    EventEmitter10.prefixed = prefix;
    EventEmitter10.EventEmitter = EventEmitter10;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter10;
    }
  }
});

// node_modules/p-queue/node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "node_modules/p-queue/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    __name(Events, "Events");
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    function EventEmitter10() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    __name(EventEmitter10, "EventEmitter");
    EventEmitter10.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      var names4 = [], events2, name14;
      if (this._eventsCount === 0)
        return names4;
      for (name14 in events2 = this._events) {
        if (has.call(events2, name14))
          names4.push(prefix ? name14.slice(1) : name14);
      }
      if (Object.getOwnPropertySymbols) {
        return names4.concat(Object.getOwnPropertySymbols(events2));
      }
      return names4;
    }, "eventNames");
    EventEmitter10.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    }, "listeners");
    EventEmitter10.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    }, "listenerCount");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length21 = listeners.length, j;
        for (i = 0; i < length21; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    }, "emit");
    EventEmitter10.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    }, "on");
    EventEmitter10.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    }, "once");
    EventEmitter10.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length21 = listeners.length; i < length21; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    }, "removeListener");
    EventEmitter10.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners");
    EventEmitter10.prototype.off = EventEmitter10.prototype.removeListener;
    EventEmitter10.prototype.addListener = EventEmitter10.prototype.on;
    EventEmitter10.prefixed = prefix;
    EventEmitter10.EventEmitter = EventEmitter10;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter10;
    }
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet11, maxline) {
      if (typeof alphabet11 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output3 = "";
      if (!(input instanceof Uint8Array)) {
        output3 = _encodeWithByteBuffer(input, alphabet11);
      } else {
        var i = 0;
        var base42 = alphabet11.length;
        var first2 = alphabet11.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base42;
            carry = carry / base42 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base42);
            carry = carry / base42 | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output3 += first2;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output3 += alphabet11[digits[i]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output3 = output3.match(regex).join("\r\n");
      }
      return output3;
    };
    api.decode = function(input, alphabet11) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet11 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table2 = _reverseAlphabets[alphabet11];
      if (!table2) {
        table2 = _reverseAlphabets[alphabet11] = [];
        for (var i = 0; i < alphabet11.length; ++i) {
          table2[alphabet11.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base42 = alphabet11.length;
      var first2 = alphabet11.charAt(0);
      var bytes3 = [0];
      for (var i = 0; i < input.length; i++) {
        var value = table2[input.charCodeAt(i)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes3.length; ++j) {
          carry += bytes3[j] * base42;
          bytes3[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes3.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first2 && k < input.length - 1; ++k) {
        bytes3.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes3.reverse());
      }
      return new Uint8Array(bytes3.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet11) {
      var i = 0;
      var base42 = alphabet11.length;
      var first2 = alphabet11.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base42;
          carry = carry / base42 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base42);
          carry = carry / base42 | 0;
        }
      }
      var output3 = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output3 += first2;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output3 += alphabet11[digits[i]];
      }
      return output3;
    }
    __name(_encodeWithByteBuffer, "_encodeWithByteBuffer");
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge12 = require_forge();
    var baseN = require_baseN();
    var util = module2.exports = forge12.util = forge12.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        __name(handler2, "handler");
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return window;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    __name(_checkBitsParam, "_checkBitsParam");
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    __name(ByteStringBuffer, "ByteStringBuffer");
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d2 = this.data;
      while (n > 0) {
        if (n & 1) {
          d2 += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d2;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes3) {
      this.data += bytes3;
      this._optimizeConstructedString(bytes3.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes3 = "";
      do {
        n -= 8;
        bytes3 += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes3);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer3) {
      return this.putBytes(buffer3.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer2 = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer2 || isArrayBufferView) {
        if (isArrayBuffer2) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    __name(DataBuffer, "DataBuffer");
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src30 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src30);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes3, encoding) {
      if (util.isArrayBufferView(bytes3)) {
        var src30 = new Uint8Array(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
        var len = src30.byteLength - src30.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src30);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes3)) {
        var src30 = new Uint8Array(bytes3);
        this.accommodate(src30.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src30, this.write);
        this.write += src30.byteLength;
        return this;
      }
      if (bytes3 instanceof util.DataBuffer || typeof bytes3 === "object" && typeof bytes3.read === "number" && typeof bytes3.write === "number" && util.isArrayBufferView(bytes3.data)) {
        var src30 = new Uint8Array(bytes3.data.byteLength, bytes3.read, bytes3.length());
        this.accommodate(src30.byteLength);
        var dst = new Uint8Array(bytes3.data.byteLength, this.write);
        dst.set(src30);
        this.write += src30.byteLength;
        return this;
      }
      if (bytes3 instanceof util.ByteStringBuffer) {
        bytes3 = bytes3.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes3 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes3.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes3.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes3 = util.encodeUtf8(bytes3);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes3.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes3.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes3);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer3) {
      this.putBytes(buffer3);
      buffer3.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src30 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src30.byteLength);
        dst.set(src30);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s2 = "";
      while (n > 0) {
        if (n & 1) {
          s2 += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s2;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes3) {
      return util.createBuffer(bytes3).toHex();
    };
    util.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output3 = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output3 += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output3 += line;
      return output3;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output3 = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output3 += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output3 += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output3 += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output3;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes3) {
      return String.fromCharCode.apply(null, bytes3);
    };
    util.binary.raw.decode = function(str, output3, offset) {
      var out = output3;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output3 ? j - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output3, offset) {
      var out = output3;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output3 ? j - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output3 = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output3 += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output3 += line;
      return output3;
    };
    util.binary.base64.decode = function(input, output3, offset) {
      var out = output3;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output3 ? j - offset : out.subarray(0, j);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output3, offset) {
      str = util.encodeUtf8(str);
      var out = output3;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output3 ? j - offset : out;
    };
    util.text.utf8.decode = function(bytes3) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes3));
    };
    util.text.utf16.encode = function(str, output3, offset) {
      var out = output3;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output3 ? j - offset : out;
    };
    util.text.utf16.decode = function(bytes3) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes3.buffer));
    };
    util.deflate = function(api, bytes3, raw) {
      bytes3 = util.decode64(api.deflate(util.encode64(bytes3)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes3.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes3 = bytes3.substring(start, bytes3.length - 4);
      }
      return bytes3;
    };
    util.inflate = function(api, bytes3, raw) {
      var rval = api.inflate(util.encode64(bytes3)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = /* @__PURE__ */ __name(function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    }, "_setStorageObject");
    var _getStorageObject = /* @__PURE__ */ __name(function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    }, "_getStorageObject");
    var _setItem = /* @__PURE__ */ __name(function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    }, "_setItem");
    var _getItem = /* @__PURE__ */ __name(function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    }, "_getItem");
    var _removeItem = /* @__PURE__ */ __name(function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty32 = true;
        for (var prop in obj) {
          empty32 = false;
          break;
        }
        if (empty32) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    }, "_removeItem");
    var _clearItems = /* @__PURE__ */ __name(function(api, id) {
      _setStorageObject(api, id, null);
    }, "_clearItems");
    var _callStorageFunction = /* @__PURE__ */ __name(function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    }, "_callStorageFunction");
    util.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format14) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format14)) {
        part = format14.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code16 = match[0][1];
        switch (code16) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code16 + "?>");
        }
      }
      parts.push(format14.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number3, decimals, dec_point, thousands_sep) {
      var n = number3, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d2 = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s2 + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d2 + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes3 = util.hexToBytes(ip[i]);
        if (bytes3.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes3);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes3) {
      if (bytes3.length === 4) {
        return util.bytesToIPv4(bytes3);
      }
      if (bytes3.length === 16) {
        return util.bytesToIPv6(bytes3);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes3) {
      if (bytes3.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes3.length; ++i) {
        ip.push(bytes3.charCodeAt(i));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes3) {
      if (bytes3.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes3.length; i += 2) {
        var hex = util.bytesToHex(bytes3[i] + bytes3[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et)
              ;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map3(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      __name(sample, "sample");
      function map3(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      __name(map3, "map");
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
      __name(reduce, "reduce");
    };
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge12 = require_forge();
    forge12.pki = forge12.pki || {};
    var oids = module2.exports = forge12.pki.oids = forge12.oids = forge12.oids || {};
    function _IN(id, name14) {
      oids[id] = name14;
      oids[name14] = id;
    }
    __name(_IN, "_IN");
    function _I_(id, name14) {
      oids[id] = name14;
    }
    __name(_I_, "_I_");
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge12.asn1 = forge12.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge12.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== void 0) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge12.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge12.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge12.util.isArray(obj1)) {
        if (!forge12.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length21;
      var longForm = b2 & 128;
      if (!longForm) {
        length21 = b2;
      } else {
        length21 = b.getInt((b2 & 127) << 3);
      }
      return length21;
    };
    function _checkBufferLength(bytes3, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes3.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    __name(_checkBufferLength, "_checkBufferLength");
    var _getValueLength = /* @__PURE__ */ __name(function(bytes3, remaining) {
      var b2 = bytes3.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length21;
      var longForm = b2 & 128;
      if (!longForm) {
        length21 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes3, remaining, longFormBytes);
        length21 = bytes3.getInt(longFormBytes << 3);
      }
      if (length21 < 0) {
        throw new Error("Negative length: " + length21);
      }
      return length21;
    }, "_getValueLength");
    asn1.fromDer = function(bytes3, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes3 === "string") {
        bytes3 = forge12.util.createBuffer(bytes3);
      }
      var byteCount = bytes3.length();
      var value = _fromDer(bytes3, bytes3.length(), 0, options);
      if (options.parseAllBytes && bytes3.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes3.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes3, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes3, remaining, 2);
      var b1 = bytes3.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes3.length();
      var length21 = _getValueLength(bytes3, remaining);
      remaining -= start - bytes3.length();
      if (length21 !== void 0 && length21 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes3.length();
          error.remaining = remaining;
          error.requested = length21;
          throw error;
        }
        length21 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length21 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes3, remaining, 2);
            if (bytes3.bytes(2) === String.fromCharCode(0, 0)) {
              bytes3.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes3.length();
            value.push(_fromDer(bytes3, remaining, depth + 1, options));
            remaining -= start - bytes3.length();
          }
        } else {
          while (length21 > 0) {
            start = bytes3.length();
            value.push(_fromDer(bytes3, length21, depth + 1, options));
            remaining -= start - bytes3.length();
            length21 -= start - bytes3.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes3.bytes(length21);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length21 > 1) {
        var savedRead = bytes3.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes3, remaining, 1);
          unused = bytes3.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes3.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes3, remaining, depth + 1, subOptions);
            var used = start - bytes3.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length21 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes3.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length21 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length21 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length21 > 0; length21 -= 2) {
            _checkBufferLength(bytes3, remaining, 2);
            value += String.fromCharCode(bytes3.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes3.getBytes(length21);
          remaining -= length21;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    __name(_fromDer, "_fromDer");
    asn1.toDer = function(obj) {
      var bytes3 = forge12.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge12.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes3.putByte(b1);
      if (value.length() <= 127) {
        bytes3.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes3.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes3.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes3.putBuffer(value);
      return bytes3;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes3 = forge12.util.createBuffer();
      bytes3.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b = value & 127;
          value = value >>> 7;
          if (!last) {
            b |= 128;
          }
          valueBytes.push(b);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes3.putByte(valueBytes[n]);
        }
      }
      return bytes3;
    };
    asn1.derToOid = function(bytes3) {
      var oid;
      if (typeof bytes3 === "string") {
        bytes3 = forge12.util.createBuffer(bytes3);
      }
      var b = bytes3.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value = 0;
      while (bytes3.length() > 0) {
        b = bytes3.getByte();
        value = value << 7;
        if (b & 128) {
          value += b & 127;
        } else {
          oid += "." + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format14 = [];
      format14.push(("" + date.getUTCFullYear()).substr(2));
      format14.push("" + (date.getUTCMonth() + 1));
      format14.push("" + date.getUTCDate());
      format14.push("" + date.getUTCHours());
      format14.push("" + date.getUTCMinutes());
      format14.push("" + date.getUTCSeconds());
      for (var i = 0; i < format14.length; ++i) {
        if (format14[i].length < 2) {
          rval += "0";
        }
        rval += format14[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format14 = [];
      format14.push("" + date.getUTCFullYear());
      format14.push("" + (date.getUTCMonth() + 1));
      format14.push("" + date.getUTCDate());
      format14.push("" + date.getUTCHours());
      format14.push("" + date.getUTCMinutes());
      format14.push("" + date.getUTCSeconds());
      for (var i = 0; i < format14.length; ++i) {
        if (format14[i].length < 2) {
          rval += "0";
        }
        rval += format14[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge12.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes3) {
      if (typeof bytes3 === "string") {
        bytes3 = forge12.util.createBuffer(bytes3);
      }
      var n = bytes3.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes3.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge12.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge12.pki && forge12.pki.oids) {
            if (oid in forge12.pki.oids) {
              rval += " (" + forge12.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge12.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge12.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge12.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge12.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge12.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge12.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    module2.exports = forge12.cipher = forge12.cipher || {};
    forge12.cipher.algorithms = forge12.cipher.algorithms || {};
    forge12.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge12.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge12.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge12.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge12.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge12.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge12.cipher.registerAlgorithm = function(name14, algorithm) {
      name14 = name14.toUpperCase();
      forge12.cipher.algorithms[name14] = algorithm;
    };
    forge12.cipher.getAlgorithm = function(name14) {
      name14 = name14.toUpperCase();
      if (name14 in forge12.cipher.algorithms) {
        return forge12.cipher.algorithms[name14];
      }
      return null;
    };
    var BlockCipher = forge12.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge12.util.createBuffer();
      this.output = options.output || forge12.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output3) {
          return pad(this.blockSize, output3, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    forge12.cipher = forge12.cipher || {};
    var modes = module2.exports = forge12.cipher.modes = forge12.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output3, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output3.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output3, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output3.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output3, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output3.length();
      var count = output3.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output3.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output3, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output3.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output3, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output3.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output3, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output3.length();
      var count = output3.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output3.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge12.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output3, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output3.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output3.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output3.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output3, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output3.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output3.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output3.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge12.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output3, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output3.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output3.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output3.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge12.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output3, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output3.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output3.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output3.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge12.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge12.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge12.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge12.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge12.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge12.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output3, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output3.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output3.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output3.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output3, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output3.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output3, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output3.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge12.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y2) {
      var z_i = [0, 0, 0, 0];
      var v_i = y2.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h2, y2, x) {
      y2[0] ^= x[0];
      y2[1] ^= x[1];
      y2[2] ^= x[2];
      y2[3] ^= x[3];
      return this.tableMultiply(y2);
    };
    modes.gcm.prototype.generateHashTable = function(h2, bits3) {
      var multiplier = 8 / bits3;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m2 = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits3;
        tmp[idx] = 1 << bits3 - 1 << shft;
        m2[i] = this.generateSubHashTable(this.multiply(tmp, h2), bits3);
      }
      return m2;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits3) {
      var size = 1 << bits3;
      var half = size >>> 1;
      var m2 = new Array(size);
      m2[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m2[2 * i], m2[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m2[i];
          var m_j = m2[j];
          m2[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m2[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m2[i ^ half];
        m2[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m2;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge12.util.createBuffer(iv);
      }
      if (forge12.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge12.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge12.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    __name(transformIV, "transformIV");
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    __name(inc32, "inc32");
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
    __name(from64To32, "from64To32");
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge12 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge12.aes = forge12.aes || {};
    forge12.aes.startEncrypting = function(key, iv, output3, mode) {
      var cipher = _createCipher({
        key,
        output: output3,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge12.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge12.aes.startDecrypting = function(key, iv, output3, mode) {
      var cipher = _createCipher({
        key,
        output: output3,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge12.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge12.aes.Algorithm = function(name14, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name14;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge12.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge12.util.createBuffer(key);
      } else if (forge12.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge12.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge12.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge12.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge12.aes._expandKey = function(key, decrypt3) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt3);
    };
    forge12.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge12.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge12.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge12.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge12.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge12.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge12.cipher.modes.gcm);
    function registerAlgorithm(name14, mode) {
      var factory = /* @__PURE__ */ __name(function() {
        return new forge12.aes.Algorithm(name14, mode);
      }, "factory");
      forge12.cipher.registerAlgorithm(name14, factory);
    }
    __name(registerAlgorithm, "registerAlgorithm");
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    __name(initialize, "initialize");
    function _expandKey(key, decrypt3) {
      var w2 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w2.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w2[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w2[i] = w2[i - Nk] ^ temp;
      }
      if (decrypt3) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w2.slice(0);
        end = w2.length;
        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w2[wi];
            wnew[i + 1] = w2[wi + 3];
            wnew[i + 2] = w2[wi + 2];
            wnew[i + 3] = w2[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w2[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w2 = wnew;
      }
      return w2;
    }
    __name(_expandKey, "_expandKey");
    function _updateBlock(w2, input, output3, decrypt3) {
      var Nr = w2.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt3) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d2, a2, b2, c2;
      a = input[0] ^ w2[0];
      b = input[decrypt3 ? 3 : 1] ^ w2[1];
      c = input[2] ^ w2[2];
      d2 = input[decrypt3 ? 1 : 3] ^ w2[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d2 & 255] ^ w2[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a & 255] ^ w2[++i];
        c2 = m0[c >>> 24] ^ m1[d2 >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w2[++i];
        d2 = m0[d2 >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w2[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output3[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w2[++i];
      output3[decrypt3 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a & 255] ^ w2[++i];
      output3[2] = sub[c >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w2[++i];
      output3[decrypt3 ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w2[++i];
    }
    __name(_updateBlock, "_updateBlock");
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge12.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge12.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output3 = null;
        if (options2 instanceof forge12.util.ByteBuffer) {
          output3 = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output3;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
    __name(_createCipher, "_createCipher");
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge12 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge12.des = forge12.des || {};
    forge12.des.startEncrypting = function(key, iv, output3, mode) {
      var cipher = _createCipher({
        key,
        output: output3,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge12.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge12.des.startDecrypting = function(key, iv, output3, mode) {
      var cipher = _createCipher({
        key,
        output: output3,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge12.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge12.des.Algorithm = function(name14, mode) {
      var self2 = this;
      self2.name = name14;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge12.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge12.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge12.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge12.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge12.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge12.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge12.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge12.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge12.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge12.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge12.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge12.cipher.modes.ctr);
    function registerAlgorithm(name14, mode) {
      var factory = /* @__PURE__ */ __name(function() {
        return new forge12.des.Algorithm(name14, mode);
      }, "factory");
      forge12.cipher.registerAlgorithm(name14, factory);
    }
    __name(registerAlgorithm, "registerAlgorithm");
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    __name(_createKeys, "_createKeys");
    function _updateBlock(keys, input, output3, decrypt3) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt3 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt3 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output3[0] = left;
      output3[1] = right;
    }
    __name(_updateBlock, "_updateBlock");
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge12.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge12.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output3 = null;
        if (options2 instanceof forge12.util.ByteBuffer) {
          output3 = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output3;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
    __name(_createCipher, "_createCipher");
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge12 = require_forge();
    module2.exports = forge12.md = forge12.md || {};
    forge12.md.algorithms = forge12.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge12 = require_forge();
    require_md();
    require_util();
    var hmac2 = module2.exports = forge12.hmac = forge12.hmac || {};
    hmac2.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge12.md.algorithms) {
              _md = forge12.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge12.util.createBuffer(key);
          } else if (forge12.util.isArray(key)) {
            var tmp = key;
            key = forge12.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge12.util.createBuffer();
          _opadding = forge12.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes3) {
        _md.update(bytes3);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge12 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge12.pkcs5 = forge12.pkcs5 || {};
    var crypto5;
    if (forge12.util.isNodejs && !forge12.options.usePureJavaScript) {
      crypto5 = require_crypto();
    }
    module2.exports = forge12.pbkdf2 = pkcs5.pbkdf2 = function(p, s2, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge12.util.isNodejs && !forge12.options.usePureJavaScript && crypto5.pbkdf2 && (md === null || typeof md !== "object") && (crypto5.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s2 = Buffer.from(s2, "binary");
        if (!callback) {
          if (crypto5.pbkdf2Sync.length === 4) {
            return crypto5.pbkdf2Sync(p, s2, c, dkLen).toString("binary");
          }
          return crypto5.pbkdf2Sync(p, s2, c, dkLen, md).toString("binary");
        }
        if (crypto5.pbkdf2Sync.length === 4) {
          return crypto5.pbkdf2(p, s2, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto5.pbkdf2(p, s2, c, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge12.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge12.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge12.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor2, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s2);
          prf.update(forge12.util.int32ToBytes(i));
          xor2 = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor2 = forge12.util.xorBytes(xor2, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor2 : xor2.substr(0, r);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s2);
        prf.update(forge12.util.int32ToBytes(i));
        xor2 = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      __name(outer, "outer");
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor2 = forge12.util.xorBytes(xor2, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge12.util.setImmediate(inner);
        }
        dk += i < len ? xor2 : xor2.substr(0, r);
        ++i;
        outer();
      }
      __name(inner, "inner");
      outer();
    };
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    var pem = module2.exports = forge12.pem = forge12.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge12.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge12.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = /* @__PURE__ */ __name(function(match, $1) {
        return " " + $1;
      }, "insertSpace");
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length21 = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length21) {
        if (length21 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length21 = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    __name(foldHeader, "foldHeader");
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
    __name(ltrim, "ltrim");
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge12 = require_forge();
    require_md();
    require_util();
    var sha25618 = module2.exports = forge12.sha256 = forge12.sha256 || {};
    forge12.md.sha256 = forge12.md.algorithms.sha256 = sha25618;
    sha25618.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge12.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge12.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge12.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge12.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits3 = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits3 += carry;
          finalBlock.putInt32(bits3 >>> 0);
          bits3 = next >>> 0;
        }
        finalBlock.putInt32(bits3);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge12.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge12.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s2, w2, bytes3) {
      var t1, t2, s0, s1, ch, maj, i, a, b, c, d2, e, f, g, h2;
      var len = bytes3.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w2[i] = bytes3.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w2[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w2[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w2[i] = t1 + w2[i - 7] + t2 + w2[i - 16] | 0;
        }
        a = s2.h0;
        b = s2.h1;
        c = s2.h2;
        d2 = s2.h3;
        e = s2.h4;
        f = s2.h5;
        g = s2.h6;
        h2 = s2.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h2 + s1 + ch + _k[i] + w2[i];
          t2 = s0 + maj;
          h2 = g;
          g = f;
          f = e;
          e = d2 + t1 >>> 0;
          d2 = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s2.h0 = s2.h0 + a | 0;
        s2.h1 = s2.h1 + b | 0;
        s2.h2 = s2.h2 + c | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e | 0;
        s2.h5 = s2.h5 + f | 0;
        s2.h6 = s2.h6 + g | 0;
        s2.h7 = s2.h7 + h2 | 0;
        len -= 64;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    var _crypto = null;
    if (forge12.util.isNodejs && !forge12.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module2.exports = forge12.prng = forge12.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge12.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge12.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes3 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes3.length;
          b.putBytes(bytes3);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge12.util.setImmediate(generate);
        }
        __name(generate, "generate");
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge12.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes3 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes3.length;
          b.putBytes(bytes3);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes3) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes3);
          _seed();
          callback();
        });
      }
      __name(_reseed, "_reseed");
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      __name(_reseedSync, "_reseedSync");
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      __name(_seed, "_seed");
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge12.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = /* @__PURE__ */ __name(function(arr) {
            return _crypto2.getRandomValues(arr);
          }, "getRandomValues");
        }
        var b = forge12.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      __name(defaultSeedFile, "defaultSeedFile");
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes3) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes3.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes3) {
        var count = bytes3.length;
        for (var i2 = 0; i2 < count; ++i2) {
          ctx.pools[ctx.pool].update(bytes3.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes3 = "";
        for (var x = 0; x < n; x += 8) {
          bytes3 += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes3);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            __name(listener2, "listener");
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = /* @__PURE__ */ __name(function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes3) {
                worker.postMessage({ forge: { prng: { err, bytes: bytes3 } } });
              });
            }
          }, "listener");
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge12 = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge12.random && forge12.random.getBytes) {
        module2.exports = forge12.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge12.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge12.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge12.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge12.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge12.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge12.md.sha256;
        function spawnPrng() {
          var ctx = forge12.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        __name(spawnPrng, "spawnPrng");
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge12.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = /* @__PURE__ */ __name(function(arr) {
            return _crypto.getRandomValues(arr);
          }, "getRandomValues");
        }
        if (forge12.options.usePureJavaScript || !forge12.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge12.random) {
          forge12.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge12.random[key] = _ctx[key];
          }
        }
        forge12.random.createInstance = spawnPrng;
        module2.exports = forge12.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = /* @__PURE__ */ __name(function(word2, bits3) {
      return word2 << bits3 & 65535 | (word2 & 65535) >> 16 - bits3;
    }, "rol");
    var ror = /* @__PURE__ */ __name(function(word2, bits3) {
      return (word2 & 65535) >> bits3 | word2 << 16 - bits3 & 65535;
    }, "ror");
    module2.exports = forge12.rc2 = forge12.rc2 || {};
    forge12.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge12.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = /* @__PURE__ */ __name(function(key, bits3, encrypt3) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K2 = [];
      key = forge12.rc2.expandKey(key, bits3);
      for (i = 0; i < 64; i++) {
        K2.push(key.getInt16Le());
      }
      if (encrypt3) {
        mixRound = /* @__PURE__ */ __name(function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K2[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s2[i]);
            j++;
          }
        }, "mixRound");
        mashRound = /* @__PURE__ */ __name(function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K2[R[(i + 3) % 4] & 63];
          }
        }, "mashRound");
      } else {
        mixRound = /* @__PURE__ */ __name(function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s2[i]);
            R[i] -= K2[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        }, "mixRound");
        mashRound = /* @__PURE__ */ __name(function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K2[R[(i + 3) % 4] & 63];
          }
        }, "mashRound");
      }
      var runPlan = /* @__PURE__ */ __name(function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt3) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt3 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt3) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      }, "runPlan");
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output3) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge12.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge12.util.createBuffer();
          _output = output3 || new forge12.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt3) {
            if (pad) {
              rval = pad(8, _input, !encrypt3);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt3) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt3);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    }, "createCipher");
    forge12.rc2.startEncrypting = function(key, iv, output3) {
      var cipher = forge12.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output3);
      return cipher;
    };
    forge12.rc2.createEncryptionCipher = function(key, bits3) {
      return createCipher(key, bits3, true);
    };
    forge12.rc2.startDecrypting = function(key, iv, output3) {
      var cipher = forge12.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output3);
      return cipher;
    };
    forge12.rc2.createDecryptionCipher = function(key, bits3) {
      return createCipher(key, bits3, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge12 = require_forge();
    module2.exports = forge12.jsbn = forge12.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    __name(BigInteger, "BigInteger");
    forge12.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    __name(nbi, "nbi");
    function am1(i, x, w2, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w2.data[j] + c;
        c = Math.floor(v / 67108864);
        w2.data[j++] = v & 67108863;
      }
      return c;
    }
    __name(am1, "am1");
    function am2(i, x, w2, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h2 = this.data[i++] >> 15;
        var m2 = xh * l + h2 * xl;
        l = xl * l + ((m2 & 32767) << 15) + w2.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
        w2.data[j++] = l & 1073741823;
      }
      return c;
    }
    __name(am2, "am2");
    function am3(i, x, w2, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h2 = this.data[i++] >> 14;
        var m2 = xh * l + h2 * xl;
        l = xl * l + ((m2 & 16383) << 14) + w2.data[j] + c;
        c = (l >> 28) + (m2 >> 14) + xh * h2;
        w2.data[j++] = l & 268435455;
      }
      return c;
    }
    __name(am3, "am3");
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    __name(int2char, "int2char");
    function intAt(s2, i) {
      var c = BI_RC[s2.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    __name(intAt, "intAt");
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    __name(bnpCopyTo, "bnpCopyTo");
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    __name(bnpFromInt, "bnpFromInt");
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    __name(nbv, "nbv");
    function bnpFromString(s2, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s2, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s2.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s2[i] & 255 : intAt(s2, i);
        if (x < 0) {
          if (s2.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    __name(bnpFromString, "bnpFromString");
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    __name(bnpClamp, "bnpClamp");
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d2, m2 = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d2 = this.data[i] >> p) > 0) {
          m2 = true;
          r = int2char(d2);
        }
        while (i >= 0) {
          if (p < k) {
            d2 = (this.data[i] & (1 << p) - 1) << k - p;
            d2 |= this.data[--i] >> (p += this.DB - k);
          } else {
            d2 = this.data[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d2 > 0)
            m2 = true;
          if (m2)
            r += int2char(d2);
        }
      }
      return m2 ? r : "0";
    }
    __name(bnToString, "bnToString");
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    __name(bnNegate, "bnNegate");
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    __name(bnAbs, "bnAbs");
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this.data[i] - a.data[i]) != 0)
          return r;
      return 0;
    }
    __name(bnCompareTo, "bnCompareTo");
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    __name(nbits, "nbits");
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    __name(bnBitLength, "bnBitLength");
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    __name(bnpDLShiftTo, "bnpDLShiftTo");
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    __name(bnpDRShiftTo, "bnpDRShiftTo");
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    __name(bnpLShiftTo, "bnpLShiftTo");
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    __name(bnpRShiftTo, "bnpRShiftTo");
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m2 = Math.min(a.t, this.t);
      while (i < m2) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r.data[i++] = this.DV + c;
      else if (c > 0)
        r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    __name(bnpSubTo, "bnpSubTo");
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y2 = a.abs();
      var i = x.t;
      r.t = i + y2.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < y2.t; ++i)
        r.data[i + x.t] = x.am(0, y2.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    __name(bnpMultiplyTo, "bnpMultiplyTo");
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    __name(bnpSquareTo, "bnpSquareTo");
    function bnpDivRemTo(m2, q, r) {
      var pm = m2.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y2 = nbi(), ts = this.s, ms2 = m2.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y2);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y2);
        pt.copyTo(r);
      }
      var ys = y2.t;
      var y0 = y2.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y2.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q == null ? nbi() : q;
      y2.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y2, y2);
      while (y2.t < ys)
        y2.data[y2.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y2.am(0, qd, r, j, 0, ys)) < qd) {
          y2.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms2)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    __name(bnpDivRemTo, "bnpDivRemTo");
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    __name(bnMod, "bnMod");
    function Classic(m2) {
      this.m = m2;
    }
    __name(Classic, "Classic");
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    __name(cConvert, "cConvert");
    function cRevert(x) {
      return x;
    }
    __name(cRevert, "cRevert");
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    __name(cReduce, "cReduce");
    function cMulTo(x, y2, r) {
      x.multiplyTo(y2, r);
      this.reduce(r);
    }
    __name(cMulTo, "cMulTo");
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    __name(cSqrTo, "cSqrTo");
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y2 = x & 3;
      y2 = y2 * (2 - (x & 15) * y2) & 15;
      y2 = y2 * (2 - (x & 255) * y2) & 255;
      y2 = y2 * (2 - ((x & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    __name(bnpInvDigit, "bnpInvDigit");
    function Montgomery(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    __name(Montgomery, "Montgomery");
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    __name(montConvert, "montConvert");
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    __name(montRevert, "montRevert");
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    __name(montReduce, "montReduce");
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    __name(montSqrTo, "montSqrTo");
    function montMulTo(x, y2, r) {
      x.multiplyTo(y2, r);
      this.reduce(r);
    }
    __name(montMulTo, "montMulTo");
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    __name(bnpIsEven, "bnpIsEven");
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    __name(bnpExp, "bnpExp");
    function bnModPowInt(e, m2) {
      var z;
      if (e < 256 || m2.isEven())
        z = new Classic(m2);
      else
        z = new Montgomery(m2);
      return this.exp(e, z);
    }
    __name(bnModPowInt, "bnModPowInt");
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    __name(bnClone, "bnClone");
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    __name(bnIntValue, "bnIntValue");
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    __name(bnByteValue, "bnByteValue");
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    __name(bnShortValue, "bnShortValue");
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    __name(bnpChunkSize, "bnpChunkSize");
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    __name(bnSigNum, "bnSigNum");
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d2 = nbv(a), y2 = nbi(), z = nbi(), r = "";
      this.divRemTo(d2, y2, z);
      while (y2.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y2.divRemTo(d2, y2, z);
      }
      return z.intValue().toString(b) + r;
    }
    __name(bnpToRadix, "bnpToRadix");
    function bnpFromRadix(s2, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d2 = Math.pow(b, cs), mi = false, j = 0, w2 = 0;
      for (var i = 0; i < s2.length; ++i) {
        var x = intAt(s2, i);
        if (x < 0) {
          if (s2.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w2 = b * w2 + x;
        if (++j >= cs) {
          this.dMultiply(d2);
          this.dAddOffset(w2, 0);
          j = 0;
          w2 = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w2, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    __name(bnpFromRadix, "bnpFromRadix");
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    __name(bnpFromNumber, "bnpFromNumber");
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d2, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d2 = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d2 | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d2 = (this.data[i] & (1 << p) - 1) << 8 - p;
            d2 |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d2 = this.data[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d2 & 128) != 0)
            d2 |= -256;
          if (k == 0 && (this.s & 128) != (d2 & 128))
            ++k;
          if (k > 0 || d2 != this.s)
            r[k++] = d2;
        }
      }
      return r;
    }
    __name(bnToByteArray, "bnToByteArray");
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    __name(bnEquals, "bnEquals");
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    __name(bnMin, "bnMin");
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    __name(bnMax, "bnMax");
    function bnpBitwiseTo(a, op, r) {
      var i, f, m2 = Math.min(a.t, this.t);
      for (i = 0; i < m2; ++i)
        r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m2; i < this.t; ++i)
          r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m2; i < a.t; ++i)
          r.data[i] = op(f, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    __name(bnpBitwiseTo, "bnpBitwiseTo");
    function op_and(x, y2) {
      return x & y2;
    }
    __name(op_and, "op_and");
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    __name(bnAnd, "bnAnd");
    function op_or(x, y2) {
      return x | y2;
    }
    __name(op_or, "op_or");
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    __name(bnOr, "bnOr");
    function op_xor(x, y2) {
      return x ^ y2;
    }
    __name(op_xor, "op_xor");
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    __name(bnXor, "bnXor");
    function op_andnot(x, y2) {
      return x & ~y2;
    }
    __name(op_andnot, "op_andnot");
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    __name(bnAndNot, "bnAndNot");
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    __name(bnNot, "bnNot");
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    __name(bnShiftLeft, "bnShiftLeft");
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    __name(bnShiftRight, "bnShiftRight");
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    __name(lbit, "lbit");
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    __name(bnGetLowestSetBit, "bnGetLowestSetBit");
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    __name(cbit, "cbit");
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this.data[i] ^ x);
      return r;
    }
    __name(bnBitCount, "bnBitCount");
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    __name(bnTestBit, "bnTestBit");
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    __name(bnpChangeBit, "bnpChangeBit");
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    __name(bnSetBit, "bnSetBit");
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    __name(bnClearBit, "bnClearBit");
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    __name(bnFlipBit, "bnFlipBit");
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m2 = Math.min(a.t, this.t);
      while (i < m2) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r.data[i++] = c;
      else if (c < -1)
        r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    __name(bnpAddTo, "bnpAddTo");
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    __name(bnAdd, "bnAdd");
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    __name(bnSubtract, "bnSubtract");
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    __name(bnMultiply, "bnMultiply");
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    __name(bnDivide, "bnDivide");
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    __name(bnRemainder, "bnRemainder");
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    __name(bnDivideAndRemainder, "bnDivideAndRemainder");
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    __name(bnpDMultiply, "bnpDMultiply");
    function bnpDAddOffset(n, w2) {
      if (n == 0)
        return;
      while (this.t <= w2)
        this.data[this.t++] = 0;
      this.data[w2] += n;
      while (this.data[w2] >= this.DV) {
        this.data[w2] -= this.DV;
        if (++w2 >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w2];
      }
    }
    __name(bnpDAddOffset, "bnpDAddOffset");
    function NullExp() {
    }
    __name(NullExp, "NullExp");
    function nNop(x) {
      return x;
    }
    __name(nNop, "nNop");
    function nMulTo(x, y2, r) {
      x.multiplyTo(y2, r);
    }
    __name(nMulTo, "nMulTo");
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    __name(nSqrTo, "nSqrTo");
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    __name(bnPow, "bnPow");
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    __name(bnpMultiplyLowerTo, "bnpMultiplyLowerTo");
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    __name(bnpMultiplyUpperTo, "bnpMultiplyUpperTo");
    function Barrett(m2) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    __name(Barrett, "Barrett");
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    __name(barrettConvert, "barrettConvert");
    function barrettRevert(x) {
      return x;
    }
    __name(barrettRevert, "barrettRevert");
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    __name(barrettReduce, "barrettReduce");
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    __name(barrettSqrTo, "barrettSqrTo");
    function barrettMulTo(x, y2, r) {
      x.multiplyTo(y2, r);
      this.reduce(r);
    }
    __name(barrettMulTo, "barrettMulTo");
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m2) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m2);
      else if (m2.isEven())
        z = new Barrett(m2);
      else
        z = new Montgomery(m2);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w2, is1 = true, r2 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w2 = e.data[j] >> i - k1 & km;
        else {
          w2 = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w2 |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w2 & 1) == 0) {
          w2 >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w2].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w2], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    __name(bnModPow, "bnModPow");
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y2 = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y2) < 0) {
        var t = x;
        x = y2;
        y2 = t;
      }
      var i = x.getLowestSetBit(), g = y2.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y2.rShiftTo(g, y2);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y2.getLowestSetBit()) > 0)
          y2.rShiftTo(i, y2);
        if (x.compareTo(y2) >= 0) {
          x.subTo(y2, x);
          x.rShiftTo(1, x);
        } else {
          y2.subTo(x, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g > 0)
        y2.lShiftTo(g, y2);
      return y2;
    }
    __name(bnGCD, "bnGCD");
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d2 = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d2 == 0)
          r = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d2 * r + this.data[i]) % n;
      return r;
    }
    __name(bnpModInt, "bnpModInt");
    function bnModInverse(m2) {
      var ac = m2.isEven();
      if (this.isEven() && ac || m2.signum() == 0)
        return BigInteger.ZERO;
      var u = m2.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d2 = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m2, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m2, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d2.isEven()) {
              c.addTo(this, c);
              d2.subTo(m2, d2);
            }
            c.rShiftTo(1, c);
          } else if (!d2.isEven())
            d2.subTo(m2, d2);
          d2.rShiftTo(1, d2);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d2, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d2.subTo(b, d2);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d2.compareTo(m2) >= 0)
        return d2.subtract(m2);
      if (d2.signum() < 0)
        d2.addTo(m2, d2);
      else
        return d2;
      if (d2.signum() < 0)
        return d2.add(m2);
      else
        return d2;
    }
    __name(bnModInverse, "bnModInverse");
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m2 = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m2 < lplim)
          m2 *= lowprimes[j++];
        m2 = x.modInt(m2);
        while (i < j)
          if (m2 % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    __name(bnIsProbablePrime, "bnIsProbablePrime");
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y2 = a.modPow(r, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y2.compareTo(n1) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y2.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    __name(bnpMillerRabin, "bnpMillerRabin");
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    __name(bnGetPrng, "bnGetPrng");
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge12 = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge12.sha1 = forge12.sha1 || {};
    forge12.md.sha1 = forge12.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge12.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge12.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge12.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge12.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits3 = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits3 += carry;
          finalBlock.putInt32(bits3 >>> 0);
          bits3 = next >>> 0;
        }
        finalBlock.putInt32(bits3);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge12.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge12.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s2, w2, bytes3) {
      var t, a, b, c, d2, e, f, i;
      var len = bytes3.length();
      while (len >= 64) {
        a = s2.h0;
        b = s2.h1;
        c = s2.h2;
        d2 = s2.h3;
        e = s2.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes3.getInt32();
          w2[i] = t;
          f = d2 ^ b & (c ^ d2);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
          t = t << 1 | t >>> 31;
          w2[i] = t;
          f = d2 ^ b & (c ^ d2);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
          t = t << 1 | t >>> 31;
          w2[i] = t;
          f = b ^ c ^ d2;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
          t = t << 2 | t >>> 30;
          w2[i] = t;
          f = b ^ c ^ d2;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
          t = t << 2 | t >>> 30;
          w2[i] = t;
          f = b & c | d2 & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
          t = t << 2 | t >>> 30;
          w2[i] = t;
          f = b ^ c ^ d2;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s2.h0 = s2.h0 + a | 0;
        s2.h1 = s2.h1 + b | 0;
        s2.h2 = s2.h2 + c | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e | 0;
        len -= 64;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge12.pkcs1 = forge12.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message2, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge12.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message2.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message2.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message2.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message2;
      if (!seed) {
        seed = forge12.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge12.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge12.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge12.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y2 = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge12.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge12.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y2 !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code16 = db.charCodeAt(j);
        var is_0 = code16 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code16 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash3) {
      if (!hash3) {
        hash3 = forge12.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash3.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode(
          i >> 24 & 255,
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
        );
        hash3.start();
        hash3.update(seed + c);
        t += hash3.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
    __name(rsa_mgf1, "rsa_mgf1");
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge12 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge12.prime) {
        module2.exports = forge12.prime;
        return;
      }
      var prime = module2.exports = forge12.prime = forge12.prime || {};
      var BigInteger = forge12.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = /* @__PURE__ */ __name(function(x, y2) {
        return x | y2;
      }, "op_or");
      prime.generateProbablePrime = function(bits3, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge12.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits3, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits3, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits3, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits3, rng, options, callback);
      }
      __name(primeincFindPrime, "primeincFindPrime");
      function primeincFindPrimeWithoutWorkers(bits3, rng, options, callback) {
        var num = generateRandom(bits3, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits3, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      __name(primeincFindPrimeWithoutWorkers, "primeincFindPrimeWithoutWorkers");
      function _primeinc(num, bits3, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits3) {
            num = generateRandom(bits3, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge12.util.setImmediate(function() {
          _primeinc(num, bits3, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      __name(_primeinc, "_primeinc");
      function primeincFindPrimeWithWorkers(bits3, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits3, rng, options, callback);
        }
        var num = generateRandom(bits3, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge12.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits3) {
              num = generateRandom(bits3, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
          __name(workerMessage, "workerMessage");
        }
        __name(generate, "generate");
      }
      __name(primeincFindPrimeWithWorkers, "primeincFindPrimeWithWorkers");
      function generateRandom(bits3, rng) {
        var num = new BigInteger(bits3, rng);
        var bits1 = bits3 - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      __name(generateRandom, "generateRandom");
      function getMillerRabinTests(bits3) {
        if (bits3 <= 100)
          return 27;
        if (bits3 <= 150)
          return 18;
        if (bits3 <= 200)
          return 15;
        if (bits3 <= 250)
          return 12;
        if (bits3 <= 300)
          return 9;
        if (bits3 <= 350)
          return 8;
        if (bits3 <= 400)
          return 7;
        if (bits3 <= 500)
          return 6;
        if (bits3 <= 600)
          return 5;
        if (bits3 <= 800)
          return 4;
        if (bits3 <= 1250)
          return 3;
        return 2;
      }
      __name(getMillerRabinTests, "getMillerRabinTests");
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge12 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge12.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge12.util.isNodejs ? require_crypto() : null;
    var asn1 = forge12.asn1;
    var util = forge12.util;
    forge12.pki = forge12.pki || {};
    module2.exports = forge12.pki.rsa = forge12.rsa = forge12.rsa || {};
    var pki = forge12.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge12.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = /* @__PURE__ */ __name(function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest13 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest13);
      return asn1.toDer(digestInfo).getBytes();
    }, "emsaPkcs1v15encode");
    var _modPow = /* @__PURE__ */ __name(function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge12.util.bytesToHex(forge12.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y2 = y2.multiply(r.modInverse(key.n)).mod(key.n);
      return y2;
    }, "_modPow");
    pki.rsa.encrypt = function(m2, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m2, key, bt);
      } else {
        eb = forge12.util.createBuffer();
        eb.putBytes(m2);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y2 = _modPow(x, key, pub);
      var yhex = y2.toString(16);
      var ed = forge12.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge12.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y2 = new BigInteger(forge12.util.createBuffer(ed).toHex(), 16);
      if (y2.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y2, key, pub);
      var xhex = x.toString(16);
      var eb = forge12.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge12.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits3, e, options) {
      if (typeof bits3 === "string") {
        bits3 = parseInt(bits3, 10);
      }
      bits3 = bits3 || 2048;
      options = options || {};
      var prng = options.prng || forge12.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits: bits3,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits3 >> 1,
          pBits: bits3 - (bits3 >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = /* @__PURE__ */ __name(function(x, y2) {
        return x | y2;
      }, "op_or");
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits3 = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits3 - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits3, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits3) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d2 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d2,
              state.p,
              state.q,
              d2.mod(state.p1),
              d2.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits3, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits3 === "object") {
          options = bits3;
          bits3 = void 0;
        } else if (typeof bits3 === "function") {
          callback = bits3;
          bits3 = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits3 === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits3;
          callback = e;
          bits3 = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits3 === void 0) {
        bits3 = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge12.options.usePureJavaScript && !options.prng && bits3 >= 256 && bits3 <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits3,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits3,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair2) {
              return util.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge12.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits3,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair2 = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge12.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits3,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits3, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m2, key2, pub) {
              return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m2, key2) {
              return forge12.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest13, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest14, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              var obj = asn1.fromDer(d3, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge12.oids.md2 || oid === forge12.oids.md5 || oid === forge12.oids.sha1 || oid === forge12.oids.sha224 || oid === forge12.oids.sha256 || oid === forge12.oids.sha384 || oid === forge12.oids.sha512 || oid === forge12.oids["sha512-224"] || oid === forge12.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge12.oids.md2 || oid === forge12.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest14 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest14, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              return digest14 === d3;
            }
          };
        }
        var d2 = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest13, d2, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d2, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d: d2,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d3 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d4, key2) {
              return forge12.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d4) {
            return d4;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d3, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d3 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d3, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge12.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n, e, d2, p, q, dP, dQ, qInv;
      n = forge12.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge12.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d2 = forge12.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge12.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge12.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge12.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge12.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge12.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d2, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n = forge12.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge12.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m2, key, bt) {
      var eb = forge12.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m2.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m2.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m2.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge12.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m2);
      return eb;
    }
    __name(_encodePkcs1_v1_5, "_encodePkcs1_v1_5");
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge12.util.createBuffer(em);
      var first2 = eb.getByte();
      var bt = eb.getByte();
      if (first2 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero2 = eb.getByte();
      if (zero2 !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    __name(_decodePkcs1_v1_5, "_decodePkcs1_v1_5");
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      __name(generate, "generate");
      function getPrime(bits3, callback2) {
        forge12.prime.generateProbablePrime(bits3, opts, callback2);
      }
      __name(getPrime, "getPrime");
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d2 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d2,
            state.p,
            state.q,
            d2.mod(state.p1),
            d2.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
      __name(finish, "finish");
    }
    __name(_generateKeyPair, "_generateKeyPair");
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes3 = forge12.util.hexToBytes(hex);
      if (bytes3.length > 1 && // leading 0x00 for positive integer
      (bytes3.charCodeAt(0) === 0 && (bytes3.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes3.charCodeAt(0) === 255 && (bytes3.charCodeAt(1) & 128) === 128)) {
        return bytes3.substr(1);
      }
      return bytes3;
    }
    __name(_bnToBytes, "_bnToBytes");
    function _getMillerRabinTests(bits3) {
      if (bits3 <= 100)
        return 27;
      if (bits3 <= 150)
        return 18;
      if (bits3 <= 200)
        return 15;
      if (bits3 <= 250)
        return 12;
      if (bits3 <= 300)
        return 9;
      if (bits3 <= 350)
        return 8;
      if (bits3 <= 400)
        return 7;
      if (bits3 <= 500)
        return 6;
      if (bits3 <= 600)
        return 5;
      if (bits3 <= 800)
        return 4;
      if (bits3 <= 1250)
        return 3;
      return 2;
    }
    __name(_getMillerRabinTests, "_getMillerRabinTests");
    function _detectNodeCrypto(fn) {
      return forge12.util.isNodejs && typeof _crypto[fn] === "function";
    }
    __name(_detectNodeCrypto, "_detectNodeCrypto");
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    __name(_detectSubtleCrypto, "_detectSubtleCrypto");
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    __name(_detectSubtleMsCrypto, "_detectSubtleMsCrypto");
    function _intToUint8Array(x) {
      var bytes3 = forge12.util.hexToBytes(x.toString(16));
      var buffer3 = new Uint8Array(bytes3.length);
      for (var i = 0; i < bytes3.length; ++i) {
        buffer3[i] = bytes3.charCodeAt(i);
      }
      return buffer3;
    }
    __name(_intToUint8Array, "_intToUint8Array");
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge12 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge12.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge12.asn1;
    var pki = forge12.pki = forge12.pki || {};
    module2.exports = pki.pbe = forge12.pbe = forge12.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge12.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge12.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge12.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge12.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge12.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge12.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge12.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge12.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge12.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge12.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge12.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge12.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge12.random.getBytesSync(16);
          cipherFn = forge12.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge12.random.getBytesSync(16);
          cipherFn = forge12.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge12.random.getBytesSync(16);
          cipherFn = forge12.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge12.random.getBytesSync(8);
          cipherFn = forge12.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge12.random.getBytesSync(8);
          cipherFn = forge12.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge12.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge12.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge12.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge12.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge12.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge12.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge12.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge12.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge12.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = /* @__PURE__ */ __name(function(key) {
              return forge12.rc2.createDecryptionCipher(key, 40);
            }, "cipherFn");
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = /* @__PURE__ */ __name(function(key) {
              return forge12.rc2.createDecryptionCipher(key, 64);
            }, "cipherFn");
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = /* @__PURE__ */ __name(function(key) {
              return forge12.rc2.createDecryptionCipher(key, 128);
            }, "cipherFn");
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge12.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge12.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge12.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge12.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge12.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge12.util.ByteBuffer();
      var passBuf = new forge12.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s2 = salt.length();
      var D = new forge12.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s2 / v);
      var S = new forge12.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s2));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge12.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf3 = new forge12.util.ByteBuffer();
        buf3.putBytes(D.bytes());
        buf3.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf3.getBytes());
          buf3 = md.digest();
        }
        var B = new forge12.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf3.at(l % u));
        }
        var k = Math.ceil(s2 / v) + Math.ceil(p / v);
        var Inew = new forge12.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge12.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf3);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge12.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge12.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge12.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge12.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge12.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge12.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge12.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge12.util.createBuffer(capture.salt);
      var count = forge12.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge12.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = /* @__PURE__ */ __name(function(key2, iv2) {
            var cipher = forge12.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          }, "cipherFn");
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge12.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge12.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash3(md, password + salt)];
      for (var length21 = 16, i = 1; length21 < dkLen; ++i, length21 += 16) {
        digests.push(hash3(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash3(md, bytes3) {
      return md.start().update(bytes3).digest().getBytes();
    }
    __name(hash3, "hash");
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    __name(prfOidToMessageDigest, "prfOidToMessageDigest");
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge12.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge12.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    __name(prfAlgorithmToMessageDigest, "prfAlgorithmToMessageDigest");
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge12.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
    __name(createPbkdf2Params, "createPbkdf2Params");
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge12 = require_forge();
    require_md();
    require_util();
    var sha51218 = module2.exports = forge12.sha512 = forge12.sha512 || {};
    forge12.md.sha512 = forge12.md.algorithms.sha512 = sha51218;
    var sha384 = forge12.sha384 = forge12.sha512.sha384 = forge12.sha512.sha384 || {};
    sha384.create = function() {
      return sha51218.create("SHA-384");
    };
    forge12.md.sha384 = forge12.md.algorithms.sha384 = sha384;
    forge12.sha512.sha256 = forge12.sha512.sha256 || {
      create: function() {
        return sha51218.create("SHA-512/256");
      }
    };
    forge12.md["sha512/256"] = forge12.md.algorithms["sha512/256"] = forge12.sha512.sha256;
    forge12.sha512.sha224 = forge12.sha512.sha224 || {
      create: function() {
        return sha51218.create("SHA-512/224");
      }
    };
    forge12.md["sha512/224"] = forge12.md.algorithms["sha512/224"] = forge12.sha512.sha224;
    sha51218.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge12.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge12.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge12.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge12.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits3 = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits3 += carry;
          finalBlock.putInt32(bits3 >>> 0);
          bits3 = next >>> 0;
        }
        finalBlock.putInt32(bits3);
        var h2 = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h2[i] = _h[i].slice(0);
        }
        _update(h2, _w, finalBlock);
        var rval = forge12.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h2.length;
        } else if (algorithm === "SHA-384") {
          hlen = h2.length - 2;
        } else {
          hlen = h2.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h2[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h2[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge12.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s2, w2, bytes3) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w22, w7, w15, w16;
      var len = bytes3.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w2[i][0] = bytes3.getInt32() >>> 0;
          w2[i][1] = bytes3.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w22 = w2[i - 2];
          hi = w22[0];
          lo = w22[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w2[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w2[i - 7];
          w16 = w2[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w2[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w2[i][1] = lo >>> 0;
        }
        a_hi = s2[0][0];
        a_lo = s2[0][1];
        b_hi = s2[1][0];
        b_lo = s2[1][1];
        c_hi = s2[2][0];
        c_lo = s2[2][1];
        d_hi = s2[3][0];
        d_lo = s2[3][1];
        e_hi = s2[4][0];
        e_lo = s2[4][1];
        f_hi = s2[5][0];
        f_lo = s2[5][1];
        g_hi = s2[6][0];
        g_lo = s2[6][1];
        h_hi = s2[7][0];
        h_lo = s2[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w2[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w2[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s2[0][1] + a_lo;
        s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[0][1] = lo >>> 0;
        lo = s2[1][1] + b_lo;
        s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[1][1] = lo >>> 0;
        lo = s2[2][1] + c_lo;
        s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[2][1] = lo >>> 0;
        lo = s2[3][1] + d_lo;
        s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[3][1] = lo >>> 0;
        lo = s2[4][1] + e_lo;
        s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[4][1] = lo >>> 0;
        lo = s2[5][1] + f_lo;
        s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[5][1] = lo >>> 0;
        lo = s2[6][1] + g_lo;
        s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[6][1] = lo >>> 0;
        lo = s2[7][1] + h_lo;
        s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[7][1] = lo >>> 0;
        len -= 128;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = /* @__PURE__ */ __name((object, name14, value) => Object.defineProperty(object, name14, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    }), "defineProperty");
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = /* @__PURE__ */ __name((value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol7 of symbols) {
          if (propertyIsEnumerable.call(value, symbol7)) {
            keys.push(symbol7);
          }
        }
      }
      return keys;
    }, "getEnumerableOwnPropertyKeys");
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    __name(clone, "clone");
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    __name(cloneArray, "cloneArray");
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    __name(cloneOptionObject, "cloneOptionObject");
    var mergeKeys = /* @__PURE__ */ __name((merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge2(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    }, "mergeKeys");
    var concatArrays = /* @__PURE__ */ __name((merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    }, "concatArrays");
    function merge2(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    __name(merge2, "merge");
    module2.exports = function(...options) {
      const config = merge2(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge2(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports2, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    __name(isHighSurrogate, "isHighSurrogate");
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    __name(isLowSurrogate, "isLowSurrogate");
    module2.exports = /* @__PURE__ */ __name(function truncate(getLength, string8, byteLength) {
      if (typeof string8 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string8.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string8.charCodeAt(i);
        segment = string8[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string8.charCodeAt(i + 1))) {
          i += 1;
          segment += string8[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string8.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string8.slice(0, i - segment.length + 1);
        }
      }
      return string8;
    }, "truncate");
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser2 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports2, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    __name(isHighSurrogate, "isHighSurrogate");
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    __name(isLowSurrogate, "isLowSurrogate");
    module2.exports = /* @__PURE__ */ __name(function getByteLength(string8) {
      if (typeof string8 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string8.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string8.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    }, "getByteLength");
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser3 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports2, module2) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser2();
    module2.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports2, module2) {
    "use strict";
    var truncate = require_browser3();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    __name(sanitize2, "sanitize");
    module2.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output3 = sanitize2(input, replacement);
      if (replacement === "") {
        return output3;
      }
      return sanitize2(output3, "");
    };
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports2) {
    (function() {
      var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = /* @__PURE__ */ __name(function(long) {
        var a, b, c, d2;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d2 = long & 255;
        return [a, b, c, d2].join(".");
      }, "long2ip");
      ip2long = /* @__PURE__ */ __name(function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      }, "ip2long");
      chr = /* @__PURE__ */ __name(function(b) {
        return b.charCodeAt(0);
      }, "chr");
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = /* @__PURE__ */ __name(function(s2) {
        var base42, dmax, i, n, start;
        n = 0;
        base42 = 10;
        dmax = "9";
        i = 0;
        if (s2.length > 1 && s2[i] === "0") {
          if (s2[i + 1] === "x" || s2[i + 1] === "X") {
            i += 2;
            base42 = 16;
          } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
            i++;
            base42 = 8;
            dmax = "7";
          }
        }
        start = i;
        while (i < s2.length) {
          if ("0" <= s2[i] && s2[i] <= dmax) {
            n = n * base42 + (chr(s2[i]) - chr0) >>> 0;
          } else if (base42 === 16) {
            if ("a" <= s2[i] && s2[i] <= "f") {
              n = n * base42 + (10 + chr(s2[i]) - chra) >>> 0;
            } else if ("A" <= s2[i] && s2[i] <= "F") {
              n = n * base42 + (10 + chr(s2[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start) {
          throw new Error("empty octet");
        }
        return [n, i];
      }, "atob");
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        __name(Netmask3, "Netmask");
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports2.ip2long = ip2long;
      exports2.long2ip = long2ip;
      exports2.Netmask = Netmask2;
    }).call(exports2);
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string8, parts) {
        if (string8.indexOf("::") !== string8.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string8.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string8 = string8.replace(/%.+$/, "");
        }
        while ((lastColon = string8.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string8.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string8.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string8 = string8.replace("::", replacement);
        if (string8[0] === ":") {
          string8 = string8.slice(1);
        }
        if (string8[string8.length - 1] === ":") {
          string8 = string8.slice(0, -1);
        }
        parts = function() {
          const ref = string8.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      __name(expandIPv6, "expandIPv6");
      function matchCIDR(first2, second4, partSize, cidrBits) {
        if (first2.length !== second4.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first2[part] >> shift !== second4[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      __name(matchCIDR, "matchCIDR");
      function parseIntAuto(string8) {
        if (hexRegex.test(string8)) {
          return parseInt(string8, 16);
        }
        if (string8[0] === "0" && !isNaN(parseInt(string8[1], 10))) {
          if (octalRegex.test(string8)) {
            return parseInt(string8, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string8} as octal`);
        }
        return parseInt(string8, 10);
      }
      __name(parseIntAuto, "parseIntAuto");
      function padPart(part, length21) {
        while (part.length < length21) {
          part = `0${part}`;
        }
        return part;
      }
      __name(padPart, "padPart");
      const ipaddr2 = {};
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        __name(IPv4, "IPv4");
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ],
          // RFC7534, RFC7535
          as112: [
            [new IPv4([192, 175, 48, 0]), 24],
            [new IPv4([192, 31, 196, 0]), 24]
          ],
          // RFC7450
          amt: [
            [new IPv4([192, 52, 193, 0]), 24]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string8) {
        try {
          const cidr = this.parseCIDR(string8);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.isIPv4 = function(string8) {
        return this.parser(string8) !== null;
      };
      ipaddr2.IPv4.isValid = function(string8) {
        try {
          new this(this.parser(string8));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidCIDR = function(string8) {
        try {
          this.parseCIDR(string8);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string8) {
        if (ipaddr2.IPv4.isValid(string8) && string8.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string8) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string8);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.parse = function(string8) {
        const parts = this.parser(string8);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr2.IPv4.parseCIDR = function(string8) {
        let match;
        if (match = string8.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.parser = function(string8) {
        let match, part, value;
        if (match = string8.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string8.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string8.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string8.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        __name(IPv6, "IPv6");
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6666
          discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC5180
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          // RFC7450
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [
            [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
            [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
          ],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
          droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
          reserved: [
            // RFC3849
            [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
            // RFC2928
            [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
          ]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes3 = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes3.push(part >> 8);
            bytes3.push(part & 255);
          }
          return bytes3;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string8 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string8)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string8;
          }
          return `${string8.substring(0, bestMatchIndex)}::${string8.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      }();
      ipaddr2.IPv6.broadcastAddressFromCIDR = function(string8) {
        try {
          const cidr = this.parseCIDR(string8);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.isIPv6 = function(string8) {
        return this.parser(string8) !== null;
      };
      ipaddr2.IPv6.isValid = function(string8) {
        if (typeof string8 === "string" && string8.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string8);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.isValidCIDR = function(string8) {
        if (typeof string8 === "string" && string8.indexOf(":") === -1) {
          return false;
        }
        try {
          this.parseCIDR(string8);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.networkAddressFromCIDR = function(string8) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string8);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.parse = function(string8) {
        const addr = this.parser(string8);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv6.parseCIDR = function(string8) {
        let maskLength, match, parsed;
        if (match = string8.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.IPv6.parser = function(string8) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string8.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string8)) {
          return expandIPv6(string8, 8);
        }
        if (match = string8.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = match[1];
          if (!match[1].endsWith("::")) {
            addr = addr.slice(0, -1);
          }
          addr = expandIPv6(addr + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.fromByteArray = function(bytes3) {
        const length21 = bytes3.length;
        if (length21 === 4) {
          return new ipaddr2.IPv4(bytes3);
        } else if (length21 === 16) {
          return new ipaddr2.IPv6(bytes3);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.isValid = function(string8) {
        return ipaddr2.IPv6.isValid(string8) || ipaddr2.IPv4.isValid(string8);
      };
      ipaddr2.isValidCIDR = function(string8) {
        return ipaddr2.IPv6.isValidCIDR(string8) || ipaddr2.IPv4.isValidCIDR(string8);
      };
      ipaddr2.parse = function(string8) {
        if (ipaddr2.IPv6.isValid(string8)) {
          return ipaddr2.IPv6.parse(string8);
        } else if (ipaddr2.IPv4.isValid(string8)) {
          return ipaddr2.IPv4.parse(string8);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string8) {
        try {
          return ipaddr2.IPv6.parseCIDR(string8);
        } catch (e) {
          try {
            return ipaddr2.IPv4.parseCIDR(string8);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.process = function(string8) {
        const addr = this.parse(string8);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr2;
      } else {
        root.ipaddr = ipaddr2;
      }
    })(exports2);
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports2, module2) {
    module2.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache16 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache16[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache16;
          cache16 = /* @__PURE__ */ Object.create(null);
        }
      }
      __name(update, "update");
      return {
        has: function(key) {
          return cache16[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache16[key] !== void 0)
            cache16[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache16[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache16[key] !== void 0)
            cache16[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache16 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js
var require_RateLimiterAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js"(exports2, module2) {
    module2.exports = class RateLimiterAbstract {
      static {
        __name(this, "RateLimiterAbstract");
      }
      /**
       *
       * @param opts Object Defaults {
       *   points: 4, // Number of points
       *   duration: 1, // Per seconds
       *   blockDuration: 0, // Block if consumed more than points in current duration for blockDuration seconds
       *   execEvenly: false, // Execute allowed actions evenly over duration
       *   execEvenlyMinDelayMs: duration * 1000 / points, // ms, works with execEvenly=true option
       *   keyPrefix: 'rlflx',
       * }
       */
      constructor(opts = {}) {
        this.points = opts.points;
        this.duration = opts.duration;
        this.blockDuration = opts.blockDuration;
        this.execEvenly = opts.execEvenly;
        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
        this.keyPrefix = opts.keyPrefix;
      }
      get points() {
        return this._points;
      }
      set points(value) {
        this._points = value >= 0 ? value : 4;
      }
      get duration() {
        return this._duration;
      }
      set duration(value) {
        this._duration = typeof value === "undefined" ? 1 : value;
      }
      get msDuration() {
        return this.duration * 1e3;
      }
      get blockDuration() {
        return this._blockDuration;
      }
      set blockDuration(value) {
        this._blockDuration = typeof value === "undefined" ? 0 : value;
      }
      get msBlockDuration() {
        return this.blockDuration * 1e3;
      }
      get execEvenly() {
        return this._execEvenly;
      }
      set execEvenly(value) {
        this._execEvenly = typeof value === "undefined" ? false : Boolean(value);
      }
      get execEvenlyMinDelayMs() {
        return this._execEvenlyMinDelayMs;
      }
      set execEvenlyMinDelayMs(value) {
        this._execEvenlyMinDelayMs = typeof value === "undefined" ? Math.ceil(this.msDuration / this.points) : value;
      }
      get keyPrefix() {
        return this._keyPrefix;
      }
      set keyPrefix(value) {
        if (typeof value === "undefined") {
          value = "rlflx";
        }
        if (typeof value !== "string") {
          throw new Error("keyPrefix must be string");
        }
        this._keyPrefix = value;
      }
      _getKeySecDuration(options = {}) {
        return options && options.customDuration >= 0 ? options.customDuration : this.duration;
      }
      getKey(key) {
        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
      }
      parseKey(rlKey) {
        return rlKey.substring(this.keyPrefix.length);
      }
      consume() {
        throw new Error("You have to implement the method 'consume'!");
      }
      penalty() {
        throw new Error("You have to implement the method 'penalty'!");
      }
      reward() {
        throw new Error("You have to implement the method 'reward'!");
      }
      get() {
        throw new Error("You have to implement the method 'get'!");
      }
      set() {
        throw new Error("You have to implement the method 'set'!");
      }
      block() {
        throw new Error("You have to implement the method 'block'!");
      }
      delete() {
        throw new Error("You have to implement the method 'delete'!");
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js
var require_BlockedKeys = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js"(exports2, module2) {
    module2.exports = class BlockedKeys {
      static {
        __name(this, "BlockedKeys");
      }
      constructor() {
        this._keys = {};
        this._addedKeysAmount = 0;
      }
      collectExpired() {
        const now = Date.now();
        Object.keys(this._keys).forEach((key) => {
          if (this._keys[key] <= now) {
            delete this._keys[key];
          }
        });
        this._addedKeysAmount = Object.keys(this._keys).length;
      }
      /**
       * Add new blocked key
       *
       * @param key String
       * @param sec Number
       */
      add(key, sec) {
        this.addMs(key, sec * 1e3);
      }
      /**
       * Add new blocked key for ms
       *
       * @param key String
       * @param ms Number
       */
      addMs(key, ms2) {
        this._keys[key] = Date.now() + ms2;
        this._addedKeysAmount++;
        if (this._addedKeysAmount > 999) {
          this.collectExpired();
        }
      }
      /**
       * 0 means not blocked
       *
       * @param key
       * @returns {number}
       */
      msBeforeExpire(key) {
        const expire = this._keys[key];
        if (expire && expire >= Date.now()) {
          this.collectExpired();
          const now = Date.now();
          return expire >= now ? expire - now : 0;
        }
        return 0;
      }
      /**
       * If key is not given, delete all data in memory
       * 
       * @param {string|undefined} key
       */
      delete(key) {
        if (key) {
          delete this._keys[key];
        } else {
          Object.keys(this._keys).forEach((key2) => {
            delete this._keys[key2];
          });
        }
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js
var require_BlockedKeys2 = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js"(exports2, module2) {
    var BlockedKeys = require_BlockedKeys();
    module2.exports = BlockedKeys;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterRes.js
var require_RateLimiterRes = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRes.js"(exports2, module2) {
    module2.exports = class RateLimiterRes {
      static {
        __name(this, "RateLimiterRes");
      }
      constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
        this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
        this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
        this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
        this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
      }
      get msBeforeNext() {
        return this._msBeforeNext;
      }
      set msBeforeNext(ms2) {
        this._msBeforeNext = ms2;
        return this;
      }
      get remainingPoints() {
        return this._remainingPoints;
      }
      set remainingPoints(p) {
        this._remainingPoints = p;
        return this;
      }
      get consumedPoints() {
        return this._consumedPoints;
      }
      set consumedPoints(p) {
        this._consumedPoints = p;
        return this;
      }
      get isFirstInDuration() {
        return this._isFirstInDuration;
      }
      set isFirstInDuration(value) {
        this._isFirstInDuration = Boolean(value);
      }
      _getDecoratedProperties() {
        return {
          remainingPoints: this.remainingPoints,
          msBeforeNext: this.msBeforeNext,
          consumedPoints: this.consumedPoints,
          isFirstInDuration: this.isFirstInDuration
        };
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this._getDecoratedProperties();
      }
      toString() {
        return JSON.stringify(this._getDecoratedProperties());
      }
      toJSON() {
        return this._getDecoratedProperties();
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js
var require_RateLimiterStoreAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var BlockedKeys = require_BlockedKeys2();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {
      static {
        __name(this, "RateLimiterStoreAbstract");
      }
      /**
       *
       * @param opts Object Defaults {
       *   ... see other in RateLimiterAbstract
       *
       *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked
       *   inMemoryBlockDuration: 10, // Block duration in seconds
       *   insuranceLimiter: RateLimiterAbstract
       * }
       */
      constructor(opts = {}) {
        super(opts);
        this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;
        this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;
        this.insuranceLimiter = opts.insuranceLimiter;
        this._inMemoryBlockedKeys = new BlockedKeys();
      }
      get client() {
        return this._client;
      }
      set client(value) {
        if (typeof value === "undefined") {
          throw new Error("storeClient is not set");
        }
        this._client = value;
      }
      /**
       * Have to be launched after consume
       * It blocks key and execute evenly depending on result from store
       *
       * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result
       *
       * @param resolve
       * @param reject
       * @param rlKey
       * @param changedPoints
       * @param storeResult
       * @param {Object} options
       * @private
       */
      _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {
        const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
        if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
          if (res.consumedPoints > this.points) {
            return reject(res);
          } else {
            return resolve(res);
          }
        } else if (res.consumedPoints > this.points) {
          let blockPromise = Promise.resolve();
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
            res.msBeforeNext = this.msBlockDuration;
            blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
          }
          if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
            this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
            res.msBeforeNext = this.msInMemoryBlockDuration;
          }
          blockPromise.then(() => {
            reject(res);
          }).catch((err) => {
            reject(err);
          });
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay < this.execEvenlyMinDelayMs) {
            delay = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve, delay, res);
        } else {
          resolve(res);
        }
      }
      _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {
        if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {
          reject(err);
        } else {
          this.insuranceLimiter[funcName](key, data, options).then((res) => {
            resolve(res);
          }).catch((res) => {
            reject(res);
          });
        }
      }
      /**
       * @deprecated Use camelCase version
       * @returns {BlockedKeys}
       * @private
       */
      get _inmemoryBlockedKeys() {
        return this._inMemoryBlockedKeys;
      }
      /**
       * @deprecated Use camelCase version
       * @param rlKey
       * @returns {number}
       */
      getInmemoryBlockMsBeforeExpire(rlKey) {
        return this.getInMemoryBlockMsBeforeExpire(rlKey);
      }
      /**
       * @deprecated Use camelCase version
       * @returns {number|number}
       */
      get inmemoryBlockOnConsumed() {
        return this.inMemoryBlockOnConsumed;
      }
      /**
       * @deprecated Use camelCase version
       * @param value
       */
      set inmemoryBlockOnConsumed(value) {
        this.inMemoryBlockOnConsumed = value;
      }
      /**
       * @deprecated Use camelCase version
       * @returns {number|number}
       */
      get inmemoryBlockDuration() {
        return this.inMemoryBlockDuration;
      }
      /**
       * @deprecated Use camelCase version
       * @param value
       */
      set inmemoryBlockDuration(value) {
        this.inMemoryBlockDuration = value;
      }
      /**
       * @deprecated Use camelCase version
       * @returns {number}
       */
      get msInmemoryBlockDuration() {
        return this.inMemoryBlockDuration * 1e3;
      }
      getInMemoryBlockMsBeforeExpire(rlKey) {
        if (this.inMemoryBlockOnConsumed > 0) {
          return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
        }
        return 0;
      }
      get inMemoryBlockOnConsumed() {
        return this._inMemoryBlockOnConsumed;
      }
      set inMemoryBlockOnConsumed(value) {
        this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;
        if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
          throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
        }
      }
      get inMemoryBlockDuration() {
        return this._inMemoryBlockDuration;
      }
      set inMemoryBlockDuration(value) {
        this._inMemoryBlockDuration = value ? parseInt(value) : 0;
        if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
          throw new Error("inMemoryBlockOnConsumed option must be set up");
        }
      }
      get msInMemoryBlockDuration() {
        return this._inMemoryBlockDuration * 1e3;
      }
      get insuranceLimiter() {
        return this._insuranceLimiter;
      }
      set insuranceLimiter(value) {
        if (typeof value !== "undefined" && !(value instanceof RateLimiterAbstract)) {
          throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
        }
        this._insuranceLimiter = value;
        if (this._insuranceLimiter) {
          this._insuranceLimiter.blockDuration = this.blockDuration;
          this._insuranceLimiter.execEvenly = this.execEvenly;
        }
      }
      /**
       * Block any key for secDuration seconds
       *
       * @param key
       * @param secDuration
       * @param {Object} options
       *
       * @return Promise<RateLimiterRes>
       */
      block(key, secDuration, options = {}) {
        const msDuration = secDuration * 1e3;
        return this._block(this.getKey(key), this.points + 1, msDuration, options);
      }
      /**
       * Set points by key for any duration
       *
       * @param key
       * @param points
       * @param secDuration
       * @param {Object} options
       *
       * @return Promise<RateLimiterRes>
       */
      set(key, points, secDuration, options = {}) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        return this._block(this.getKey(key), points, msDuration, options);
      }
      /**
       *
       * @param key
       * @param pointsToConsume
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const rlKey = this.getKey(key);
          const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
          if (inMemoryBlockMsBeforeExpire > 0) {
            return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));
          }
          this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);
          }).catch((err) => {
            this._handleError(err, "consume", resolve, reject, key, pointsToConsume, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param points
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._upsert(rlKey, points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve(this._getRateLimiterRes(rlKey, points, res));
          }).catch((err) => {
            this._handleError(err, "penalty", resolve, reject, key, points, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param points
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve(this._getRateLimiterRes(rlKey, -points, res));
          }).catch((err) => {
            this._handleError(err, "reward", resolve, reject, key, points, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param {Object} options
       * @returns Promise<RateLimiterRes>|null
       */
      get(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._get(rlKey, options).then((res) => {
            if (res === null || typeof res === "undefined") {
              resolve(null);
            } else {
              resolve(this._getRateLimiterRes(rlKey, 0, res));
            }
          }).catch((err) => {
            this._handleError(err, "get", resolve, reject, key, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param {Object} options
       * @returns Promise<boolean>
       */
      delete(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._delete(rlKey, options).then((res) => {
            this._inMemoryBlockedKeys.delete(rlKey);
            resolve(res);
          }).catch((err) => {
            this._handleError(err, "delete", resolve, reject, key, options);
          });
        });
      }
      /**
       * Cleanup keys no-matter expired or not.
       */
      deleteInMemoryBlockedAll() {
        this._inMemoryBlockedKeys.delete();
      }
      /**
       * Get RateLimiterRes object filled depending on storeResult, which specific for exact store
       *
       * @param rlKey
       * @param changedPoints
       * @param storeResult
       * @private
       */
      _getRateLimiterRes(rlKey, changedPoints, storeResult) {
        throw new Error("You have to implement the method '_getRateLimiterRes'!");
      }
      /**
       * Block key for this.msBlockDuration milliseconds
       * Usually, it just prolongs lifetime of key
       *
       * @param rlKey
       * @param initPoints
       * @param msDuration
       * @param {Object} options
       *
       * @return Promise<any>
       */
      _block(rlKey, initPoints, msDuration, options = {}) {
        return new Promise((resolve, reject) => {
          this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
            resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));
          }).catch((err) => {
            this._handleError(err, "block", resolve, reject, this.parseKey(rlKey), msDuration / 1e3, options);
          });
        });
      }
      /**
       * Have to be implemented in every limiter
       * Resolve with raw result from Store OR null if rlKey is not set
       * or Reject with error
       *
       * @param rlKey
       * @param {Object} options
       * @private
       *
       * @return Promise<any>
       */
      _get(rlKey, options = {}) {
        throw new Error("You have to implement the method '_get'!");
      }
      /**
       * Have to be implemented
       * Resolve with true OR false if rlKey doesn't exist
       * or Reject with error
       *
       * @param rlKey
       * @param {Object} options
       * @private
       *
       * @return Promise<any>
       */
      _delete(rlKey, options = {}) {
        throw new Error("You have to implement the method '_delete'!");
      }
      /**
       * Have to be implemented
       * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}
       *
       * @param {string} rlKey
       * @param {number} points
       * @param {number} msDuration
       * @param {boolean} forceExpire
       * @param {Object} options
       * @abstract
       *
       * @return Promise<Object>
       */
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        throw new Error("You have to implement the method '_upsert'!");
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js
var require_RateLimiterRedis = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
    var RateLimiterRedis = class extends RateLimiterStoreAbstract {
      static {
        __name(this, "RateLimiterRedis");
      }
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   redis: RedisClient
       *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not "ready"
       * }
       */
      constructor(opts) {
        super(opts);
        if (opts.redis) {
          this.client = opts.redis;
        } else {
          this.client = opts.storeClient;
        }
        this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
        if (typeof this.client.defineCommand === "function") {
          this.client.defineCommand("rlflxIncr", {
            numberOfKeys: 1,
            lua: incrTtlLuaScript
          });
        }
      }
      /**
       * Prevent actual redis call if redis connection is not ready
       * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.
       * For any other clients all the requests would be passed directly to redis client
       * @return {boolean}
       * @private
       */
      _isRedisReady() {
        if (!this._rejectIfRedisNotReady) {
          return true;
        }
        if (this.client.status && this.client.status !== "ready") {
          return false;
        }
        if (typeof this.client.isReady === "function" && !this.client.isReady()) {
          return false;
        }
        return true;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        let [consumed, resTtlMs] = result;
        if (Array.isArray(consumed)) {
          [, consumed] = consumed;
          [, resTtlMs] = resTtlMs;
        }
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(consumed);
        res.isFirstInDuration = res.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = resTtlMs;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false) {
        return new Promise((resolve, reject) => {
          if (!this._isRedisReady()) {
            return reject(new Error("Redis connection is not ready"));
          }
          const secDuration = Math.floor(msDuration / 1e3);
          const multi = this.client.multi();
          if (forceExpire) {
            if (secDuration > 0) {
              multi.set(rlKey, points, "EX", secDuration);
            } else {
              multi.set(rlKey, points);
            }
            multi.pttl(rlKey).exec((err, res) => {
              if (err) {
                return reject(err);
              }
              return resolve(res);
            });
          } else {
            if (secDuration > 0) {
              const incrCallback = /* @__PURE__ */ __name(function(err, result) {
                if (err) {
                  return reject(err);
                }
                return resolve(result);
              }, "incrCallback");
              if (typeof this.client.rlflxIncr === "function") {
                this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
              } else {
                this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
              }
            } else {
              multi.incrby(rlKey, points).pttl(rlKey).exec((err, res) => {
                if (err) {
                  return reject(err);
                }
                return resolve(res);
              });
            }
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve, reject) => {
          if (!this._isRedisReady()) {
            return reject(new Error("Redis connection is not ready"));
          }
          this.client.multi().get(rlKey).pttl(rlKey).exec((err, res) => {
            if (err) {
              reject(err);
            } else {
              const [points] = res;
              if (points === null) {
                return resolve(null);
              }
              resolve(res);
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve, reject) => {
          this.client.del(rlKey, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res > 0);
            }
          });
        });
      }
    };
    module2.exports = RateLimiterRedis;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js
var require_RateLimiterMongo = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    function getDriverVersion(client) {
      try {
        const _client = client.client ? client.client : client;
        const { version: version4 } = _client.topology.s.options.metadata.driver;
        const _v = version4.split(".").map((v) => parseInt(v));
        return {
          major: _v[0],
          feature: _v[1],
          patch: _v[2]
        };
      } catch (err) {
        return { major: 0, feature: 0, patch: 0 };
      }
    }
    __name(getDriverVersion, "getDriverVersion");
    var RateLimiterMongo = class _RateLimiterMongo extends RateLimiterStoreAbstract {
      static {
        __name(this, "RateLimiterMongo");
      }
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   indexKeyPrefix: {attr1: 1, attr2: 1}
       *   ... see other in RateLimiterStoreAbstract
       *
       *   mongo: MongoClient
       * }
       */
      constructor(opts) {
        super(opts);
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.indexKeyPrefix = opts.indexKeyPrefix;
        if (opts.mongo) {
          this.client = opts.mongo;
        } else {
          this.client = opts.storeClient;
        }
        if (typeof this.client.then === "function") {
          this.client.then((conn) => {
            this.client = conn;
            this._initCollection();
            this._driverVersion = getDriverVersion(this.client);
          });
        } else {
          this._initCollection();
          this._driverVersion = getDriverVersion(this.client);
        }
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value) {
        this._dbName = typeof value === "undefined" ? _RateLimiterMongo.getDbName() : value;
      }
      static getDbName() {
        return "node-rate-limiter-flexible";
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get client() {
        return this._client;
      }
      set client(value) {
        if (typeof value === "undefined") {
          throw new Error("mongo is not set");
        }
        this._client = value;
      }
      get indexKeyPrefix() {
        return this._indexKeyPrefix;
      }
      set indexKeyPrefix(obj) {
        this._indexKeyPrefix = obj || {};
      }
      _initCollection() {
        const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
        const collection = db.collection(this.tableName);
        collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
        collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
        this._collection = collection;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        let doc;
        if (typeof result.value === "undefined") {
          doc = result;
        } else {
          doc = result.value;
        }
        res.isFirstInDuration = doc.points === changedPoints;
        res.consumedPoints = doc.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
        return res;
      }
      _upsert(key, points, msDuration, forceExpire = false, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        let where;
        let upsertData;
        if (forceExpire) {
          where = { key };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $set: {
              key,
              points,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            }
          };
          upsertData.$set = Object.assign(upsertData.$set, docAttrs);
        } else {
          where = {
            $or: [
              { expire: { $gt: /* @__PURE__ */ new Date() } },
              { expire: { $eq: null } }
            ],
            key
          };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $setOnInsert: {
              key,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            },
            $inc: { points }
          };
          upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
        }
        const upsertOptions = {
          upsert: true
        };
        if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
          upsertOptions.returnDocument = "after";
        } else {
          upsertOptions.returnOriginal = false;
        }
        return new Promise((resolve, reject) => {
          this._collection.findOneAndUpdate(
            where,
            upsertData,
            upsertOptions
          ).then((res) => {
            resolve(res);
          }).catch((errUpsert) => {
            if (errUpsert && errUpsert.code === 11e3) {
              const replaceWhere = Object.assign({
                // try to replace OLD limit doc
                $or: [
                  { expire: { $lte: /* @__PURE__ */ new Date() } },
                  { expire: { $eq: null } }
                ],
                key
              }, docAttrs);
              const replaceTo = {
                $set: Object.assign({
                  key,
                  points,
                  expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
                }, docAttrs)
              };
              this._collection.findOneAndUpdate(
                replaceWhere,
                replaceTo,
                upsertOptions
              ).then((res) => {
                resolve(res);
              }).catch((errReplace) => {
                if (errReplace && errReplace.code === 11e3) {
                  this._upsert(key, points, msDuration, forceExpire).then((res) => resolve(res)).catch((err) => reject(err));
                } else {
                  reject(errReplace);
                }
              });
            } else {
              reject(errUpsert);
            }
          });
        });
      }
      _get(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({
          key: rlKey,
          $or: [
            { expire: { $gt: /* @__PURE__ */ new Date() } },
            { expire: { $eq: null } }
          ]
        }, docAttrs);
        return this._collection.findOne(where);
      }
      _delete(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({ key: rlKey }, docAttrs);
        return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
      }
    };
    module2.exports = RateLimiterMongo;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js
var require_RateLimiterMySQL = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMySQL = class extends RateLimiterStoreAbstract {
      static {
        __name(this, "RateLimiterMySQL");
      }
      /**
       * @callback callback
       * @param {Object} err
       *
       * @param {Object} opts
       * @param {callback} cb
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: anySqlClient,
       *   storeType: 'knex', // required only for Knex instance
       *   dbName: 'string',
       *   tableName: 'string',
       * }
       */
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createDbAndTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err) => {
            if (typeof cb === "function") {
              cb(err);
            } else {
              throw err;
            }
          });
        } else {
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve) => {
          this._getConnection().then((conn) => {
            conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
              this._releaseConnection(conn);
              resolve();
            });
          }).catch(() => {
            resolve();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      /**
       *
       * @return Promise<any>
       * @private
       */
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return new Promise((resolve, reject) => {
              this.client.getConnection((errConn, conn) => {
                if (errConn) {
                  return reject(errConn);
                }
                resolve(conn);
              });
            });
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return conn.release();
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          default:
            return true;
        }
      }
      /**
       *
       * @returns {Promise<any>}
       * @private
       */
      _createDbAndTable() {
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
              if (errDb) {
                this._releaseConnection(conn);
                return reject(errDb);
              }
              conn.query(this._getCreateTableStmt(), (err) => {
                if (err) {
                  this._releaseConnection(conn);
                  return reject(err);
                }
                this._releaseConnection(conn);
                resolve();
              });
            });
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value) {
        if (typeof value === "undefined") {
          if (this.client.constructor.name === "Connection") {
            value = "connection";
          } else if (this.client.constructor.name === "Pool") {
            value = "pool";
          } else if (this.client.constructor.name === "Sequelize") {
            value = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value.toLowerCase();
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value) {
        this._dbName = typeof value === "undefined" ? "rtlmtrflx" : value;
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value) {
        this._tableCreated = typeof value === "undefined" ? false : !!value;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value) {
        this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const [row] = result;
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _upsertTransaction(conn, key, points, msDuration, forceExpire) {
        return new Promise((resolve, reject) => {
          conn.query("BEGIN", (errBegin) => {
            if (errBegin) {
              conn.rollback();
              return reject(errBegin);
            }
            const dateNow = Date.now();
            const newExpire = msDuration > 0 ? dateNow + msDuration : null;
            let q;
            let values;
            if (forceExpire) {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                points,
                newExpire
              ];
            } else {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                dateNow,
                points,
                points,
                dateNow,
                newExpire
              ];
            }
            conn.query(q, values, (errUpsert) => {
              if (errUpsert) {
                conn.rollback();
                return reject(errUpsert);
              }
              conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
                if (errSelect) {
                  conn.rollback();
                  return reject(errSelect);
                }
                conn.query("COMMIT", (err) => {
                  if (err) {
                    conn.rollback();
                    return reject(err);
                  }
                  resolve(res);
                });
              });
            });
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
              resolve(res);
              this._releaseConnection(conn);
            }).catch((err) => {
              reject(err);
              this._releaseConnection(conn);
            });
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
              [this.dbName, this.tableName, rlKey, Date.now()],
              (err, res) => {
                if (err) {
                  reject(err);
                } else if (res.length === 0) {
                  resolve(null);
                } else {
                  resolve(res);
                }
                this._releaseConnection(conn);
              }
              // eslint-disable-line
            );
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "DELETE FROM ??.?? WHERE `key` = ?",
              [this.dbName, this.tableName, rlKey],
              (err, res) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res.affectedRows > 0);
                }
                this._releaseConnection(conn);
              }
              // eslint-disable-line
            );
          }).catch((err) => {
            reject(err);
          });
        });
      }
    };
    module2.exports = RateLimiterMySQL;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js
var require_RateLimiterPostgres = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterPostgres = class extends RateLimiterStoreAbstract {
      static {
        __name(this, "RateLimiterPostgres");
      }
      /**
       * @callback callback
       * @param {Object} err
       *
       * @param {Object} opts
       * @param {callback} cb
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: postgresClient,
       *   storeType: 'knex', // required only for Knex instance
       *   tableName: 'string',
       * }
       */
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err) => {
            if (typeof cb === "function") {
              cb(err);
            } else {
              throw err;
            }
          });
        } else {
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve) => {
          const q = {
            name: "rlflx-clear-expired",
            text: `DELETE FROM ${this.tableName} WHERE expire < $1`,
            values: [expire]
          };
          this._query(q).then(() => {
            resolve();
          }).catch(() => {
            resolve();
          });
        });
      }
      /**
       * Delete all rows expired 1 hour ago once per 5 minutes
       *
       * @private
       */
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      /**
       *
       * @return Promise<any>
       * @private
       */
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return Promise.resolve(this.client);
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          case "typeorm":
            return Promise.resolve(this.client.driver.master);
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return true;
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          case "typeorm":
            return true;
          default:
            return true;
        }
      }
      /**
       *
       * @returns {Promise<any>}
       * @private
       */
      _createTable() {
        return new Promise((resolve, reject) => {
          this._query({
            text: this._getCreateTableStmt()
          }).then(() => {
            resolve();
          }).catch((err) => {
            if (err.code === "23505") {
              resolve();
            } else {
              reject(err);
            }
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value) {
        const constructorName = this.client.constructor.name;
        if (typeof value === "undefined") {
          if (constructorName === "Client") {
            value = "client";
          } else if (constructorName === "Pool" || constructorName === "BoundPool") {
            value = "pool";
          } else if (constructorName === "Sequelize") {
            value = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value.toLowerCase();
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value) {
        this._tableCreated = typeof value === "undefined" ? false : !!value;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value) {
        this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const row = result.rows[0];
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _query(q) {
        const prefix = this.tableName.toLowerCase();
        const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(queryObj).then((res) => {
              resolve(res);
              this._releaseConnection(conn);
            }).catch((err) => {
              reject(err);
              this._releaseConnection(conn);
            });
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
        const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;
        return this._query({
          name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
          text: `
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
          values: [key, points, newExpire, Date.now()]
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._query({
            name: "rlflx-get",
            text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
            values: [rlKey, Date.now()]
          }).then((res) => {
            if (res.rowCount === 0) {
              res = null;
            }
            resolve(res);
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return this._query({
          name: "rlflx-delete",
          text: `DELETE FROM ${this.tableName} WHERE key = $1`,
          values: [rlKey]
        }).then((res) => res.rowCount > 0);
      }
    };
    module2.exports = RateLimiterPostgres;
  }
});

// (disabled):cluster
var require_cluster = __commonJS({
  "(disabled):cluster"() {
  }
});

// node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js
var require_Record = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js"(exports2, module2) {
    module2.exports = class Record {
      static {
        __name(this, "Record");
      }
      /**
       *
       * @param value int
       * @param expiresAt Date|int
       * @param timeoutId
       */
      constructor(value, expiresAt, timeoutId = null) {
        this.value = value;
        this.expiresAt = expiresAt;
        this.timeoutId = timeoutId;
      }
      get value() {
        return this._value;
      }
      set value(value) {
        this._value = parseInt(value);
      }
      get expiresAt() {
        return this._expiresAt;
      }
      set expiresAt(value) {
        if (!(value instanceof Date) && Number.isInteger(value)) {
          value = new Date(value);
        }
        this._expiresAt = value;
      }
      get timeoutId() {
        return this._timeoutId;
      }
      set timeoutId(value) {
        this._timeoutId = value;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js
var require_MemoryStorage = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js"(exports2, module2) {
    var Record3 = require_Record();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class MemoryStorage {
      static {
        __name(this, "MemoryStorage");
      }
      constructor() {
        this._storage = {};
      }
      incrby(key, value, durationSec) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
          if (msBeforeExpires !== 0) {
            this._storage[key].value = this._storage[key].value + value;
            return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
          }
          return this.set(key, value, durationSec);
        }
        return this.set(key, value, durationSec);
      }
      set(key, value, durationSec) {
        const durationMs = durationSec * 1e3;
        if (this._storage[key] && this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        this._storage[key] = new Record3(
          value,
          durationMs > 0 ? new Date(Date.now() + durationMs) : null
        );
        if (durationMs > 0) {
          this._storage[key].timeoutId = setTimeout(() => {
            delete this._storage[key];
          }, durationMs);
          if (this._storage[key].timeoutId.unref) {
            this._storage[key].timeoutId.unref();
          }
        }
        return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
      }
      /**
       *
       * @param key
       * @returns {*}
       */
      get(key) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
          return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
        }
        return null;
      }
      /**
       *
       * @param key
       * @returns {boolean}
       */
      delete(key) {
        if (this._storage[key]) {
          if (this._storage[key].timeoutId) {
            clearTimeout(this._storage[key].timeoutId);
          }
          delete this._storage[key];
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js
var require_RateLimiterMemory = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var MemoryStorage = require_MemoryStorage();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemory3 = class extends RateLimiterAbstract {
      static {
        __name(this, "RateLimiterMemory");
      }
      constructor(opts = {}) {
        super(opts);
        this._memoryStorage = new MemoryStorage();
      }
      /**
       *
       * @param key
       * @param pointsToConsume
       * @param {Object} options
       * @returns {Promise<RateLimiterRes>}
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const rlKey = this.getKey(key);
          const secDuration = this._getKeySecDuration(options);
          let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          if (res.consumedPoints > this.points) {
            if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
              res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
            }
            reject(res);
          } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
            let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
            if (delay < this.execEvenlyMinDelayMs) {
              delay = res.consumedPoints * this.execEvenlyMinDelayMs;
            }
            setTimeout(resolve, delay, res);
          } else {
            resolve(res);
          }
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve(res);
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve(res);
        });
      }
      /**
       * Block any key for secDuration seconds
       *
       * @param key
       * @param secDuration
       */
      block(key, secDuration) {
        const msDuration = secDuration * 1e3;
        const initPoints = this.points + 1;
        this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)
        );
      }
      set(key, points, secDuration) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        this._memoryStorage.set(this.getKey(key), points, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)
        );
      }
      get(key) {
        const res = this._memoryStorage.get(this.getKey(key));
        if (res !== null) {
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        }
        return Promise.resolve(res);
      }
      delete(key) {
        return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
      }
    };
    module2.exports = RateLimiterMemory3;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js
var require_RateLimiterCluster = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"(exports2, module2) {
    var cluster = require_cluster();
    var crypto5 = require_crypto();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var RateLimiterMemory3 = require_RateLimiterMemory();
    var RateLimiterRes = require_RateLimiterRes();
    var channel = "rate_limiter_flexible";
    var masterInstance = null;
    var masterSendToWorker = /* @__PURE__ */ __name(function(worker, msg, type, res) {
      let data;
      if (res === null || res === true || res === false) {
        data = res;
      } else {
        data = {
          remainingPoints: res.remainingPoints,
          msBeforeNext: res.msBeforeNext,
          consumedPoints: res.consumedPoints,
          isFirstInDuration: res.isFirstInDuration
        };
      }
      worker.send({
        channel,
        keyPrefix: msg.keyPrefix,
        // which rate limiter exactly
        promiseId: msg.promiseId,
        type,
        data
      });
    }, "masterSendToWorker");
    var workerWaitInit = /* @__PURE__ */ __name(function(payload) {
      setTimeout(() => {
        if (this._initiated) {
          process.send(payload);
        } else if (typeof this._promises[payload.promiseId] !== "undefined") {
          workerWaitInit.call(this, payload);
        }
      }, 30);
    }, "workerWaitInit");
    var workerSendToMaster = /* @__PURE__ */ __name(function(func, promiseId, key, arg, opts) {
      const payload = {
        channel,
        keyPrefix: this.keyPrefix,
        func,
        promiseId,
        data: {
          key,
          arg,
          opts
        }
      };
      if (!this._initiated) {
        workerWaitInit.call(this, payload);
      } else {
        process.send(payload);
      }
    }, "workerSendToMaster");
    var masterProcessMsg = /* @__PURE__ */ __name(function(worker, msg) {
      if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
        return false;
      }
      let promise;
      switch (msg.func) {
        case "consume":
          promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "penalty":
          promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "reward":
          promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "block":
          promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "get":
          promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
          break;
        case "delete":
          promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
          break;
        default:
          return false;
      }
      if (promise) {
        promise.then((res) => {
          masterSendToWorker(worker, msg, "resolve", res);
        }).catch((rejRes) => {
          masterSendToWorker(worker, msg, "reject", rejRes);
        });
      }
    }, "masterProcessMsg");
    var workerProcessMsg = /* @__PURE__ */ __name(function(msg) {
      if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
        return false;
      }
      if (this._promises[msg.promiseId]) {
        clearTimeout(this._promises[msg.promiseId].timeoutId);
        let res;
        if (msg.data === null || msg.data === true || msg.data === false) {
          res = msg.data;
        } else {
          res = new RateLimiterRes(
            msg.data.remainingPoints,
            msg.data.msBeforeNext,
            msg.data.consumedPoints,
            msg.data.isFirstInDuration
            // eslint-disable-line comma-dangle
          );
        }
        switch (msg.type) {
          case "resolve":
            this._promises[msg.promiseId].resolve(res);
            break;
          case "reject":
            this._promises[msg.promiseId].reject(res);
            break;
          default:
            throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
        }
        delete this._promises[msg.promiseId];
      }
    }, "workerProcessMsg");
    var getOpts = /* @__PURE__ */ __name(function() {
      return {
        points: this.points,
        duration: this.duration,
        blockDuration: this.blockDuration,
        execEvenly: this.execEvenly,
        execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
        keyPrefix: this.keyPrefix
      };
    }, "getOpts");
    var savePromise = /* @__PURE__ */ __name(function(resolve, reject) {
      const hrtime = process.hrtime();
      let promiseId = hrtime[0].toString() + hrtime[1].toString();
      if (typeof this._promises[promiseId] !== "undefined") {
        promiseId += crypto5.randomBytes(12).toString("base64");
      }
      this._promises[promiseId] = {
        resolve,
        reject,
        timeoutId: setTimeout(() => {
          delete this._promises[promiseId];
          reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
        }, this.timeoutMs)
      };
      return promiseId;
    }, "savePromise");
    var RateLimiterClusterMaster = class {
      static {
        __name(this, "RateLimiterClusterMaster");
      }
      constructor() {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        cluster.setMaxListeners(0);
        cluster.on("message", (worker, msg) => {
          if (msg && msg.channel === channel && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory3(msg.opts);
            }
            worker.send({
              channel,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            });
          } else {
            masterProcessMsg.call(this, worker, msg);
          }
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterMasterPM2 = class {
      static {
        __name(this, "RateLimiterClusterMasterPM2");
      }
      constructor(pm2) {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        pm2.launchBus((err, pm2Bus) => {
          pm2Bus.on("process:msg", (packet) => {
            const msg = packet.raw;
            if (msg && msg.channel === channel && msg.type === "init") {
              if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
                this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory3(msg.opts);
              }
              pm2.sendDataToProcessId(packet.process.pm_id, {
                data: {},
                topic: channel,
                channel,
                type: "init",
                keyPrefix: msg.opts.keyPrefix
              }, (sendErr, res) => {
                if (sendErr) {
                  console.log(sendErr, res);
                }
              });
            } else {
              const worker = {
                send: (msgData) => {
                  const pm2Message = msgData;
                  pm2Message.topic = channel;
                  if (typeof pm2Message.data === "undefined") {
                    pm2Message.data = {};
                  }
                  pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {
                    if (sendErr) {
                      console.log(sendErr, res);
                    }
                  });
                }
              };
              masterProcessMsg.call(this, worker, msg);
            }
          });
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterWorker = class extends RateLimiterAbstract {
      static {
        __name(this, "RateLimiterClusterWorker");
      }
      get timeoutMs() {
        return this._timeoutMs;
      }
      set timeoutMs(value) {
        this._timeoutMs = typeof value === "undefined" ? 5e3 : Math.abs(parseInt(value));
      }
      constructor(opts = {}) {
        super(opts);
        process.setMaxListeners(0);
        this.timeoutMs = opts.timeoutMs;
        this._initiated = false;
        process.on("message", (msg) => {
          if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
            this._initiated = true;
          } else {
            workerProcessMsg.call(this, msg);
          }
        });
        process.send({
          channel,
          type: "init",
          opts: getOpts.call(this)
        });
        this._promises = {};
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
        });
      }
      penalty(key, points = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
        });
      }
      reward(key, points = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "reward", promiseId, key, points, options);
        });
      }
      block(key, secDuration, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
        });
      }
      get(key, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "get", promiseId, key, options);
        });
      }
      delete(key, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "delete", promiseId, key, options);
        });
      }
    };
    module2.exports = {
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster: RateLimiterClusterWorker
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js
var require_RateLimiterMemcache = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemcache = class extends RateLimiterStoreAbstract {
      static {
        __name(this, "RateLimiterMemcache");
      }
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: memcacheClient
       * }
       */
      constructor(opts) {
        super(opts);
        this.client = opts.storeClient;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(result.consumedPoints);
        res.isFirstInDuration = result.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = result.msBeforeNext;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        return new Promise((resolve, reject) => {
          const nowMs = Date.now();
          const secDuration = Math.floor(msDuration / 1e3);
          if (forceExpire) {
            this.client.set(rlKey, points, secDuration, (err) => {
              if (!err) {
                this.client.set(
                  `${rlKey}_expire`,
                  secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                  secDuration,
                  () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                    };
                    resolve(res);
                  }
                );
              } else {
                reject(err);
              }
            });
          } else {
            this.client.incr(rlKey, points, (err, consumedPoints) => {
              if (err || consumedPoints === false) {
                this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                  if (errAddKey || !createdNew) {
                    if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                      const nextOptions = Object.assign({}, options);
                      nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                      this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve(resUpsert)).catch((errUpsert) => reject(errUpsert));
                    } else {
                      reject(new Error("Can not add key"));
                    }
                  } else {
                    this.client.add(
                      `${rlKey}_expire`,
                      secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                      secDuration,
                      () => {
                        const res = {
                          consumedPoints: points,
                          msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                        };
                        resolve(res);
                      }
                    );
                  }
                });
              } else {
                this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                  if (errGetExpire) {
                    reject(errGetExpire);
                  } else {
                    const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                    const res = {
                      consumedPoints,
                      msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                    };
                    resolve(res);
                  }
                });
              }
            });
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve, reject) => {
          const nowMs = Date.now();
          this.client.get(rlKey, (err, consumedPoints) => {
            if (!consumedPoints) {
              resolve(null);
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve(res);
                }
              });
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve, reject) => {
          this.client.del(rlKey, (err, res) => {
            if (err) {
              reject(err);
            } else if (res === false) {
              resolve(res);
            } else {
              this.client.del(`${rlKey}_expire`, (errDelExpire) => {
                if (errDelExpire) {
                  reject(errDelExpire);
                } else {
                  resolve(res);
                }
              });
            }
          });
        });
      }
    };
    module2.exports = RateLimiterMemcache;
  }
});

// node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js
var require_RLWrapperBlackAndWhite = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js"(exports2, module2) {
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class RLWrapperBlackAndWhite {
      static {
        __name(this, "RLWrapperBlackAndWhite");
      }
      constructor(opts = {}) {
        this.limiter = opts.limiter;
        this.blackList = opts.blackList;
        this.whiteList = opts.whiteList;
        this.isBlackListed = opts.isBlackListed;
        this.isWhiteListed = opts.isWhiteListed;
        this.runActionAnyway = opts.runActionAnyway;
      }
      get limiter() {
        return this._limiter;
      }
      set limiter(value) {
        if (typeof value === "undefined") {
          throw new Error("limiter is not set");
        }
        this._limiter = value;
      }
      get runActionAnyway() {
        return this._runActionAnyway;
      }
      set runActionAnyway(value) {
        this._runActionAnyway = typeof value === "undefined" ? false : value;
      }
      get blackList() {
        return this._blackList;
      }
      set blackList(value) {
        this._blackList = Array.isArray(value) ? value : [];
      }
      get isBlackListed() {
        return this._isBlackListed;
      }
      set isBlackListed(func) {
        if (typeof func === "undefined") {
          func = /* @__PURE__ */ __name(() => false, "func");
        }
        if (typeof func !== "function") {
          throw new Error("isBlackListed must be function");
        }
        this._isBlackListed = func;
      }
      get whiteList() {
        return this._whiteList;
      }
      set whiteList(value) {
        this._whiteList = Array.isArray(value) ? value : [];
      }
      get isWhiteListed() {
        return this._isWhiteListed;
      }
      set isWhiteListed(func) {
        if (typeof func === "undefined") {
          func = /* @__PURE__ */ __name(() => false, "func");
        }
        if (typeof func !== "function") {
          throw new Error("isWhiteListed must be function");
        }
        this._isWhiteListed = func;
      }
      isBlackListedSomewhere(key) {
        return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
      }
      isWhiteListedSomewhere(key) {
        return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
      }
      getBlackRes() {
        return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);
      }
      getWhiteRes() {
        return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);
      }
      rejectBlack() {
        return Promise.reject(this.getBlackRes());
      }
      resolveBlack() {
        return Promise.resolve(this.getBlackRes());
      }
      resolveWhite() {
        return Promise.resolve(this.getWhiteRes());
      }
      consume(key, pointsToConsume = 1) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.rejectBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.consume(key, pointsToConsume);
        }
        if (this.runActionAnyway) {
          this.limiter.consume(key, pointsToConsume).catch(() => {
          });
        }
        return res;
      }
      block(key, secDuration) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.block(key, secDuration);
        }
        if (this.runActionAnyway) {
          this.limiter.block(key, secDuration).catch(() => {
          });
        }
        return res;
      }
      penalty(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.penalty(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.penalty(key, points).catch(() => {
          });
        }
        return res;
      }
      reward(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.reward(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.reward(key, points).catch(() => {
          });
        }
        return res;
      }
      get(key) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined" || this.runActionAnyway) {
          return this.limiter.get(key);
        }
        return res;
      }
      delete(key) {
        return this.limiter.delete(key);
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js
var require_RateLimiterUnion = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    module2.exports = class RateLimiterUnion {
      static {
        __name(this, "RateLimiterUnion");
      }
      constructor(...limiters) {
        if (limiters.length < 1) {
          throw new Error("RateLimiterUnion: at least one limiter have to be passed");
        }
        limiters.forEach((limiter) => {
          if (!(limiter instanceof RateLimiterAbstract)) {
            throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
          }
        });
        this._limiters = limiters;
      }
      consume(key, points = 1) {
        return new Promise((resolve, reject) => {
          const promises = [];
          this._limiters.forEach((limiter) => {
            promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
          });
          Promise.all(promises).then((res) => {
            const resObj = {};
            let rejected = false;
            res.forEach((item) => {
              if (item.rejected === true) {
                rejected = true;
              }
            });
            for (let i = 0; i < res.length; i++) {
              if (rejected && res[i].rejected === true) {
                resObj[this._limiters[i].keyPrefix] = res[i].rej;
              } else if (!rejected) {
                resObj[this._limiters[i].keyPrefix] = res[i];
              }
            }
            if (rejected) {
              reject(resObj);
            } else {
              resolve(resObj);
            }
          });
        });
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js
var require_RateLimiterQueueError = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js"(exports2, module2) {
    module2.exports = class RateLimiterQueueError extends Error {
      static {
        __name(this, "RateLimiterQueueError");
      }
      constructor(message2, extra) {
        super();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "CustomError";
        this.message = message2;
        if (extra) {
          this.extra = extra;
        }
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js
var require_RateLimiterQueue = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js"(exports2, module2) {
    var RateLimiterQueueError = require_RateLimiterQueueError();
    var MAX_QUEUE_SIZE = 4294967295;
    var KEY_DEFAULT = "limiter";
    module2.exports = class RateLimiterQueue {
      static {
        __name(this, "RateLimiterQueue");
      }
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE
      }) {
        this._queueLimiters = {
          KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
        };
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining(key = KEY_DEFAULT) {
        if (this._queueLimiters[key]) {
          return this._queueLimiters[key].getTokensRemaining();
        } else {
          return Promise.resolve(this._limiterFlexible.points);
        }
      }
      removeTokens(tokens, key = KEY_DEFAULT) {
        if (!this._queueLimiters[key]) {
          this._queueLimiters[key] = new RateLimiterQueueInternal(
            this._limiterFlexible,
            {
              key,
              maxQueueSize: this._maxQueueSize
            }
          );
        }
        return this._queueLimiters[key].removeTokens(tokens);
      }
    };
    var RateLimiterQueueInternal = class {
      static {
        __name(this, "RateLimiterQueueInternal");
      }
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE,
        key: KEY_DEFAULT
      }) {
        this._key = opts.key;
        this._waitTimeout = null;
        this._queue = [];
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining() {
        return this._limiterFlexible.get(this._key).then((rlRes) => {
          return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
        });
      }
      removeTokens(tokens) {
        const _this = this;
        return new Promise((resolve, reject) => {
          if (tokens > _this._limiterFlexible.points) {
            reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
            return;
          }
          if (_this._queue.length > 0) {
            _this._queueRequest.call(_this, resolve, reject, tokens);
          } else {
            _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
              resolve(res.remainingPoints);
            }).catch((rej) => {
              if (rej instanceof Error) {
                reject(rej);
              } else {
                _this._queueRequest.call(_this, resolve, reject, tokens);
                if (_this._waitTimeout === null) {
                  _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
                }
              }
            });
          }
        });
      }
      _queueRequest(resolve, reject, tokens) {
        const _this = this;
        if (_this._queue.length < _this._maxQueueSize) {
          _this._queue.push({ resolve, reject, tokens });
        } else {
          reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
        }
      }
      _processFIFO() {
        const _this = this;
        if (_this._waitTimeout !== null) {
          clearTimeout(_this._waitTimeout);
          _this._waitTimeout = null;
        }
        if (_this._queue.length === 0) {
          return;
        }
        const item = _this._queue.shift();
        _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
          item.resolve(res.remainingPoints);
          _this._processFIFO.call(_this);
        }).catch((rej) => {
          if (rej instanceof Error) {
            item.reject(rej);
            _this._processFIFO.call(_this);
          } else {
            _this._queue.unshift(item);
            if (_this._waitTimeout === null) {
              _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
            }
          }
        });
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js
var require_BurstyRateLimiter = __commonJS({
  "node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"(exports2, module2) {
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class BurstyRateLimiter {
      static {
        __name(this, "BurstyRateLimiter");
      }
      constructor(rateLimiter, burstLimiter) {
        this._rateLimiter = rateLimiter;
        this._burstLimiter = burstLimiter;
      }
      /**
       * Merge rate limiter response objects. Responses can be null
       *
       * @param {RateLimiterRes} [rlRes] Rate limiter response
       * @param {RateLimiterRes} [blRes] Bursty limiter response
       */
      _combineRes(rlRes, blRes) {
        if (!rlRes) {
          return null;
        }
        return new RateLimiterRes(
          rlRes.remainingPoints,
          Math.min(rlRes.msBeforeNext, blRes ? blRes.msBeforeNext : 0),
          rlRes.consumedPoints,
          rlRes.isFirstInDuration
        );
      }
      /**
       * @param key
       * @param pointsToConsume
       * @param options
       * @returns {Promise<any>}
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
          if (rlRej instanceof RateLimiterRes) {
            return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
              return Promise.resolve(this._combineRes(rlRej, blRes));
            }).catch(
              (blRej) => {
                if (blRej instanceof RateLimiterRes) {
                  return Promise.reject(this._combineRes(rlRej, blRej));
                } else {
                  return Promise.reject(blRej);
                }
              }
            );
          } else {
            return Promise.reject(rlRej);
          }
        });
      }
      /**
       * It doesn't expose available points from burstLimiter
       *
       * @param key
       * @returns {Promise<RateLimiterRes>}
       */
      get(key) {
        return Promise.all([
          this._rateLimiter.get(key),
          this._burstLimiter.get(key)
        ]).then(([rlRes, blRes]) => {
          return this._combineRes(rlRes, blRes);
        });
      }
      get points() {
        return this._rateLimiter.points;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/index.js
var require_rate_limiter_flexible = __commonJS({
  "node_modules/rate-limiter-flexible/index.js"(exports2, module2) {
    var RateLimiterRedis = require_RateLimiterRedis();
    var RateLimiterMongo = require_RateLimiterMongo();
    var RateLimiterMySQL = require_RateLimiterMySQL();
    var RateLimiterPostgres = require_RateLimiterPostgres();
    var { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = require_RateLimiterCluster();
    var RateLimiterMemory3 = require_RateLimiterMemory();
    var RateLimiterMemcache = require_RateLimiterMemcache();
    var RLWrapperBlackAndWhite = require_RLWrapperBlackAndWhite();
    var RateLimiterUnion = require_RateLimiterUnion();
    var RateLimiterQueue = require_RateLimiterQueue();
    var BurstyRateLimiter = require_BurstyRateLimiter();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = {
      RateLimiterRedis,
      RateLimiterMongo,
      RateLimiterMySQL,
      RateLimiterPostgres,
      RateLimiterMemory: RateLimiterMemory3,
      RateLimiterMemcache,
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster,
      RLWrapperBlackAndWhite,
      RateLimiterUnion,
      RateLimiterQueue,
      BurstyRateLimiter,
      RateLimiterRes
    };
  }
});

// node_modules/libp2p/node_modules/eventemitter3/index.js
var require_eventemitter33 = __commonJS({
  "node_modules/libp2p/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    __name(Events, "Events");
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    function EventEmitter10() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    __name(EventEmitter10, "EventEmitter");
    EventEmitter10.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      var names4 = [], events2, name14;
      if (this._eventsCount === 0)
        return names4;
      for (name14 in events2 = this._events) {
        if (has.call(events2, name14))
          names4.push(prefix ? name14.slice(1) : name14);
      }
      if (Object.getOwnPropertySymbols) {
        return names4.concat(Object.getOwnPropertySymbols(events2));
      }
      return names4;
    }, "eventNames");
    EventEmitter10.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    }, "listeners");
    EventEmitter10.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    }, "listenerCount");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length21 = listeners.length, j;
        for (i = 0; i < length21; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    }, "emit");
    EventEmitter10.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    }, "on");
    EventEmitter10.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    }, "once");
    EventEmitter10.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length21 = listeners.length; i < length21; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    }, "removeListener");
    EventEmitter10.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners");
    EventEmitter10.prototype.off = EventEmitter10.prototype.removeListener;
    EventEmitter10.prototype.addListener = EventEmitter10.prototype.on;
    EventEmitter10.prefixed = prefix;
    EventEmitter10.EventEmitter = EventEmitter10;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter10;
    }
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(/* @__PURE__ */ __name(function executor(resolve, reject) {
        params[offset] = /* @__PURE__ */ __name(function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        }, "callback");
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      }, "executor"));
    }
    __name(asPromise, "asPromise");
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base6429 = exports2;
    base6429.length = /* @__PURE__ */ __name(function length21(string8) {
      var p = string8.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string8.charAt(p) === "=")
        ++n;
      return Math.ceil(string8.length * 3) / 4 - n;
    }, "length");
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base6429.encode = /* @__PURE__ */ __name(function encode79(buffer3, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer3[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    }, "encode");
    var invalidEncoding = "invalid encoding";
    base6429.decode = /* @__PURE__ */ __name(function decode97(string8, buffer3, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string8.length; ) {
        var c = string8.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer3[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer3[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer3[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    }, "decode");
    base6429.test = /* @__PURE__ */ __name(function test(string8) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string8);
    }, "test");
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter10;
    function EventEmitter10() {
      this._listeners = {};
    }
    __name(EventEmitter10, "EventEmitter");
    EventEmitter10.prototype.on = /* @__PURE__ */ __name(function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    }, "on");
    EventEmitter10.prototype.off = /* @__PURE__ */ __name(function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    }, "off");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    }, "emit");
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f322 = new Float32Array([-0]), f8b2 = new Uint8Array(f322.buffer), le = f8b2[3] === 128;
          function writeFloat_f32_cpy(val, buf3, pos) {
            f322[0] = val;
            buf3[pos] = f8b2[0];
            buf3[pos + 1] = f8b2[1];
            buf3[pos + 2] = f8b2[2];
            buf3[pos + 3] = f8b2[3];
          }
          __name(writeFloat_f32_cpy, "writeFloat_f32_cpy");
          function writeFloat_f32_rev(val, buf3, pos) {
            f322[0] = val;
            buf3[pos] = f8b2[3];
            buf3[pos + 1] = f8b2[2];
            buf3[pos + 2] = f8b2[1];
            buf3[pos + 3] = f8b2[0];
          }
          __name(writeFloat_f32_rev, "writeFloat_f32_rev");
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf3, pos) {
            f8b2[0] = buf3[pos];
            f8b2[1] = buf3[pos + 1];
            f8b2[2] = buf3[pos + 2];
            f8b2[3] = buf3[pos + 3];
            return f322[0];
          }
          __name(readFloat_f32_cpy, "readFloat_f32_cpy");
          function readFloat_f32_rev(buf3, pos) {
            f8b2[3] = buf3[pos];
            f8b2[2] = buf3[pos + 1];
            f8b2[1] = buf3[pos + 2];
            f8b2[0] = buf3[pos + 3];
            return f322[0];
          }
          __name(readFloat_f32_rev, "readFloat_f32_rev");
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf3, pos) {
            var sign4 = val < 0 ? 1 : 0;
            if (sign4)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf3, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf3, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign4 << 31 | 2139095040) >>> 0, buf3, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign4 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf3, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign4 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf3, pos);
            }
          }
          __name(writeFloat_ieee754, "writeFloat_ieee754");
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf3, pos) {
            var uint = readUint(buf3, pos), sign4 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign4 * Infinity : exponent === 0 ? sign4 * 1401298464324817e-60 * mantissa : sign4 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          __name(readFloat_ieee754, "readFloat_ieee754");
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f642 = new Float64Array([-0]), f8b2 = new Uint8Array(f642.buffer), le = f8b2[7] === 128;
          function writeDouble_f64_cpy(val, buf3, pos) {
            f642[0] = val;
            buf3[pos] = f8b2[0];
            buf3[pos + 1] = f8b2[1];
            buf3[pos + 2] = f8b2[2];
            buf3[pos + 3] = f8b2[3];
            buf3[pos + 4] = f8b2[4];
            buf3[pos + 5] = f8b2[5];
            buf3[pos + 6] = f8b2[6];
            buf3[pos + 7] = f8b2[7];
          }
          __name(writeDouble_f64_cpy, "writeDouble_f64_cpy");
          function writeDouble_f64_rev(val, buf3, pos) {
            f642[0] = val;
            buf3[pos] = f8b2[7];
            buf3[pos + 1] = f8b2[6];
            buf3[pos + 2] = f8b2[5];
            buf3[pos + 3] = f8b2[4];
            buf3[pos + 4] = f8b2[3];
            buf3[pos + 5] = f8b2[2];
            buf3[pos + 6] = f8b2[1];
            buf3[pos + 7] = f8b2[0];
          }
          __name(writeDouble_f64_rev, "writeDouble_f64_rev");
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf3, pos) {
            f8b2[0] = buf3[pos];
            f8b2[1] = buf3[pos + 1];
            f8b2[2] = buf3[pos + 2];
            f8b2[3] = buf3[pos + 3];
            f8b2[4] = buf3[pos + 4];
            f8b2[5] = buf3[pos + 5];
            f8b2[6] = buf3[pos + 6];
            f8b2[7] = buf3[pos + 7];
            return f642[0];
          }
          __name(readDouble_f64_cpy, "readDouble_f64_cpy");
          function readDouble_f64_rev(buf3, pos) {
            f8b2[7] = buf3[pos];
            f8b2[6] = buf3[pos + 1];
            f8b2[5] = buf3[pos + 2];
            f8b2[4] = buf3[pos + 3];
            f8b2[3] = buf3[pos + 4];
            f8b2[2] = buf3[pos + 5];
            f8b2[1] = buf3[pos + 6];
            f8b2[0] = buf3[pos + 7];
            return f642[0];
          }
          __name(readDouble_f64_rev, "readDouble_f64_rev");
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf3, pos) {
            var sign4 = val < 0 ? 1 : 0;
            if (sign4)
              val = -val;
            if (val === 0) {
              writeUint(0, buf3, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf3, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf3, pos + off0);
              writeUint(2146959360, buf3, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf3, pos + off0);
              writeUint((sign4 << 31 | 2146435072) >>> 0, buf3, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf3, pos + off0);
                writeUint((sign4 << 31 | mantissa / 4294967296) >>> 0, buf3, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf3, pos + off0);
                writeUint((sign4 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf3, pos + off1);
              }
            }
          }
          __name(writeDouble_ieee754, "writeDouble_ieee754");
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf3, pos) {
            var lo = readUint(buf3, pos + off0), hi = readUint(buf3, pos + off1);
            var sign4 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign4 * Infinity : exponent === 0 ? sign4 * 5e-324 * mantissa : sign4 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          __name(readDouble_ieee754, "readDouble_ieee754");
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    __name(factory, "factory");
    function writeUintLE(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    __name(writeUintLE, "writeUintLE");
    function writeUintBE(val, buf3, pos) {
      buf3[pos] = val >>> 24;
      buf3[pos + 1] = val >>> 16 & 255;
      buf3[pos + 2] = val >>> 8 & 255;
      buf3[pos + 3] = val & 255;
    }
    __name(writeUintBE, "writeUintBE");
    function readUintLE(buf3, pos) {
      return (buf3[pos] | buf3[pos + 1] << 8 | buf3[pos + 2] << 16 | buf3[pos + 3] << 24) >>> 0;
    }
    __name(readUintLE, "readUintLE");
    function readUintBE(buf3, pos) {
      return (buf3[pos] << 24 | buf3[pos + 1] << 16 | buf3[pos + 2] << 8 | buf3[pos + 3]) >>> 0;
    }
    __name(readUintBE, "readUintBE");
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
    __name(inquire, "inquire");
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = /* @__PURE__ */ __name(function utf8_length(string8) {
      var len = 0, c = 0;
      for (var i = 0; i < string8.length; ++i) {
        c = string8.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string8.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }, "utf8_length");
    utf8.read = /* @__PURE__ */ __name(function utf8_read(buffer3, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer3[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer3[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer3[start++] & 63) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    }, "utf8_read");
    utf8.write = /* @__PURE__ */ __name(function utf8_write(string8, buffer3, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string8.length; ++i) {
        c1 = string8.charCodeAt(i);
        if (c1 < 128) {
          buffer3[offset++] = c1;
        } else if (c1 < 2048) {
          buffer3[offset++] = c1 >> 6 | 192;
          buffer3[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string8.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer3[offset++] = c1 >> 18 | 240;
          buffer3[offset++] = c1 >> 12 & 63 | 128;
          buffer3[offset++] = c1 >> 6 & 63 | 128;
          buffer3[offset++] = c1 & 63 | 128;
        } else {
          buffer3[offset++] = c1 >> 12 | 224;
          buffer3[offset++] = c1 >> 6 & 63 | 128;
          buffer3[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }, "utf8_write");
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool2;
    function pool2(alloc5, slice3, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return /* @__PURE__ */ __name(function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc5(size2);
        if (offset + size2 > SIZE) {
          slab = alloc5(SIZE);
          offset = 0;
        }
        var buf3 = slice3.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf3;
      }, "pool_alloc");
    }
    __name(pool2, "pool");
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits3;
    var util = require_minimal();
    function LongBits3(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    __name(LongBits3, "LongBits");
    var zero2 = LongBits3.zero = new LongBits3(0, 0);
    zero2.toNumber = function() {
      return 0;
    };
    zero2.zzEncode = zero2.zzDecode = function() {
      return this;
    };
    zero2.length = function() {
      return 1;
    };
    var zeroHash = LongBits3.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits3.fromNumber = /* @__PURE__ */ __name(function fromNumber(value) {
      if (value === 0)
        return zero2;
      var sign4 = value < 0;
      if (sign4)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign4) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits3(lo, hi);
    }, "fromNumber");
    LongBits3.from = /* @__PURE__ */ __name(function from46(value) {
      if (typeof value === "number")
        return LongBits3.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits3.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits3(value.low >>> 0, value.high >>> 0) : zero2;
    }, "from");
    LongBits3.prototype.toNumber = /* @__PURE__ */ __name(function toNumber(unsigned3) {
      if (!unsigned3 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }, "toNumber");
    LongBits3.prototype.toLong = /* @__PURE__ */ __name(function toLong(unsigned3) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned3)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned3) };
    }, "toLong");
    var charCodeAt = String.prototype.charCodeAt;
    LongBits3.fromHash = /* @__PURE__ */ __name(function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero2;
      return new LongBits3(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    }, "fromHash");
    LongBits3.prototype.toHash = /* @__PURE__ */ __name(function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    }, "toHash");
    LongBits3.prototype.zzEncode = /* @__PURE__ */ __name(function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }, "zzEncode");
    LongBits3.prototype.zzDecode = /* @__PURE__ */ __name(function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }, "zzDecode");
    LongBits3.prototype.length = /* @__PURE__ */ __name(function length21() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }, "length");
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof window !== "undefined" && window && window.process && window.process.versions && window.process.versions.node);
    util.global = util.isNode && window || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    /* @__PURE__ */ __name(function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }, "isInteger");
    util.isString = /* @__PURE__ */ __name(function isString(value) {
      return typeof value === "string" || value instanceof String;
    }, "isString");
    util.isObject = /* @__PURE__ */ __name(function isObject(value) {
      return value && typeof value === "object";
    }, "isObject");
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = /* @__PURE__ */ __name(function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    }, "isSet");
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = /* @__PURE__ */ __name(function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    }, "newBuffer");
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = /* @__PURE__ */ __name(function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    }, "longToHash");
    util.longFromHash = /* @__PURE__ */ __name(function longFromHash(hash3, unsigned3) {
      var bits3 = util.LongBits.fromHash(hash3);
      if (util.Long)
        return util.Long.fromBits(bits3.lo, bits3.hi, unsigned3);
      return bits3.toNumber(Boolean(unsigned3));
    }, "longFromHash");
    function merge2(dst, src30, ifNotSet) {
      for (var keys = Object.keys(src30), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src30[keys[i]];
      return dst;
    }
    __name(merge2, "merge");
    util.merge = merge2;
    util.lcFirst = /* @__PURE__ */ __name(function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    }, "lcFirst");
    function newError(name14) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      __name(CustomError, "CustomError");
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name14;
      } });
      CustomError.prototype.toString = /* @__PURE__ */ __name(function toString19() {
        return this.name + ": " + this.message;
      }, "toString");
      return CustomError;
    }
    __name(newError, "newError");
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = /* @__PURE__ */ __name(function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    }, "getOneOf");
    util.oneOfSetter = /* @__PURE__ */ __name(function setOneOf(fieldNames) {
      return function(name14) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name14)
            delete this[fieldNames[i]];
      };
    }, "setOneOf");
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      }, "Buffer_from");
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      }, "Buffer_allocUnsafe");
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits3 = util.LongBits;
    var base6429 = util.base64;
    var utf8 = util.utf8;
    function Op2(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(Op2, "Op");
    function noop3() {
    }
    __name(noop3, "noop");
    function State2(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    __name(State2, "State");
    function Writer() {
      this.len = 0;
      this.head = new Op2(noop3, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    __name(Writer, "Writer");
    var create23 = /* @__PURE__ */ __name(function create24() {
      return util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup() {
        return (Writer.create = /* @__PURE__ */ __name(function create_buffer() {
          return new BufferWriter();
        }, "create_buffer"))();
      }, "create_buffer_setup") : /* @__PURE__ */ __name(function create_array() {
        return new Writer();
      }, "create_array");
    }, "create");
    Writer.create = create23();
    Writer.alloc = /* @__PURE__ */ __name(function alloc5(size) {
      return new util.Array(size);
    }, "alloc");
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = /* @__PURE__ */ __name(function push(fn, len, val) {
      this.tail = this.tail.next = new Op2(fn, len, val);
      this.len += len;
      return this;
    }, "push");
    function writeByte2(val, buf3, pos) {
      buf3[pos] = val & 255;
    }
    __name(writeByte2, "writeByte");
    function writeVarint322(val, buf3, pos) {
      while (val > 127) {
        buf3[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf3[pos] = val;
    }
    __name(writeVarint322, "writeVarint32");
    function VarintOp2(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(VarintOp2, "VarintOp");
    VarintOp2.prototype = Object.create(Op2.prototype);
    VarintOp2.prototype.fn = writeVarint322;
    Writer.prototype.uint32 = /* @__PURE__ */ __name(function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp2(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    }, "write_uint32");
    Writer.prototype.int32 = /* @__PURE__ */ __name(function write_int32(value) {
      return value < 0 ? this._push(writeVarint642, 10, LongBits3.fromNumber(value)) : this.uint32(value);
    }, "write_int32");
    Writer.prototype.sint32 = /* @__PURE__ */ __name(function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }, "write_sint32");
    function writeVarint642(val, buf3, pos) {
      while (val.hi) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf3[pos++] = val.lo;
    }
    __name(writeVarint642, "writeVarint64");
    Writer.prototype.uint64 = /* @__PURE__ */ __name(function write_uint64(value) {
      var bits3 = LongBits3.from(value);
      return this._push(writeVarint642, bits3.length(), bits3);
    }, "write_uint64");
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = /* @__PURE__ */ __name(function write_sint64(value) {
      var bits3 = LongBits3.from(value).zzEncode();
      return this._push(writeVarint642, bits3.length(), bits3);
    }, "write_sint64");
    Writer.prototype.bool = /* @__PURE__ */ __name(function write_bool(value) {
      return this._push(writeByte2, 1, value ? 1 : 0);
    }, "write_bool");
    function writeFixed322(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    __name(writeFixed322, "writeFixed32");
    Writer.prototype.fixed32 = /* @__PURE__ */ __name(function write_fixed32(value) {
      return this._push(writeFixed322, 4, value >>> 0);
    }, "write_fixed32");
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = /* @__PURE__ */ __name(function write_fixed64(value) {
      var bits3 = LongBits3.from(value);
      return this._push(writeFixed322, 4, bits3.lo)._push(writeFixed322, 4, bits3.hi);
    }, "write_fixed64");
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = /* @__PURE__ */ __name(function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    }, "write_float");
    Writer.prototype.double = /* @__PURE__ */ __name(function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    }, "write_double");
    var writeBytes2 = util.Array.prototype.set ? /* @__PURE__ */ __name(function writeBytes_set(val, buf3, pos) {
      buf3.set(val, pos);
    }, "writeBytes_set") : /* @__PURE__ */ __name(function writeBytes_for(val, buf3, pos) {
      for (var i = 0; i < val.length; ++i)
        buf3[pos + i] = val[i];
    }, "writeBytes_for");
    Writer.prototype.bytes = /* @__PURE__ */ __name(function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte2, 1, 0);
      if (util.isString(value)) {
        var buf3 = Writer.alloc(len = base6429.length(value));
        base6429.decode(value, buf3, 0);
        value = buf3;
      }
      return this.uint32(len)._push(writeBytes2, len, value);
    }, "write_bytes");
    Writer.prototype.string = /* @__PURE__ */ __name(function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte2, 1, 0);
    }, "write_string");
    Writer.prototype.fork = /* @__PURE__ */ __name(function fork() {
      this.states = new State2(this);
      this.head = this.tail = new Op2(noop3, 0, 0);
      this.len = 0;
      return this;
    }, "fork");
    Writer.prototype.reset = /* @__PURE__ */ __name(function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op2(noop3, 0, 0);
        this.len = 0;
      }
      return this;
    }, "reset");
    Writer.prototype.ldelim = /* @__PURE__ */ __name(function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }, "ldelim");
    Writer.prototype.finish = /* @__PURE__ */ __name(function finish() {
      var head = this.head.next, buf3 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf3, pos);
        pos += head.len;
        head = head.next;
      }
      return buf3;
    }, "finish");
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create23();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    __name(BufferWriter, "BufferWriter");
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? /* @__PURE__ */ __name(function writeBytesBuffer_set(val, buf3, pos) {
        buf3.set(val, pos);
      }, "writeBytesBuffer_set") : /* @__PURE__ */ __name(function writeBytesBuffer_copy(val, buf3, pos) {
        if (val.copy)
          val.copy(buf3, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf3[pos++] = val[i++];
      }, "writeBytesBuffer_copy");
    };
    BufferWriter.prototype.bytes = /* @__PURE__ */ __name(function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    }, "write_bytes_buffer");
    function writeStringBuffer2(val, buf3, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf3, pos);
      else if (buf3.utf8Write)
        buf3.utf8Write(val, pos);
      else
        buf3.write(val, pos);
    }
    __name(writeStringBuffer2, "writeStringBuffer");
    BufferWriter.prototype.string = /* @__PURE__ */ __name(function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer2, len, value);
      return this;
    }, "write_string_buffer");
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits3 = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange2(reader2, writeLength) {
      return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
    }
    __name(indexOutOfRange2, "indexOutOfRange");
    function Reader(buffer3) {
      this.buf = buffer3;
      this.pos = 0;
      this.len = buffer3.length;
    }
    __name(Reader, "Reader");
    var create_array = typeof Uint8Array !== "undefined" ? /* @__PURE__ */ __name(function create_typed_array(buffer3) {
      if (buffer3 instanceof Uint8Array || Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    }, "create_typed_array") : /* @__PURE__ */ __name(function create_array2(buffer3) {
      if (Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    }, "create_array");
    var create23 = /* @__PURE__ */ __name(function create24() {
      return util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup(buffer3) {
        return (Reader.create = /* @__PURE__ */ __name(function create_buffer(buffer4) {
          return util.Buffer.isBuffer(buffer4) ? new BufferReader(buffer4) : create_array(buffer4);
        }, "create_buffer"))(buffer3);
      }, "create_buffer_setup") : create_array;
    }, "create");
    Reader.create = create23();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = (/* @__PURE__ */ __name(function read_uint32_setup() {
      var value = 4294967295;
      return /* @__PURE__ */ __name(function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange2(this, 10);
        }
        return value;
      }, "read_uint32");
    }, "read_uint32_setup"))();
    Reader.prototype.int32 = /* @__PURE__ */ __name(function read_int32() {
      return this.uint32() | 0;
    }, "read_int32");
    Reader.prototype.sint32 = /* @__PURE__ */ __name(function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }, "read_sint32");
    function readLongVarint() {
      var bits3 = new LongBits3(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits3.lo = (bits3.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits3;
        }
        bits3.lo = (bits3.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits3.hi = (bits3.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits3;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange2(this);
          bits3.lo = (bits3.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits3;
        }
        bits3.lo = (bits3.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits3;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits3.hi = (bits3.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits3;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange2(this);
          bits3.hi = (bits3.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits3;
        }
      }
      throw Error("invalid varint encoding");
    }
    __name(readLongVarint, "readLongVarint");
    Reader.prototype.bool = /* @__PURE__ */ __name(function read_bool() {
      return this.uint32() !== 0;
    }, "read_bool");
    function readFixed32_end(buf3, end) {
      return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
    }
    __name(readFixed32_end, "readFixed32_end");
    Reader.prototype.fixed32 = /* @__PURE__ */ __name(function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange2(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    }, "read_fixed32");
    Reader.prototype.sfixed32 = /* @__PURE__ */ __name(function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange2(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    }, "read_sfixed32");
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange2(this, 8);
      return new LongBits3(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    __name(readFixed64, "readFixed64");
    Reader.prototype.float = /* @__PURE__ */ __name(function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange2(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }, "read_float");
    Reader.prototype.double = /* @__PURE__ */ __name(function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange2(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }, "read_double");
    Reader.prototype.bytes = /* @__PURE__ */ __name(function read_bytes() {
      var length21 = this.uint32(), start = this.pos, end = this.pos + length21;
      if (end > this.len)
        throw indexOutOfRange2(this, length21);
      this.pos += length21;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    }, "read_bytes");
    Reader.prototype.string = /* @__PURE__ */ __name(function read_string() {
      var bytes3 = this.bytes();
      return utf8.read(bytes3, 0, bytes3.length);
    }, "read_string");
    Reader.prototype.skip = /* @__PURE__ */ __name(function skip(length21) {
      if (typeof length21 === "number") {
        if (this.pos + length21 > this.len)
          throw indexOutOfRange2(this, length21);
        this.pos += length21;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange2(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }, "skip");
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create23();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: /* @__PURE__ */ __name(function read_int64() {
          return readLongVarint.call(this)[fn](false);
        }, "read_int64"),
        uint64: /* @__PURE__ */ __name(function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        }, "read_uint64"),
        sint64: /* @__PURE__ */ __name(function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        }, "read_sint64"),
        fixed64: /* @__PURE__ */ __name(function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        }, "read_fixed64"),
        sfixed64: /* @__PURE__ */ __name(function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }, "read_sfixed64")
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer3) {
      Reader.call(this, buffer3);
    }
    __name(BufferReader, "BufferReader");
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = /* @__PURE__ */ __name(function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    }, "read_string_buffer");
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    __name(Service, "Service");
    Service.prototype.rpcCall = /* @__PURE__ */ __name(function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          /* @__PURE__ */ __name(function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }, "rpcCallback")
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    }, "rpcCall");
    Service.prototype.end = /* @__PURE__ */ __name(function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    }, "end");
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf2 = exports2;
    protobuf2.build = "minimal";
    protobuf2.Writer = require_writer();
    protobuf2.BufferWriter = require_writer_buffer();
    protobuf2.Reader = require_reader();
    protobuf2.BufferReader = require_reader_buffer();
    protobuf2.util = require_minimal();
    protobuf2.rpc = require_rpc();
    protobuf2.roots = require_roots();
    protobuf2.configure = configure;
    function configure() {
      protobuf2.util._configure();
      protobuf2.Writer._configure(protobuf2.BufferWriter);
      protobuf2.Reader._configure(protobuf2.BufferReader);
    }
    __name(configure, "configure");
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs
var require_rpc2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs"(exports2, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
          // define(["protobufjs/minimal"], factory);
      } else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports) {
          module2.exports = factory(require_minimal2());
      }
    })(exports2, function($protobuf) {
      "use strict";
      var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.RPC = function() {
        function RPC3(p) {
          this.subscriptions = [];
          this.messages = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        __name(RPC3, "RPC");
        RPC3.prototype.subscriptions = $util.emptyArray;
        RPC3.prototype.messages = $util.emptyArray;
        RPC3.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC3.prototype, "_control", {
          get: $util.oneOfGetter($oneOfFields = ["control"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        RPC3.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
          if (!w2)
            w2 = $Writer.create();
          if (m2.subscriptions != null && m2.subscriptions.length) {
            for (var i = 0; i < m2.subscriptions.length; ++i)
              $root.RPC.SubOpts.encode(m2.subscriptions[i], w2.uint32(10).fork()).ldelim();
          }
          if (m2.messages != null && m2.messages.length) {
            for (var i = 0; i < m2.messages.length; ++i)
              $root.RPC.Message.encode(m2.messages[i], w2.uint32(18).fork()).ldelim();
          }
          if (m2.control != null && Object.hasOwnProperty.call(m2, "control"))
            $root.RPC.ControlMessage.encode(m2.control, w2.uint32(26).fork()).ldelim();
          return w2;
        }, "encode");
        RPC3.decode = /* @__PURE__ */ __name(function decode97(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m2.subscriptions && m2.subscriptions.length))
                  m2.subscriptions = [];
                m2.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m2.messages && m2.messages.length))
                  m2.messages = [];
                m2.messages.push($root.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m2.control = $root.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m2;
        }, "decode");
        RPC3.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
          if (d2 instanceof $root.RPC)
            return d2;
          var m2 = new $root.RPC();
          if (d2.subscriptions) {
            if (!Array.isArray(d2.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m2.subscriptions = [];
            for (var i = 0; i < d2.subscriptions.length; ++i) {
              if (typeof d2.subscriptions[i] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m2.subscriptions[i] = $root.RPC.SubOpts.fromObject(d2.subscriptions[i]);
            }
          }
          if (d2.messages) {
            if (!Array.isArray(d2.messages))
              throw TypeError(".RPC.messages: array expected");
            m2.messages = [];
            for (var i = 0; i < d2.messages.length; ++i) {
              if (typeof d2.messages[i] !== "object")
                throw TypeError(".RPC.messages: object expected");
              m2.messages[i] = $root.RPC.Message.fromObject(d2.messages[i]);
            }
          }
          if (d2.control != null) {
            if (typeof d2.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m2.control = $root.RPC.ControlMessage.fromObject(d2.control);
          }
          return m2;
        }, "fromObject");
        RPC3.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
          if (!o)
            o = {};
          var d2 = {};
          if (o.arrays || o.defaults) {
            d2.subscriptions = [];
            d2.messages = [];
          }
          if (m2.subscriptions && m2.subscriptions.length) {
            d2.subscriptions = [];
            for (var j = 0; j < m2.subscriptions.length; ++j) {
              d2.subscriptions[j] = $root.RPC.SubOpts.toObject(m2.subscriptions[j], o);
            }
          }
          if (m2.messages && m2.messages.length) {
            d2.messages = [];
            for (var j = 0; j < m2.messages.length; ++j) {
              d2.messages[j] = $root.RPC.Message.toObject(m2.messages[j], o);
            }
          }
          if (m2.control != null && m2.hasOwnProperty("control")) {
            d2.control = $root.RPC.ControlMessage.toObject(m2.control, o);
            if (o.oneofs)
              d2._control = "control";
          }
          return d2;
        }, "toObject");
        RPC3.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        RPC3.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(SubOpts, "SubOpts");
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topic = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topic", {
            get: $util.oneOfGetter($oneOfFields2 = ["topic"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.subscribe != null && Object.hasOwnProperty.call(m2, "subscribe"))
              w2.uint32(8).bool(m2.subscribe);
            if (m2.topic != null && Object.hasOwnProperty.call(m2, "topic"))
              w2.uint32(18).string(m2.topic);
            return w2;
          }, "encode");
          SubOpts.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m2.subscribe = r.bool();
                  break;
                case 2:
                  m2.topic = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          SubOpts.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.SubOpts)
              return d2;
            var m2 = new $root.RPC.SubOpts();
            if (d2.subscribe != null) {
              m2.subscribe = Boolean(d2.subscribe);
            }
            if (d2.topic != null) {
              m2.topic = String(d2.topic);
            }
            return m2;
          }, "fromObject");
          SubOpts.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (m2.subscribe != null && m2.hasOwnProperty("subscribe")) {
              d2.subscribe = m2.subscribe;
              if (o.oneofs)
                d2._subscribe = "subscribe";
            }
            if (m2.topic != null && m2.hasOwnProperty("topic")) {
              d2.topic = m2.topic;
              if (o.oneofs)
                d2._topic = "topic";
            }
            return d2;
          }, "toObject");
          SubOpts.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return SubOpts;
        }();
        RPC3.Message = function() {
          function Message7(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(Message7, "Message");
          Message7.prototype.from = null;
          Message7.prototype.data = null;
          Message7.prototype.seqno = null;
          Message7.prototype.topic = "";
          Message7.prototype.signature = null;
          Message7.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message7.prototype, "_from", {
            get: $util.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message7.prototype, "_data", {
            get: $util.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message7.prototype, "_seqno", {
            get: $util.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message7.prototype, "_signature", {
            get: $util.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message7.prototype, "_key", {
            get: $util.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Message7.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.from != null && Object.hasOwnProperty.call(m2, "from"))
              w2.uint32(10).bytes(m2.from);
            if (m2.data != null && Object.hasOwnProperty.call(m2, "data"))
              w2.uint32(18).bytes(m2.data);
            if (m2.seqno != null && Object.hasOwnProperty.call(m2, "seqno"))
              w2.uint32(26).bytes(m2.seqno);
            w2.uint32(34).string(m2.topic);
            if (m2.signature != null && Object.hasOwnProperty.call(m2, "signature"))
              w2.uint32(42).bytes(m2.signature);
            if (m2.key != null && Object.hasOwnProperty.call(m2, "key"))
              w2.uint32(50).bytes(m2.key);
            return w2;
          }, "encode");
          Message7.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m2.from = r.bytes();
                  break;
                case 2:
                  m2.data = r.bytes();
                  break;
                case 3:
                  m2.seqno = r.bytes();
                  break;
                case 4:
                  m2.topic = r.string();
                  break;
                case 5:
                  m2.signature = r.bytes();
                  break;
                case 6:
                  m2.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m2.hasOwnProperty("topic"))
              throw $util.ProtocolError("missing required 'topic'", { instance: m2 });
            return m2;
          }, "decode");
          Message7.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.Message)
              return d2;
            var m2 = new $root.RPC.Message();
            if (d2.from != null) {
              if (typeof d2.from === "string")
                $util.base64.decode(d2.from, m2.from = $util.newBuffer($util.base64.length(d2.from)), 0);
              else if (d2.from.length)
                m2.from = d2.from;
            }
            if (d2.data != null) {
              if (typeof d2.data === "string")
                $util.base64.decode(d2.data, m2.data = $util.newBuffer($util.base64.length(d2.data)), 0);
              else if (d2.data.length)
                m2.data = d2.data;
            }
            if (d2.seqno != null) {
              if (typeof d2.seqno === "string")
                $util.base64.decode(d2.seqno, m2.seqno = $util.newBuffer($util.base64.length(d2.seqno)), 0);
              else if (d2.seqno.length)
                m2.seqno = d2.seqno;
            }
            if (d2.topic != null) {
              m2.topic = String(d2.topic);
            }
            if (d2.signature != null) {
              if (typeof d2.signature === "string")
                $util.base64.decode(d2.signature, m2.signature = $util.newBuffer($util.base64.length(d2.signature)), 0);
              else if (d2.signature.length)
                m2.signature = d2.signature;
            }
            if (d2.key != null) {
              if (typeof d2.key === "string")
                $util.base64.decode(d2.key, m2.key = $util.newBuffer($util.base64.length(d2.key)), 0);
              else if (d2.key.length)
                m2.key = d2.key;
            }
            return m2;
          }, "fromObject");
          Message7.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (o.defaults) {
              d2.topic = "";
            }
            if (m2.from != null && m2.hasOwnProperty("from")) {
              d2.from = o.bytes === String ? $util.base64.encode(m2.from, 0, m2.from.length) : o.bytes === Array ? Array.prototype.slice.call(m2.from) : m2.from;
              if (o.oneofs)
                d2._from = "from";
            }
            if (m2.data != null && m2.hasOwnProperty("data")) {
              d2.data = o.bytes === String ? $util.base64.encode(m2.data, 0, m2.data.length) : o.bytes === Array ? Array.prototype.slice.call(m2.data) : m2.data;
              if (o.oneofs)
                d2._data = "data";
            }
            if (m2.seqno != null && m2.hasOwnProperty("seqno")) {
              d2.seqno = o.bytes === String ? $util.base64.encode(m2.seqno, 0, m2.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m2.seqno) : m2.seqno;
              if (o.oneofs)
                d2._seqno = "seqno";
            }
            if (m2.topic != null && m2.hasOwnProperty("topic")) {
              d2.topic = m2.topic;
            }
            if (m2.signature != null && m2.hasOwnProperty("signature")) {
              d2.signature = o.bytes === String ? $util.base64.encode(m2.signature, 0, m2.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m2.signature) : m2.signature;
              if (o.oneofs)
                d2._signature = "signature";
            }
            if (m2.key != null && m2.hasOwnProperty("key")) {
              d2.key = o.bytes === String ? $util.base64.encode(m2.key, 0, m2.key.length) : o.bytes === Array ? Array.prototype.slice.call(m2.key) : m2.key;
              if (o.oneofs)
                d2._key = "key";
            }
            return d2;
          }, "toObject");
          Message7.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return Message7;
        }();
        RPC3.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(ControlMessage, "ControlMessage");
          ControlMessage.prototype.ihave = $util.emptyArray;
          ControlMessage.prototype.iwant = $util.emptyArray;
          ControlMessage.prototype.graft = $util.emptyArray;
          ControlMessage.prototype.prune = $util.emptyArray;
          ControlMessage.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.ihave != null && m2.ihave.length) {
              for (var i = 0; i < m2.ihave.length; ++i)
                $root.RPC.ControlIHave.encode(m2.ihave[i], w2.uint32(10).fork()).ldelim();
            }
            if (m2.iwant != null && m2.iwant.length) {
              for (var i = 0; i < m2.iwant.length; ++i)
                $root.RPC.ControlIWant.encode(m2.iwant[i], w2.uint32(18).fork()).ldelim();
            }
            if (m2.graft != null && m2.graft.length) {
              for (var i = 0; i < m2.graft.length; ++i)
                $root.RPC.ControlGraft.encode(m2.graft[i], w2.uint32(26).fork()).ldelim();
            }
            if (m2.prune != null && m2.prune.length) {
              for (var i = 0; i < m2.prune.length; ++i)
                $root.RPC.ControlPrune.encode(m2.prune[i], w2.uint32(34).fork()).ldelim();
            }
            return w2;
          }, "encode");
          ControlMessage.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m2.ihave && m2.ihave.length))
                    m2.ihave = [];
                  m2.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m2.iwant && m2.iwant.length))
                    m2.iwant = [];
                  m2.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m2.graft && m2.graft.length))
                    m2.graft = [];
                  m2.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m2.prune && m2.prune.length))
                    m2.prune = [];
                  m2.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          ControlMessage.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.ControlMessage)
              return d2;
            var m2 = new $root.RPC.ControlMessage();
            if (d2.ihave) {
              if (!Array.isArray(d2.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m2.ihave = [];
              for (var i = 0; i < d2.ihave.length; ++i) {
                if (typeof d2.ihave[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m2.ihave[i] = $root.RPC.ControlIHave.fromObject(d2.ihave[i]);
              }
            }
            if (d2.iwant) {
              if (!Array.isArray(d2.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m2.iwant = [];
              for (var i = 0; i < d2.iwant.length; ++i) {
                if (typeof d2.iwant[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m2.iwant[i] = $root.RPC.ControlIWant.fromObject(d2.iwant[i]);
              }
            }
            if (d2.graft) {
              if (!Array.isArray(d2.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m2.graft = [];
              for (var i = 0; i < d2.graft.length; ++i) {
                if (typeof d2.graft[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m2.graft[i] = $root.RPC.ControlGraft.fromObject(d2.graft[i]);
              }
            }
            if (d2.prune) {
              if (!Array.isArray(d2.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m2.prune = [];
              for (var i = 0; i < d2.prune.length; ++i) {
                if (typeof d2.prune[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m2.prune[i] = $root.RPC.ControlPrune.fromObject(d2.prune[i]);
              }
            }
            return m2;
          }, "fromObject");
          ControlMessage.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (o.arrays || o.defaults) {
              d2.ihave = [];
              d2.iwant = [];
              d2.graft = [];
              d2.prune = [];
            }
            if (m2.ihave && m2.ihave.length) {
              d2.ihave = [];
              for (var j = 0; j < m2.ihave.length; ++j) {
                d2.ihave[j] = $root.RPC.ControlIHave.toObject(m2.ihave[j], o);
              }
            }
            if (m2.iwant && m2.iwant.length) {
              d2.iwant = [];
              for (var j = 0; j < m2.iwant.length; ++j) {
                d2.iwant[j] = $root.RPC.ControlIWant.toObject(m2.iwant[j], o);
              }
            }
            if (m2.graft && m2.graft.length) {
              d2.graft = [];
              for (var j = 0; j < m2.graft.length; ++j) {
                d2.graft[j] = $root.RPC.ControlGraft.toObject(m2.graft[j], o);
              }
            }
            if (m2.prune && m2.prune.length) {
              d2.prune = [];
              for (var j = 0; j < m2.prune.length; ++j) {
                d2.prune[j] = $root.RPC.ControlPrune.toObject(m2.prune[j], o);
              }
            }
            return d2;
          }, "toObject");
          ControlMessage.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ControlMessage;
        }();
        RPC3.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(ControlIHave, "ControlIHave");
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.topicID != null && Object.hasOwnProperty.call(m2, "topicID"))
              w2.uint32(10).string(m2.topicID);
            if (m2.messageIDs != null && m2.messageIDs.length) {
              for (var i = 0; i < m2.messageIDs.length; ++i)
                w2.uint32(18).bytes(m2.messageIDs[i]);
            }
            return w2;
          }, "encode");
          ControlIHave.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m2.topicID = r.string();
                  break;
                case 2:
                  if (!(m2.messageIDs && m2.messageIDs.length))
                    m2.messageIDs = [];
                  m2.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          ControlIHave.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.ControlIHave)
              return d2;
            var m2 = new $root.RPC.ControlIHave();
            if (d2.topicID != null) {
              m2.topicID = String(d2.topicID);
            }
            if (d2.messageIDs) {
              if (!Array.isArray(d2.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m2.messageIDs = [];
              for (var i = 0; i < d2.messageIDs.length; ++i) {
                if (typeof d2.messageIDs[i] === "string")
                  $util.base64.decode(d2.messageIDs[i], m2.messageIDs[i] = $util.newBuffer($util.base64.length(d2.messageIDs[i])), 0);
                else if (d2.messageIDs[i].length)
                  m2.messageIDs[i] = d2.messageIDs[i];
              }
            }
            return m2;
          }, "fromObject");
          ControlIHave.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (o.arrays || o.defaults) {
              d2.messageIDs = [];
            }
            if (m2.topicID != null && m2.hasOwnProperty("topicID")) {
              d2.topicID = m2.topicID;
              if (o.oneofs)
                d2._topicID = "topicID";
            }
            if (m2.messageIDs && m2.messageIDs.length) {
              d2.messageIDs = [];
              for (var j = 0; j < m2.messageIDs.length; ++j) {
                d2.messageIDs[j] = o.bytes === String ? $util.base64.encode(m2.messageIDs[j], 0, m2.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m2.messageIDs[j]) : m2.messageIDs[j];
              }
            }
            return d2;
          }, "toObject");
          ControlIHave.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ControlIHave;
        }();
        RPC3.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(ControlIWant, "ControlIWant");
          ControlIWant.prototype.messageIDs = $util.emptyArray;
          ControlIWant.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.messageIDs != null && m2.messageIDs.length) {
              for (var i = 0; i < m2.messageIDs.length; ++i)
                w2.uint32(10).bytes(m2.messageIDs[i]);
            }
            return w2;
          }, "encode");
          ControlIWant.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m2.messageIDs && m2.messageIDs.length))
                    m2.messageIDs = [];
                  m2.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          ControlIWant.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.ControlIWant)
              return d2;
            var m2 = new $root.RPC.ControlIWant();
            if (d2.messageIDs) {
              if (!Array.isArray(d2.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m2.messageIDs = [];
              for (var i = 0; i < d2.messageIDs.length; ++i) {
                if (typeof d2.messageIDs[i] === "string")
                  $util.base64.decode(d2.messageIDs[i], m2.messageIDs[i] = $util.newBuffer($util.base64.length(d2.messageIDs[i])), 0);
                else if (d2.messageIDs[i].length)
                  m2.messageIDs[i] = d2.messageIDs[i];
              }
            }
            return m2;
          }, "fromObject");
          ControlIWant.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (o.arrays || o.defaults) {
              d2.messageIDs = [];
            }
            if (m2.messageIDs && m2.messageIDs.length) {
              d2.messageIDs = [];
              for (var j = 0; j < m2.messageIDs.length; ++j) {
                d2.messageIDs[j] = o.bytes === String ? $util.base64.encode(m2.messageIDs[j], 0, m2.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m2.messageIDs[j]) : m2.messageIDs[j];
              }
            }
            return d2;
          }, "toObject");
          ControlIWant.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ControlIWant;
        }();
        RPC3.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(ControlGraft, "ControlGraft");
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.topicID != null && Object.hasOwnProperty.call(m2, "topicID"))
              w2.uint32(10).string(m2.topicID);
            return w2;
          }, "encode");
          ControlGraft.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m2.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          ControlGraft.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.ControlGraft)
              return d2;
            var m2 = new $root.RPC.ControlGraft();
            if (d2.topicID != null) {
              m2.topicID = String(d2.topicID);
            }
            return m2;
          }, "fromObject");
          ControlGraft.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (m2.topicID != null && m2.hasOwnProperty("topicID")) {
              d2.topicID = m2.topicID;
              if (o.oneofs)
                d2._topicID = "topicID";
            }
            return d2;
          }, "toObject");
          ControlGraft.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ControlGraft;
        }();
        RPC3.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(ControlPrune, "ControlPrune");
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.topicID != null && Object.hasOwnProperty.call(m2, "topicID"))
              w2.uint32(10).string(m2.topicID);
            if (m2.peers != null && m2.peers.length) {
              for (var i = 0; i < m2.peers.length; ++i)
                $root.RPC.PeerInfo.encode(m2.peers[i], w2.uint32(18).fork()).ldelim();
            }
            if (m2.backoff != null && Object.hasOwnProperty.call(m2, "backoff"))
              w2.uint32(24).uint64(m2.backoff);
            return w2;
          }, "encode");
          ControlPrune.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m2.topicID = r.string();
                  break;
                case 2:
                  if (!(m2.peers && m2.peers.length))
                    m2.peers = [];
                  m2.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m2.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          ControlPrune.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.ControlPrune)
              return d2;
            var m2 = new $root.RPC.ControlPrune();
            if (d2.topicID != null) {
              m2.topicID = String(d2.topicID);
            }
            if (d2.peers) {
              if (!Array.isArray(d2.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m2.peers = [];
              for (var i = 0; i < d2.peers.length; ++i) {
                if (typeof d2.peers[i] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m2.peers[i] = $root.RPC.PeerInfo.fromObject(d2.peers[i]);
              }
            }
            if (d2.backoff != null) {
              if ($util.Long)
                (m2.backoff = $util.Long.fromValue(d2.backoff)).unsigned = true;
              else if (typeof d2.backoff === "string")
                m2.backoff = parseInt(d2.backoff, 10);
              else if (typeof d2.backoff === "number")
                m2.backoff = d2.backoff;
              else if (typeof d2.backoff === "object")
                m2.backoff = new $util.LongBits(d2.backoff.low >>> 0, d2.backoff.high >>> 0).toNumber(true);
            }
            return m2;
          }, "fromObject");
          ControlPrune.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (o.arrays || o.defaults) {
              d2.peers = [];
            }
            if (m2.topicID != null && m2.hasOwnProperty("topicID")) {
              d2.topicID = m2.topicID;
              if (o.oneofs)
                d2._topicID = "topicID";
            }
            if (m2.peers && m2.peers.length) {
              d2.peers = [];
              for (var j = 0; j < m2.peers.length; ++j) {
                d2.peers[j] = $root.RPC.PeerInfo.toObject(m2.peers[j], o);
              }
            }
            if (m2.backoff != null && m2.hasOwnProperty("backoff")) {
              if (typeof m2.backoff === "number")
                d2.backoff = o.longs === String ? String(m2.backoff) : m2.backoff;
              else
                d2.backoff = o.longs === String ? $util.Long.prototype.toString.call(m2.backoff) : o.longs === Number ? new $util.LongBits(m2.backoff.low >>> 0, m2.backoff.high >>> 0).toNumber(true) : m2.backoff;
              if (o.oneofs)
                d2._backoff = "backoff";
            }
            return d2;
          }, "toObject");
          ControlPrune.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ControlPrune;
        }();
        RPC3.PeerInfo = function() {
          function PeerInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          __name(PeerInfo, "PeerInfo");
          PeerInfo.prototype.peerID = null;
          PeerInfo.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo.prototype, "_peerID", {
            get: $util.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
            get: $util.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          PeerInfo.encode = /* @__PURE__ */ __name(function encode79(m2, w2) {
            if (!w2)
              w2 = $Writer.create();
            if (m2.peerID != null && Object.hasOwnProperty.call(m2, "peerID"))
              w2.uint32(10).bytes(m2.peerID);
            if (m2.signedPeerRecord != null && Object.hasOwnProperty.call(m2, "signedPeerRecord"))
              w2.uint32(18).bytes(m2.signedPeerRecord);
            return w2;
          }, "encode");
          PeerInfo.decode = /* @__PURE__ */ __name(function decode97(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m2 = new $root.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m2.peerID = r.bytes();
                  break;
                case 2:
                  m2.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m2;
          }, "decode");
          PeerInfo.fromObject = /* @__PURE__ */ __name(function fromObject(d2) {
            if (d2 instanceof $root.RPC.PeerInfo)
              return d2;
            var m2 = new $root.RPC.PeerInfo();
            if (d2.peerID != null) {
              if (typeof d2.peerID === "string")
                $util.base64.decode(d2.peerID, m2.peerID = $util.newBuffer($util.base64.length(d2.peerID)), 0);
              else if (d2.peerID.length)
                m2.peerID = d2.peerID;
            }
            if (d2.signedPeerRecord != null) {
              if (typeof d2.signedPeerRecord === "string")
                $util.base64.decode(d2.signedPeerRecord, m2.signedPeerRecord = $util.newBuffer($util.base64.length(d2.signedPeerRecord)), 0);
              else if (d2.signedPeerRecord.length)
                m2.signedPeerRecord = d2.signedPeerRecord;
            }
            return m2;
          }, "fromObject");
          PeerInfo.toObject = /* @__PURE__ */ __name(function toObject(m2, o) {
            if (!o)
              o = {};
            var d2 = {};
            if (m2.peerID != null && m2.hasOwnProperty("peerID")) {
              d2.peerID = o.bytes === String ? $util.base64.encode(m2.peerID, 0, m2.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m2.peerID) : m2.peerID;
              if (o.oneofs)
                d2._peerID = "peerID";
            }
            if (m2.signedPeerRecord != null && m2.hasOwnProperty("signedPeerRecord")) {
              d2.signedPeerRecord = o.bytes === String ? $util.base64.encode(m2.signedPeerRecord, 0, m2.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m2.signedPeerRecord) : m2.signedPeerRecord;
              if (o.oneofs)
                d2._signedPeerRecord = "signedPeerRecord";
            }
            return d2;
          }, "toObject");
          PeerInfo.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return PeerInfo;
        }();
        return RPC3;
      }();
      return $root;
    });
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque2(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    __name(Denque2, "Denque");
    Denque2.prototype.peekAt = /* @__PURE__ */ __name(function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    }, "peekAt");
    Denque2.prototype.get = /* @__PURE__ */ __name(function get(i) {
      return this.peekAt(i);
    }, "get");
    Denque2.prototype.peek = /* @__PURE__ */ __name(function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    }, "peek");
    Denque2.prototype.peekFront = /* @__PURE__ */ __name(function peekFront() {
      return this.peek();
    }, "peekFront");
    Denque2.prototype.peekBack = /* @__PURE__ */ __name(function peekBack() {
      return this.peekAt(-1);
    }, "peekBack");
    Object.defineProperty(Denque2.prototype, "length", {
      get: /* @__PURE__ */ __name(function length21() {
        return this.size();
      }, "length")
    });
    Denque2.prototype.size = /* @__PURE__ */ __name(function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    }, "size");
    Denque2.prototype.unshift = /* @__PURE__ */ __name(function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    }, "unshift");
    Denque2.prototype.shift = /* @__PURE__ */ __name(function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    }, "shift");
    Denque2.prototype.push = /* @__PURE__ */ __name(function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    }, "push");
    Denque2.prototype.pop = /* @__PURE__ */ __name(function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    }, "pop");
    Denque2.prototype.removeOne = /* @__PURE__ */ __name(function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    }, "removeOne");
    Denque2.prototype.remove = /* @__PURE__ */ __name(function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    }, "remove");
    Denque2.prototype.splice = /* @__PURE__ */ __name(function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    }, "splice");
    Denque2.prototype.clear = /* @__PURE__ */ __name(function clear() {
      this._head = 0;
      this._tail = 0;
    }, "clear");
    Denque2.prototype.isEmpty = /* @__PURE__ */ __name(function isEmpty() {
      return this._head === this._tail;
    }, "isEmpty");
    Denque2.prototype.toArray = /* @__PURE__ */ __name(function toArray() {
      return this._copyArray(false);
    }, "toArray");
    Denque2.prototype._fromArray = /* @__PURE__ */ __name(function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    }, "_fromArray");
    Denque2.prototype._copyArray = /* @__PURE__ */ __name(function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    }, "_copyArray");
    Denque2.prototype._growArray = /* @__PURE__ */ __name(function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    }, "_growArray");
    Denque2.prototype._shrinkArray = /* @__PURE__ */ __name(function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    }, "_shrinkArray");
    module2.exports = Denque2;
  }
});

// node_modules/iterable-ndjson/parse.browser.js
var require_parse_browser = __commonJS({
  "node_modules/iterable-ndjson/parse.browser.js"(exports2, module2) {
    module2.exports = (source) => async function* () {
      const matcher = /\r?\n/;
      const decoder = new TextDecoder("utf8");
      let buffer3 = "";
      for await (let chunk of source) {
        if (typeof chunk === "string") {
          chunk = new TextEncoder().encode(chunk);
        }
        buffer3 += decoder.decode(chunk, { stream: true });
        const parts = buffer3.split(matcher);
        buffer3 = parts.pop();
        for (let i = 0; i < parts.length; i++)
          yield JSON.parse(parts[i]);
      }
      buffer3 += decoder.decode();
      if (buffer3)
        yield JSON.parse(buffer3);
    }();
  }
});

// node_modules/iterable-ndjson/stringify.js
var require_stringify = __commonJS({
  "node_modules/iterable-ndjson/stringify.js"(exports2, module2) {
    module2.exports = (source) => async function* () {
      for await (const obj of source) {
        yield JSON.stringify(obj) + "\n";
      }
    }();
  }
});

// node_modules/iterable-ndjson/browser.js
var require_browser4 = __commonJS({
  "node_modules/iterable-ndjson/browser.js"(exports2, module2) {
    module2.exports = require_parse_browser();
    module2.exports.parse = require_parse_browser();
    module2.exports.stringify = require_stringify();
  }
});

// node_modules/@libp2p/ipni-content-routing/node_modules/eventemitter3/index.js
var require_eventemitter34 = __commonJS({
  "node_modules/@libp2p/ipni-content-routing/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    __name(Events, "Events");
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    function EventEmitter10() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    __name(EventEmitter10, "EventEmitter");
    EventEmitter10.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      var names4 = [], events2, name14;
      if (this._eventsCount === 0)
        return names4;
      for (name14 in events2 = this._events) {
        if (has.call(events2, name14))
          names4.push(prefix ? name14.slice(1) : name14);
      }
      if (Object.getOwnPropertySymbols) {
        return names4.concat(Object.getOwnPropertySymbols(events2));
      }
      return names4;
    }, "eventNames");
    EventEmitter10.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    }, "listeners");
    EventEmitter10.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    }, "listenerCount");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length21 = listeners.length, j;
        for (i = 0; i < length21; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    }, "emit");
    EventEmitter10.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    }, "on");
    EventEmitter10.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    }, "once");
    EventEmitter10.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length21 = listeners.length; i < length21; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    }, "removeListener");
    EventEmitter10.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners");
    EventEmitter10.prototype.off = EventEmitter10.prototype.removeListener;
    EventEmitter10.prototype.addListener = EventEmitter10.prototype.on;
    EventEmitter10.prefixed = prefix;
    EventEmitter10.EventEmitter = EventEmitter10;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter10;
    }
  }
});

// node_modules/@libp2p/kad-dht/node_modules/eventemitter3/index.js
var require_eventemitter35 = __commonJS({
  "node_modules/@libp2p/kad-dht/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    __name(Events, "Events");
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    function EventEmitter10() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    __name(EventEmitter10, "EventEmitter");
    EventEmitter10.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      var names4 = [], events2, name14;
      if (this._eventsCount === 0)
        return names4;
      for (name14 in events2 = this._events) {
        if (has.call(events2, name14))
          names4.push(prefix ? name14.slice(1) : name14);
      }
      if (Object.getOwnPropertySymbols) {
        return names4.concat(Object.getOwnPropertySymbols(events2));
      }
      return names4;
    }, "eventNames");
    EventEmitter10.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    }, "listeners");
    EventEmitter10.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    }, "listenerCount");
    EventEmitter10.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length21 = listeners.length, j;
        for (i = 0; i < length21; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    }, "emit");
    EventEmitter10.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    }, "on");
    EventEmitter10.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    }, "once");
    EventEmitter10.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length21 = listeners.length; i < length21; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    }, "removeListener");
    EventEmitter10.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners");
    EventEmitter10.prototype.off = EventEmitter10.prototype.removeListener;
    EventEmitter10.prototype.addListener = EventEmitter10.prototype.on;
    EventEmitter10.prefixed = prefix;
    EventEmitter10.EventEmitter = EventEmitter10;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter10;
    }
  }
});

// node_modules/@multiformats/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/@multiformats/base-x/src/index.js"(exports2, module2) {
    "use strict";
    function base42(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode79(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length21 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length21 = i2;
          pbegin++;
        }
        var it2 = size - length21;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      __name(encode79, "encode");
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length21 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length21 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length21;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      __name(decodeUnsafe, "decodeUnsafe");
      function decode97(string8) {
        var buffer3 = decodeUnsafe(string8);
        if (buffer3) {
          return buffer3;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      __name(decode97, "decode");
      return {
        encode: encode79,
        decodeUnsafe,
        decode: decode97
      };
    }
    __name(base42, "base");
    module2.exports = base42;
  }
});

// node_modules/multibase/src/util.js
var require_util2 = __commonJS({
  "node_modules/multibase/src/util.js"(exports2, module2) {
    "use strict";
    var textDecoder14 = new TextDecoder();
    var decodeText = /* @__PURE__ */ __name((bytes3) => textDecoder14.decode(bytes3), "decodeText");
    var textEncoder15 = new TextEncoder();
    var encodeText = /* @__PURE__ */ __name((text) => textEncoder15.encode(text), "encodeText");
    function concat7(arrs, length21) {
      const output3 = new Uint8Array(length21);
      let offset = 0;
      for (const arr of arrs) {
        output3.set(arr, offset);
        offset += arr.length;
      }
      return output3;
    }
    __name(concat7, "concat");
    module2.exports = { decodeText, encodeText, concat: concat7 };
  }
});

// node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/multibase/src/base.js"(exports2, module2) {
    "use strict";
    var { encodeText } = require_util2();
    var Base = class {
      static {
        __name(this, "Base");
      }
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name14, code16, factory, alphabet11) {
        this.name = name14;
        this.code = code16;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet11;
        this.codec = factory(alphabet11);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf3) {
        return this.codec.encode(buf3);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string8) {
        for (const char of string8) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string8}'`);
          }
        }
        return this.codec.decode(string8);
      }
    };
    module2.exports = Base;
  }
});

// node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/multibase/src/rfc4648.js"(exports2, module2) {
    "use strict";
    var decode97 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar) => {
      const codes8 = {};
      for (let i = 0; i < alphabet11.length; ++i) {
        codes8[alphabet11[i]] = i;
      }
      let end = string8.length;
      while (string8[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits3 = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes8[string8[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string8[i]);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits3 += bitsPerChar;
        if (bits3 >= 8) {
          bits3 -= 8;
          out[written++] = 255 & buffer3 >> bits3;
        }
      }
      if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    }, "decode");
    var encode79 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
      const pad = alphabet11[alphabet11.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits3 = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits3 += 8;
        while (bits3 > bitsPerChar) {
          bits3 -= bitsPerChar;
          out += alphabet11[mask & buffer3 >> bits3];
        }
      }
      if (bits3) {
        out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    }, "encode");
    var rfc464830 = /* @__PURE__ */ __name((bitsPerChar) => (alphabet11) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode79(input, alphabet11, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode97(input, alphabet11, bitsPerChar);
        }
      };
    }, "rfc4648");
    module2.exports = { rfc4648: rfc464830 };
  }
});

// node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "node_modules/multibase/src/constants.js"(exports2, module2) {
    "use strict";
    var baseX30 = require_src2();
    var Base = require_base();
    var { rfc4648: rfc464830 } = require_rfc4648();
    var { decodeText, encodeText } = require_util2();
    var identity23 = /* @__PURE__ */ __name(() => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    }, "identity");
    var constants = [
      ["identity", "\0", identity23, ""],
      ["base2", "0", rfc464830(1), "01"],
      ["base8", "7", rfc464830(3), "01234567"],
      ["base10", "9", baseX30, "0123456789"],
      ["base16", "f", rfc464830(4), "0123456789abcdef"],
      ["base16upper", "F", rfc464830(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc464830(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc464830(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc464830(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc464830(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc464830(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc464830(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc464830(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc464830(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc464830(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX30, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX30, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX30, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX30, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc464830(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc464830(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc464830(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc464830(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names4 = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes8 = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names4[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module2.exports = {
      names: names4,
      codes: codes8
    };
  }
});

// node_modules/multibase/src/index.js
var require_src3 = __commonJS({
  "node_modules/multibase/src/index.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat: concat7 } = require_util2();
    function multibase(nameOrCode, buf3) {
      if (!buf3) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name: name14, codeBuf } = encoding(nameOrCode);
      validEncode(name14, buf3);
      return concat7([codeBuf, buf3], codeBuf.length + buf3.length);
    }
    __name(multibase, "multibase");
    function encode79(nameOrCode, buf3) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf3));
      return concat7([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    __name(encode79, "encode");
    function decode97(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    __name(decode97, "decode");
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    __name(isEncoded, "isEncoded");
    function validEncode(name14, buf3) {
      const enc = encoding(name14);
      enc.decode(decodeText(buf3));
    }
    __name(validEncode, "validEncode");
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    __name(encoding, "encoding");
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    __name(encodingFromData, "encodingFromData");
    exports2 = module2.exports = multibase;
    exports2.encode = encode79;
    exports2.decode = decode97;
    exports2.isEncoded = isEncoded;
    exports2.encoding = encoding;
    exports2.encodingFromData = encodingFromData;
    var names4 = Object.freeze(constants.names);
    var codes8 = Object.freeze(constants.codes);
    exports2.names = names4;
    exports2.codes = codes8;
  }
});

// node_modules/multihashes/node_modules/varint/encode.js
var require_encode3 = __commonJS({
  "node_modules/multihashes/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode79;
    var MSB21 = 128;
    var REST21 = 127;
    var MSBALL19 = ~REST21;
    var INT19 = Math.pow(2, 31);
    function encode79(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT19) {
        out[offset++] = num & 255 | MSB21;
        num /= 128;
      }
      while (num & MSBALL19) {
        out[offset++] = num & 255 | MSB21;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode79.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode79, "encode");
  }
});

// node_modules/multihashes/node_modules/varint/decode.js
var require_decode3 = __commonJS({
  "node_modules/multihashes/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read21;
    var MSB21 = 128;
    var REST21 = 127;
    function read21(buf3, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
      do {
        if (counter >= l) {
          read21.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST21) << shift : (b & REST21) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB21);
      read21.bytes = counter - offset;
      return res;
    }
    __name(read21, "read");
  }
});

// node_modules/multihashes/node_modules/varint/length.js
var require_length3 = __commonJS({
  "node_modules/multihashes/node_modules/varint/length.js"(exports2, module2) {
    var N122 = Math.pow(2, 7);
    var N222 = Math.pow(2, 14);
    var N322 = Math.pow(2, 21);
    var N422 = Math.pow(2, 28);
    var N522 = Math.pow(2, 35);
    var N622 = Math.pow(2, 42);
    var N722 = Math.pow(2, 49);
    var N821 = Math.pow(2, 56);
    var N921 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N122 ? 1 : value < N222 ? 2 : value < N322 ? 3 : value < N422 ? 4 : value < N522 ? 5 : value < N622 ? 6 : value < N722 ? 7 : value < N821 ? 8 : value < N921 ? 9 : 10;
    };
  }
});

// node_modules/multihashes/node_modules/varint/index.js
var require_varint3 = __commonJS({
  "node_modules/multihashes/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode3(),
      decode: require_decode3(),
      encodingLength: require_length3()
    };
  }
});

// node_modules/multihashes/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/multihashes/src/constants.js"(exports2, module2) {
    "use strict";
    var names4 = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module2.exports = { names: names4 };
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/vendor/base-x.js
function base37(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
var src25, _brrp__multiformats_scope_baseX25, base_x_default25;
var init_base_x = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/vendor/base-x.js"() {
    __name(base37, "base");
    src25 = base37;
    _brrp__multiformats_scope_baseX25 = src25;
    base_x_default25 = _brrp__multiformats_scope_baseX25;
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bytes.js
var empty27, equals28, coerce27, fromString13, toString14;
var init_bytes = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bytes.js"() {
    empty27 = new Uint8Array(0);
    equals28 = /* @__PURE__ */ __name((aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    }, "equals");
    coerce27 = /* @__PURE__ */ __name((o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    }, "coerce");
    fromString13 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString");
    toString14 = /* @__PURE__ */ __name((b) => new TextDecoder().decode(b), "toString");
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base.js
var Encoder26, Decoder27, ComposedDecoder25, or26, Codec25, from36, baseX25, decode71, encode59, rfc464825;
var init_base = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder26 = class {
      static {
        __name(this, "Encoder");
      }
      constructor(name14, prefix, baseEncode) {
        this.name = name14;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes3) {
        if (bytes3 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes3)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder27 = class {
      static {
        __name(this, "Decoder");
      }
      constructor(name14, prefix, baseDecode) {
        this.name = name14;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or26(this, decoder);
      }
    };
    ComposedDecoder25 = class {
      static {
        __name(this, "ComposedDecoder");
      }
      constructor(decoders2) {
        this.decoders = decoders2;
      }
      or(decoder) {
        return or26(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or26 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder25({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    }), "or");
    Codec25 = class {
      static {
        __name(this, "Codec");
      }
      constructor(name14, prefix, baseEncode, baseDecode) {
        this.name = name14;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder26(name14, prefix, baseEncode);
        this.decoder = new Decoder27(name14, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from36 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec25(name14, prefix, encode79, decode97), "from");
    baseX25 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
      const { encode: encode79, decode: decode97 } = base_x_default25(alphabet11, name14);
      return from36({
        prefix,
        name: name14,
        encode: encode79,
        decode: (text) => coerce27(decode97(text))
      });
    }, "baseX");
    decode71 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
      const codes8 = {};
      for (let i = 0; i < alphabet11.length; ++i) {
        codes8[alphabet11[i]] = i;
      }
      let end = string8.length;
      while (string8[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits3 = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes8[string8[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name14} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits3 += bitsPerChar;
        if (bits3 >= 8) {
          bits3 -= 8;
          out[written++] = 255 & buffer3 >> bits3;
        }
      }
      if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    }, "decode");
    encode59 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
      const pad = alphabet11[alphabet11.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits3 = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits3 += 8;
        while (bits3 > bitsPerChar) {
          bits3 -= bitsPerChar;
          out += alphabet11[mask & buffer3 >> bits3];
        }
      }
      if (bits3) {
        out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    }, "encode");
    rfc464825 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
      return from36({
        prefix,
        name: name14,
        encode(input) {
          return encode59(input, alphabet11, bitsPerChar);
        },
        decode(input) {
          return decode71(input, alphabet11, bitsPerChar, name14);
        }
      });
    }, "rfc4648");
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports13 = {};
__export(identity_exports13, {
  identity: () => identity15
});
var identity15;
var init_identity = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity15 = from36({
      prefix: "\0",
      name: "identity",
      encode: (buf3) => toString14(buf3),
      decode: (str) => fromString13(str)
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports7 = {};
__export(base2_exports7, {
  base2: () => base210
});
var base210;
var init_base2 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base210 = rfc464825({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports7 = {};
__export(base8_exports7, {
  base8: () => base87
});
var base87;
var init_base8 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base87 = rfc464825({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports7 = {};
__export(base10_exports7, {
  base10: () => base107
});
var base107;
var init_base10 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base107 = baseX25({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports7 = {};
__export(base16_exports7, {
  base16: () => base167,
  base16upper: () => base16upper7
});
var base167, base16upper7;
var init_base16 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base167 = rfc464825({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper7 = rfc464825({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports8 = {};
__export(base32_exports8, {
  base32: () => base3224,
  base32hex: () => base32hex24,
  base32hexpad: () => base32hexpad24,
  base32hexpadupper: () => base32hexpadupper24,
  base32hexupper: () => base32hexupper24,
  base32pad: () => base32pad24,
  base32padupper: () => base32padupper24,
  base32upper: () => base32upper24,
  base32z: () => base32z24
});
var base3224, base32upper24, base32pad24, base32padupper24, base32hex24, base32hexupper24, base32hexpad24, base32hexpadupper24, base32z24;
var init_base32 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base3224 = rfc464825({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper24 = rfc464825({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad24 = rfc464825({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper24 = rfc464825({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex24 = rfc464825({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper24 = rfc464825({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad24 = rfc464825({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper24 = rfc464825({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z24 = rfc464825({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports7 = {};
__export(base36_exports7, {
  base36: () => base368,
  base36upper: () => base36upper8
});
var base368, base36upper8;
var init_base36 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base368 = baseX25({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper8 = baseX25({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports8 = {};
__export(base58_exports8, {
  base58btc: () => base58btc25,
  base58flickr: () => base58flickr25
});
var base58btc25, base58flickr25;
var init_base58 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc25 = baseX25({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr25 = baseX25({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports8 = {};
__export(base64_exports8, {
  base64: () => base6424,
  base64pad: () => base64pad24,
  base64url: () => base64url24,
  base64urlpad: () => base64urlpad24
});
var base6424, base64pad24, base64url24, base64urlpad24;
var init_base64 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base6424 = rfc464825({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad24 = rfc464825({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url24 = rfc464825({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad24 = rfc464825({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports7 = {};
__export(base256emoji_exports7, {
  base256emoji: () => base256emoji7
});
function encode60(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars7[c];
    return p;
  }, "");
}
function decode72(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes7[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet7, alphabetBytesToChars7, alphabetCharsToBytes7, base256emoji7;
var init_base256emoji = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet7 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars7 = alphabet7.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    alphabetCharsToBytes7 = alphabet7.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    __name(encode60, "encode");
    __name(decode72, "decode");
    base256emoji7 = from36({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode60,
      decode: decode72
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/vendor/varint.js
function encode61(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT14) {
    out[offset++] = num & 255 | MSB16;
    num /= 128;
  }
  while (num & MSBALL14) {
    out[offset++] = num & 255 | MSB16;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode61.bytes = offset - oldOffset + 1;
  return out;
}
function read16(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read16.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$114) << shift : (b & REST$114) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$114);
  read16.bytes = counter - offset;
  return res;
}
var encode_114, MSB16, REST16, MSBALL14, INT14, decode73, MSB$114, REST$114, N117, N217, N317, N417, N517, N617, N717, N816, N916, length16, varint17, _brrp_varint14, varint_default14;
var init_varint = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/vendor/varint.js"() {
    encode_114 = encode61;
    MSB16 = 128;
    REST16 = 127;
    MSBALL14 = ~REST16;
    INT14 = Math.pow(2, 31);
    __name(encode61, "encode");
    decode73 = read16;
    MSB$114 = 128;
    REST$114 = 127;
    __name(read16, "read");
    N117 = Math.pow(2, 7);
    N217 = Math.pow(2, 14);
    N317 = Math.pow(2, 21);
    N417 = Math.pow(2, 28);
    N517 = Math.pow(2, 35);
    N617 = Math.pow(2, 42);
    N717 = Math.pow(2, 49);
    N816 = Math.pow(2, 56);
    N916 = Math.pow(2, 63);
    length16 = /* @__PURE__ */ __name(function(value) {
      return value < N117 ? 1 : value < N217 ? 2 : value < N317 ? 3 : value < N417 ? 4 : value < N517 ? 5 : value < N617 ? 6 : value < N717 ? 7 : value < N816 ? 8 : value < N916 ? 9 : 10;
    }, "length");
    varint17 = {
      encode: encode_114,
      decode: decode73,
      encodingLength: length16
    };
    _brrp_varint14 = varint17;
    varint_default14 = _brrp_varint14;
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/varint.js
var decode74, encodeTo14, encodingLength15;
var init_varint2 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode74 = /* @__PURE__ */ __name((data, offset = 0) => {
      const code16 = varint_default14.decode(data, offset);
      return [
        code16,
        varint_default14.decode.bytes
      ];
    }, "decode");
    encodeTo14 = /* @__PURE__ */ __name((int, target, offset = 0) => {
      varint_default14.encode(int, target, offset);
      return target;
    }, "encodeTo");
    encodingLength15 = /* @__PURE__ */ __name((int) => {
      return varint_default14.encodingLength(int);
    }, "encodingLength");
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/hashes/digest.js
var create16, decode75, equals29, Digest14;
var init_digest = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create16 = /* @__PURE__ */ __name((code16, digest13) => {
      const size = digest13.byteLength;
      const sizeOffset = encodingLength15(code16);
      const digestOffset = sizeOffset + encodingLength15(size);
      const bytes3 = new Uint8Array(digestOffset + size);
      encodeTo14(code16, bytes3, 0);
      encodeTo14(size, bytes3, sizeOffset);
      bytes3.set(digest13, digestOffset);
      return new Digest14(code16, size, digest13, bytes3);
    }, "create");
    decode75 = /* @__PURE__ */ __name((multihash) => {
      const bytes3 = coerce27(multihash);
      const [code16, sizeOffset] = decode74(bytes3);
      const [size, digestOffset] = decode74(bytes3.subarray(sizeOffset));
      const digest13 = bytes3.subarray(sizeOffset + digestOffset);
      if (digest13.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest14(code16, size, digest13, bytes3);
    }, "decode");
    equals29 = /* @__PURE__ */ __name((a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals28(a.bytes, b.bytes);
      }
    }, "equals");
    Digest14 = class {
      static {
        __name(this, "Digest");
      }
      constructor(code16, size, digest13, bytes3) {
        this.code = code16;
        this.size = size;
        this.digest = digest13;
        this.bytes = bytes3;
      }
    };
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/hashes/hasher.js
var from37, Hasher12;
var init_hasher = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from37 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher12(name14, code16, encode79), "from");
    Hasher12 = class {
      static {
        __name(this, "Hasher");
      }
      constructor(name14, code16, encode79) {
        this.name = name14;
        this.code = code16;
        this.encode = encode79;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create16(this.code, result) : result.then((digest13) => create16(this.code, digest13));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports7 = {};
__export(sha2_browser_exports7, {
  sha256: () => sha25613,
  sha512: () => sha51213
});
var sha12, sha25613, sha51213;
var init_sha2_browser = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha12 = /* @__PURE__ */ __name((name14) => async (data) => new Uint8Array(await crypto.subtle.digest(name14, data)), "sha");
    sha25613 = from37({
      name: "sha2-256",
      code: 18,
      encode: sha12("SHA-256")
    });
    sha51213 = from37({
      name: "sha2-512",
      code: 19,
      encode: sha12("SHA-512")
    });
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports14 = {};
__export(identity_exports14, {
  identity: () => identity16
});
var code12, name9, encode62, digest9, identity16;
var init_identity2 = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code12 = 0;
    name9 = "identity";
    encode62 = coerce27;
    digest9 = /* @__PURE__ */ __name((input) => create16(code12, encode62(input)), "digest");
    identity16 = {
      code: code12,
      name: name9,
      encode: encode62,
      digest: digest9
    };
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/codecs/raw.js
var init_raw = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder10, textDecoder9;
var init_json = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder10 = new TextEncoder();
    textDecoder9 = new TextDecoder();
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/cid.js
var CID10, parseCIDtoBytes10, toStringV010, toStringV110, DAG_PB_CODE10, SHA_256_CODE10, encodeCID10, cidSymbol10, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID10 = class _CID {
      static {
        __name(this, "CID");
      }
      constructor(version4, code16, multihash, bytes3) {
        this.code = code16;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes3;
        this.byteOffset = bytes3.byteOffset;
        this.byteLength = bytes3.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code16, multihash } = this;
            if (code16 !== DAG_PB_CODE10) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE10) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code16, digest: digest13 } = this.multihash;
            const multihash = create16(code16, digest13);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals29(this.multihash, other.multihash);
      }
      toString(base42) {
        const { bytes: bytes3, version: version4, _baseCache } = this;
        switch (version4) {
          case 0:
            return toStringV010(bytes3, _baseCache, base42 || base58btc25.encoder);
          default:
            return toStringV110(bytes3, _baseCache, base42 || base3224.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol10] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
          return new _CID(version4, code16, multihash, bytes3 || encodeCID10(version4, code16, multihash.bytes));
        } else if (value != null && value[cidSymbol10] === true) {
          const { version: version4, multihash, code: code16 } = value;
          const digest13 = decode75(multihash);
          return _CID.create(version4, code16, digest13);
        } else {
          return null;
        }
      }
      static create(version4, code16, digest13) {
        if (typeof code16 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version4) {
          case 0: {
            if (code16 !== DAG_PB_CODE10) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE10}) block encoding`);
            } else {
              return new _CID(version4, code16, digest13, digest13.bytes);
            }
          }
          case 1: {
            const bytes3 = encodeCID10(version4, code16, digest13.bytes);
            return new _CID(version4, code16, digest13, bytes3);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest13) {
        return _CID.create(0, DAG_PB_CODE10, digest13);
      }
      static createV1(code16, digest13) {
        return _CID.create(1, code16, digest13);
      }
      static decode(bytes3) {
        const [cid, remainder] = _CID.decodeFirst(bytes3);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes3) {
        const specs = _CID.inspectBytes(bytes3);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce27(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest13 = new Digest14(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
        return [
          cid,
          bytes3.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = /* @__PURE__ */ __name(() => {
          const [i, length21] = decode74(initialBytes.subarray(offset));
          offset += length21;
          return i;
        }, "next");
        let version4 = next();
        let codec = DAG_PB_CODE10;
        if (version4 === 18) {
          version4 = 0;
          offset = 0;
        } else if (version4 === 1) {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version4,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base42) {
        const [prefix, bytes3] = parseCIDtoBytes10(source, base42);
        const cid = _CID.decode(bytes3);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes10 = /* @__PURE__ */ __name((source, base42) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base42 || base58btc25;
          return [
            base58btc25.prefix,
            decoder.decode(`${base58btc25.prefix}${source}`)
          ];
        }
        case base58btc25.prefix: {
          const decoder = base42 || base58btc25;
          return [
            base58btc25.prefix,
            decoder.decode(source)
          ];
        }
        case base3224.prefix: {
          const decoder = base42 || base3224;
          return [
            base3224.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base42 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base42.decode(source)
          ];
        }
      }
    }, "parseCIDtoBytes");
    toStringV010 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
      const { prefix } = base42;
      if (prefix !== base58btc25.prefix) {
        throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
      }
      const cid = cache16.get(prefix);
      if (cid == null) {
        const cid2 = base42.encode(bytes3).slice(1);
        cache16.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    }, "toStringV0");
    toStringV110 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
      const { prefix } = base42;
      const cid = cache16.get(prefix);
      if (cid == null) {
        const cid2 = base42.encode(bytes3);
        cache16.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    }, "toStringV1");
    DAG_PB_CODE10 = 112;
    SHA_256_CODE10 = 18;
    encodeCID10 = /* @__PURE__ */ __name((version4, code16, multihash) => {
      const codeOffset = encodingLength15(version4);
      const hashOffset = codeOffset + encodingLength15(code16);
      const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo14(version4, bytes3, 0);
      encodeTo14(code16, bytes3, codeOffset);
      bytes3.set(multihash, hashOffset);
      return bytes3;
    }, "encodeCID");
    cidSymbol10 = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = /* @__PURE__ */ __name((range, message2) => {
      if (range.test(version)) {
        console.warn(message2);
      } else {
        throw new Error(message2);
      }
    }, "deprecate");
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multihashes/node_modules/multiformats/esm/src/basics.js
var bases7, hashes7;
var init_basics = __esm({
  "node_modules/multihashes/node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases7 = {
      ...identity_exports13,
      ...base2_exports7,
      ...base8_exports7,
      ...base10_exports7,
      ...base16_exports7,
      ...base32_exports8,
      ...base36_exports7,
      ...base58_exports8,
      ...base64_exports8,
      ...base256emoji_exports7
    };
    hashes7 = {
      ...sha2_browser_exports7,
      ...identity_exports14
    };
  }
});

// node_modules/multihashes/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array4(buf3) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength);
  }
  return buf3;
}
var init_as_uint8array = __esm({
  "node_modules/multihashes/node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
    __name(asUint8Array4, "asUint8Array");
  }
});

// node_modules/multihashes/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe11(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array4(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
var init_alloc = __esm({
  "node_modules/multihashes/node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
    __name(allocUnsafe11, "allocUnsafe");
  }
});

// node_modules/multihashes/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec7(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: { decode: decode97 }
  };
}
var string6, ascii6, BASES6, bases_default6;
var init_bases = __esm({
  "node_modules/multihashes/node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    __name(createCodec7, "createCodec");
    string6 = createCodec7("utf8", "u", (buf3) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf3);
    }, (str) => {
      const encoder2 = new TextEncoder();
      return encoder2.encode(str.substring(1));
    });
    ascii6 = createCodec7("ascii", "a", (buf3) => {
      let string8 = "a";
      for (let i = 0; i < buf3.length; i++) {
        string8 += String.fromCharCode(buf3[i]);
      }
      return string8;
    }, (str) => {
      str = str.substring(1);
      const buf3 = allocUnsafe11(str.length);
      for (let i = 0; i < str.length; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    });
    BASES6 = {
      utf8: string6,
      "utf-8": string6,
      hex: bases7.base16,
      latin1: ascii6,
      ascii: ascii6,
      binary: ascii6,
      ...bases7
    };
    bases_default6 = BASES6;
  }
});

// node_modules/multihashes/node_modules/uint8arrays/esm/src/to-string.js
var to_string_exports = {};
__export(to_string_exports, {
  toString: () => toString15
});
function toString15(array, encoding = "utf8") {
  const base42 = bases_default6[encoding];
  if (!base42) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base42.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "node_modules/multihashes/node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
    __name(toString15, "toString");
  }
});

// node_modules/multihashes/node_modules/uint8arrays/esm/src/from-string.js
var from_string_exports = {};
__export(from_string_exports, {
  fromString: () => fromString14
});
function fromString14(string8, encoding = "utf8") {
  const base42 = bases_default6[encoding];
  if (!base42) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array4(globalThis.Buffer.from(string8, "utf-8"));
  }
  return base42.decoder.decode(`${base42.prefix}${string8}`);
}
var init_from_string = __esm({
  "node_modules/multihashes/node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    init_as_uint8array();
    __name(fromString14, "fromString");
  }
});

// node_modules/multihashes/node_modules/uint8arrays/esm/src/concat.js
var concat_exports = {};
__export(concat_exports, {
  concat: () => concat5
});
function concat5(arrays, length21) {
  if (!length21) {
    length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe11(length21);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array4(output3);
}
var init_concat = __esm({
  "node_modules/multihashes/node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
    init_as_uint8array();
    __name(concat5, "concat");
  }
});

// node_modules/multihashes/src/index.js
var require_src4 = __commonJS({
  "node_modules/multihashes/src/index.js"(exports2, module2) {
    "use strict";
    var multibase = require_src3();
    var varint22 = require_varint3();
    var { names: names4 } = require_constants2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var codes8 = (
      /** @type {import('./types').CodeNameMap} */
      {}
    );
    for (const key in names4) {
      const name14 = (
        /** @type {HashName} */
        key
      );
      codes8[names4[name14]] = name14;
    }
    Object.freeze(codes8);
    function toHexString(hash3) {
      if (!(hash3 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash3, "base16");
    }
    __name(toHexString, "toHexString");
    function fromHexString(hash3) {
      return uint8ArrayFromString(hash3, "base16");
    }
    __name(fromHexString, "fromHexString");
    function toB58String(hash3) {
      if (!(hash3 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash3)).slice(1);
    }
    __name(toB58String, "toB58String");
    function fromB58String(hash3) {
      const encoded = hash3 instanceof Uint8Array ? uint8ArrayToString(hash3) : hash3;
      return multibase.decode("z" + encoded);
    }
    __name(fromB58String, "fromB58String");
    function decode97(bytes3) {
      if (!(bytes3 instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes3.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code16 = (
        /** @type {HashCode} */
        varint22.decode(bytes3)
      );
      if (!isValidCode(code16)) {
        throw new Error(`multihash unknown function code: 0x${code16.toString(16)}`);
      }
      bytes3 = bytes3.slice(varint22.decode.bytes);
      const len = varint22.decode(bytes3);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes3 = bytes3.slice(varint22.decode.bytes);
      if (bytes3.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes3, "base16")}`);
      }
      return {
        code: code16,
        name: codes8[code16],
        length: len,
        digest: bytes3
      };
    }
    __name(decode97, "decode");
    function encode79(digest13, code16, length21) {
      if (!digest13 || code16 === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code16);
      if (!(digest13 instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length21 == null) {
        length21 = digest13.length;
      }
      if (length21 && digest13.length !== length21) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash3 = varint22.encode(hashfn);
      const len = varint22.encode(length21);
      return uint8ArrayConcat([hash3, len, digest13], hash3.length + len.length + digest13.length);
    }
    __name(encode79, "encode");
    function coerceCode(name14) {
      let code16 = name14;
      if (typeof name14 === "string") {
        if (names4[name14] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name14}`);
        }
        code16 = names4[name14];
      }
      if (typeof code16 !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code16}`);
      }
      if (codes8[code16] === void 0 && !isAppCode(code16)) {
        throw new Error(`Unrecognized function code: ${code16}`);
      }
      return code16;
    }
    __name(coerceCode, "coerceCode");
    function isAppCode(code16) {
      return code16 > 0 && code16 < 16;
    }
    __name(isAppCode, "isAppCode");
    function isValidCode(code16) {
      if (isAppCode(code16)) {
        return true;
      }
      if (codes8[code16]) {
        return true;
      }
      return false;
    }
    __name(isValidCode, "isValidCode");
    function validate3(multihash) {
      decode97(multihash);
    }
    __name(validate3, "validate");
    function prefix(multihash) {
      validate3(multihash);
      return multihash.subarray(0, 2);
    }
    __name(prefix, "prefix");
    module2.exports = {
      names: names4,
      codes: codes8,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode97,
      encode: encode79,
      coerceCode,
      isAppCode,
      validate: validate3,
      prefix,
      isValidCode
    };
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventQueue = class {
      static {
        __name(this, "EventQueue");
      }
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve, reject) => {
                this.pullQueue.push({ resolve, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      static {
        __name(this, "EventIterator");
      }
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports2.EventIterator = EventIterator2;
    exports2.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports2.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    __name(subscribe, "subscribe");
    exports2.subscribe = subscribe;
    exports2.default = event_iterator_1.EventIterator;
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports2, module2) {
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    __name(isElectron2, "isElectron");
    module2.exports = isElectron2;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/helia/node_modules/@libp2p/logger/dist/src/index.js
var import_debug = __toESM(require_browser(), 1);

// node_modules/helia/node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base, "base");
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/helia/node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var equals = /* @__PURE__ */ __name((aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}, "equals");
var coerce = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/helia/node_modules/multiformats/src/bases/base.js
var Encoder = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = /* @__PURE__ */ __name((left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name14, prefix, baseEncode);
    this.decoder = new Decoder(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec(name14, prefix, encode79, decode97), "from");
var baseX = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default(alphabet11, name14);
  return from({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce(decode97(text))
  });
}, "baseX");
var decode = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc4648 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from({
    prefix,
    name: name14,
    encode(input) {
      return encode(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/helia/node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/helia/node_modules/multiformats/src/bases/base32.js
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/helia/node_modules/multiformats/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/helia/node_modules/@libp2p/logger/dist/src/index.js
import_debug.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
import_debug.default.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
import_debug.default.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
import_debug.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger, "createDisabledLogger");
function logger(name14) {
  let trace = createDisabledLogger(`${name14}:trace`);
  if (import_debug.default.enabled(`${name14}:trace`) && import_debug.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug.default)(name14), {
    error: (0, import_debug.default)(`${name14}:error`),
    trace
  });
}
__name(logger, "logger");

// node_modules/blockstore-core/dist/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  closeFailedError: () => closeFailedError,
  deleteFailedError: () => deleteFailedError,
  getFailedError: () => getFailedError,
  hasFailedError: () => hasFailedError,
  notFoundError: () => notFoundError,
  openFailedError: () => openFailedError,
  putFailedError: () => putFailedError
});
var import_err_code = __toESM(require_err_code(), 1);
function openFailedError(err) {
  err = err ?? new Error("Open failed");
  return (0, import_err_code.default)(err, "ERR_OPEN_FAILED");
}
__name(openFailedError, "openFailedError");
function closeFailedError(err) {
  err = err ?? new Error("Close failed");
  return (0, import_err_code.default)(err, "ERR_CLOSE_FAILED");
}
__name(closeFailedError, "closeFailedError");
function putFailedError(err) {
  err = err ?? new Error("Put failed");
  return (0, import_err_code.default)(err, "ERR_PUT_FAILED");
}
__name(putFailedError, "putFailedError");
function getFailedError(err) {
  err = err ?? new Error("Get failed");
  return (0, import_err_code.default)(err, "ERR_GET_FAILED");
}
__name(getFailedError, "getFailedError");
function deleteFailedError(err) {
  err = err ?? new Error("Delete failed");
  return (0, import_err_code.default)(err, "ERR_DELETE_FAILED");
}
__name(deleteFailedError, "deleteFailedError");
function hasFailedError(err) {
  err = err ?? new Error("Has failed");
  return (0, import_err_code.default)(err, "ERR_HAS_FAILED");
}
__name(hasFailedError, "hasFailedError");
function notFoundError(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code.default)(err, "ERR_NOT_FOUND");
}
__name(notFoundError, "notFoundError");
function abortedError(err) {
  err = err ?? new Error("Aborted");
  return (0, import_err_code.default)(err, "ERR_ABORTED");
}
__name(abortedError, "abortedError");

// node_modules/blockstore-core/dist/src/base.js
var BaseBlockstore = class {
  static {
    __name(this, "BaseBlockstore");
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options) {
    for await (const { cid, block } of source) {
      await this.put(cid, block, options);
      yield cid;
    }
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  async *getMany(source, options) {
    for await (const key of source) {
      yield {
        cid: key,
        block: await this.get(key, options)
      };
    }
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options) {
    throw new Error(".getAll is not implemented");
  }
};

// node_modules/blockstore-core/node_modules/multiformats/dist/src/bytes.js
var empty2 = new Uint8Array(0);
function equals2(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals2, "equals");
function coerce2(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce2, "coerce");

// node_modules/blockstore-core/node_modules/multiformats/dist/src/vendor/base-x.js
function base2(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base2, "base");
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/blockstore-core/node_modules/multiformats/dist/src/bases/base.js
var Encoder2 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or2(left, right) {
  return new ComposedDecoder2({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or2, "or");
var Codec2 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name14, prefix, baseEncode);
    this.decoder = new Decoder2(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from2({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec2(name14, prefix, encode79, decode97);
}
__name(from2, "from");
function baseX2({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default2(alphabet11, name14);
  return from2({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce2(decode97(text))
  });
}
__name(baseX2, "baseX");
function decode2(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode2, "decode");
function encode2(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode2, "encode");
function rfc46482({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from2({
    prefix,
    name: name14,
    encode(input) {
      return encode2(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode2(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc46482, "rfc4648");

// node_modules/blockstore-core/node_modules/multiformats/dist/src/bases/base32.js
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/blockstore-core/node_modules/multiformats/dist/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/blockstore-core/node_modules/multiformats/dist/src/vendor/varint.js
var encode_1 = encode3;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode3, "encode");
var decode3 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
__name(read, "read");
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = /* @__PURE__ */ __name(function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
}, "length");
var varint = {
  encode: encode_1,
  decode: decode3,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/blockstore-core/node_modules/multiformats/dist/src/varint.js
function decode4(data, offset = 0) {
  const code16 = varint_default.decode(data, offset);
  return [code16, varint_default.decode.bytes];
}
__name(decode4, "decode");
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
__name(encodeTo, "encodeTo");
function encodingLength(int) {
  return varint_default.encodingLength(int);
}
__name(encodingLength, "encodingLength");

// node_modules/blockstore-core/node_modules/multiformats/dist/src/hashes/digest.js
function create(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength(code16);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo(code16, bytes3, 0);
  encodeTo(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest(code16, size, digest13, bytes3);
}
__name(create, "create");
function decode5(multihash) {
  const bytes3 = coerce2(multihash);
  const [code16, sizeOffset] = decode4(bytes3);
  const [size, digestOffset] = decode4(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code16, size, digest13, bytes3);
}
__name(decode5, "decode");
function equals3(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals2(a.bytes, data.bytes);
  }
}
__name(equals3, "equals");
var Digest = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/blockstore-core/node_modules/multiformats/dist/src/cid.js
function format(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV0(bytes3, baseCache(link), base42 ?? base58btc2.encoder);
    default:
      return toStringV1(bytes3, baseCache(link), base42 ?? base322.encoder);
  }
}
__name(format, "format");
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache14 = cache.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache, "baseCache");
var CID = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals3(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format(this, base42);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID(version4, code16, multihash.bytes));
    } else if (value[cidSymbol] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode5(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode4(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base42 ?? base58btc2;
      return [base58btc2.prefix, decoder.decode(source)];
    }
    case base322.prefix: {
      const decoder = base42 ?? base322;
      return [base322.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes, "parseCIDtoBytes");
function toStringV0(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV0, "toStringV0");
function toStringV1(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV1, "toStringV1");
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version4, code16, multihash) {
  const codeOffset = encodingLength(version4);
  const hashOffset = codeOffset + encodingLength(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version4, bytes3, 0);
  encodeTo(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID, "encodeCID");
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// node_modules/blockstore-core/node_modules/multiformats/dist/src/codecs/raw.js
var code = 85;

// node_modules/blockstore-core/dist/src/memory.js
var MemoryBlockstore = class extends BaseBlockstore {
  static {
    __name(this, "MemoryBlockstore");
  }
  data;
  constructor() {
    super();
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(base322.encode(key.multihash.bytes), val);
    return key;
  }
  get(key) {
    const buf3 = this.data.get(base322.encode(key.multihash.bytes));
    if (buf3 == null) {
      throw notFoundError();
    }
    return buf3;
  }
  has(key) {
    return this.data.has(base322.encode(key.multihash.bytes));
  }
  async delete(key) {
    this.data.delete(base322.encode(key.multihash.bytes));
  }
  async *getAll() {
    for (const [key, value] of this.data.entries()) {
      yield {
        cid: CID.createV1(code, decode5(base322.decode(key))),
        block: value
      };
    }
  }
};

// node_modules/blockstore-core/node_modules/multiformats/dist/src/bases/base64.js
var base642 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/weald/node_modules/ms/dist/index.mjs
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
function ms(value, options) {
  try {
    if (typeof value === "string" && value.length > 0) {
      return parse(value);
    } else if (typeof value === "number" && isFinite(value)) {
      return options?.long ? fmtLong(value) : fmtShort(value);
    }
    throw new Error("Value is not a string or number.");
  } catch (error) {
    const message2 = isError(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
    throw new Error(message2);
  }
}
__name(ms, "ms");
function parse(str) {
  str = String(str);
  if (str.length > 100) {
    throw new Error("Value exceeds the maximum length of 100 characters.");
  }
  const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return NaN;
  }
  const n = parseFloat(match[1]);
  const type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      throw new Error(`The unit ${type} was matched, but no matching case exists.`);
  }
}
__name(parse, "parse");
var dist_default = ms;
function fmtShort(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return `${Math.round(ms2 / d)}d`;
  }
  if (msAbs >= h) {
    return `${Math.round(ms2 / h)}h`;
  }
  if (msAbs >= m) {
    return `${Math.round(ms2 / m)}m`;
  }
  if (msAbs >= s) {
    return `${Math.round(ms2 / s)}s`;
  }
  return `${ms2}ms`;
}
__name(fmtShort, "fmtShort");
function fmtLong(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return `${ms2} ms`;
}
__name(fmtLong, "fmtLong");
function plural(ms2, msAbs, n, name14) {
  const isPlural = msAbs >= n * 1.5;
  return `${Math.round(ms2 / n)} ${name14}${isPlural ? "s" : ""}`;
}
__name(plural, "plural");
function isError(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
__name(isError, "isError");

// node_modules/weald/dist/src/common.js
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce32;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = dist_default;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash3 = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
      hash3 |= 0;
    }
    return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
  }
  __name(selectColor, "selectColor");
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug19(...args) {
      if (!debug19.enabled) {
        return;
      }
      const self2 = debug19;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format14) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format14];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    __name(debug19, "debug");
    debug19.namespace = namespace;
    debug19.useColors = createDebug.useColors();
    debug19.color = createDebug.selectColor(namespace);
    debug19.extend = extend;
    debug19.destroy = createDebug.destroy;
    Object.defineProperty(debug19, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug19);
    }
    return debug19;
  }
  __name(createDebug, "createDebug");
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  __name(extend, "extend");
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split2.length;
    for (i = 0; i < len; i++) {
      if (!split2[i]) {
        continue;
      }
      namespaces = split2[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  __name(enable, "enable");
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  __name(disable, "disable");
  function enabled(name14) {
    if (name14[name14.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name14)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name14)) {
        return true;
      }
    }
    return false;
  }
  __name(enabled, "enabled");
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  __name(toNamespace, "toNamespace");
  function coerce32(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  __name(coerce32, "coerce");
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  __name(destroy, "destroy");
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}
__name(setup, "setup");

// node_modules/weald/dist/src/browser.js
var storage = localstorage();
var colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
    return false;
  }
  return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
}
__name(useColors, "useColors");
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + dist_default(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = "color: " + this.color;
  args.splice(1, 0, c, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
__name(formatArgs, "formatArgs");
var log = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage?.setItem("debug", namespaces);
    } else {
      storage?.removeItem("debug");
    }
  } catch (error) {
  }
}
__name(save, "save");
function load() {
  let r;
  try {
    r = storage?.getItem("debug");
  } catch (error) {
  }
  if (!r && typeof process !== "undefined" && "env" in process) {
    r = process.env.DEBUG;
  }
  return r;
}
__name(load, "load");
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
__name(localstorage, "localstorage");
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
__name(setupFormatters, "setupFormatters");
var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

// node_modules/weald/dist/src/index.js
var src_default = browser_default;

// node_modules/blockstore-core/node_modules/@libp2p/logger/dist/src/index.js
src_default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc2.baseEncode(v);
};
src_default.formatters.t = (v) => {
  return v == null ? "undefined" : base322.baseEncode(v);
};
src_default.formatters.m = (v) => {
  return v == null ? "undefined" : base642.baseEncode(v);
};
src_default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger2(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger2, "createDisabledLogger");
function logger2(name14) {
  let trace = createDisabledLogger2(`${name14}:trace`);
  if (src_default.enabled(`${name14}:trace`) && src_default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = src_default(`${name14}:trace`);
  }
  return Object.assign(src_default(name14), {
    error: src_default(`${name14}:error`),
    trace
  });
}
__name(logger2, "logger");

// node_modules/it-drain/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable, "isAsyncIterable");
function drain(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
__name(drain, "drain");
var src_default2 = drain;

// node_modules/it-peekable/dist/src/index.js
function peekable(iterable) {
  const [iterator, symbol7] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol7]() {
      return this;
    }
  };
}
__name(peekable, "peekable");
var src_default3 = peekable;

// node_modules/it-filter/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable2, "isAsyncIterable");
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable2 = src_default3(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return /* @__PURE__ */ function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for await (const entry of peekable2) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const func = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable2) {
      if (func(entry, index++)) {
        yield entry;
      }
    }
  }();
}
__name(filter, "filter");
var src_default4 = filter;

// node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}
__name(pDefer, "pDefer");

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  static {
    __name(this, "FixedFIFO");
  }
  buffer;
  mask;
  top;
  btm;
  next;
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  static {
    __name(this, "FIFO");
  }
  size;
  hwm;
  head;
  tail;
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
var AbortError = class extends Error {
  static {
    __name(this, "AbortError");
  }
  type;
  code;
  constructor(message2, code16) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code16 ?? "ABORT_ERR";
  }
};
function pushable(options = {}) {
  const getNext = /* @__PURE__ */ __name((buffer3) => {
    const next = buffer3.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  }, "getNext");
  return _pushable(getNext, options);
}
__name(pushable, "pushable");
function pushableV(options = {}) {
  const getNext = /* @__PURE__ */ __name((buffer3) => {
    let next;
    const values = [];
    while (!buffer3.isEmpty()) {
      next = buffer3.shift();
      if (next == null) {
        break;
      }
      if (next.error != null) {
        throw next.error;
      }
      if (next.done === false) {
        values.push(next.value);
      }
    }
    if (next == null) {
      return { done: true };
    }
    return {
      done: next.done === true,
      value: values
    };
  }, "getNext");
  return _pushable(getNext, options);
}
__name(pushableV, "pushableV");
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer3 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain2 = pDefer();
  const waitNext = /* @__PURE__ */ __name(async () => {
    try {
      if (!buffer3.isEmpty()) {
        return getNext(buffer3);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = /* @__PURE__ */ __name((next) => {
          onNext = null;
          buffer3.push(next);
          try {
            resolve(getNext(buffer3));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        }, "onNext");
      });
    } finally {
      if (buffer3.isEmpty()) {
        queueMicrotask(() => {
          drain2.resolve();
          drain2 = pDefer();
        });
      }
    }
  }, "waitNext");
  const bufferNext = /* @__PURE__ */ __name((next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer3.push(next);
    return pushable2;
  }, "bufferNext");
  const bufferError = /* @__PURE__ */ __name((err) => {
    buffer3 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer3.push({ error: err });
    return pushable2;
  }, "bufferError");
  const push = /* @__PURE__ */ __name((value) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  }, "push");
  const end = /* @__PURE__ */ __name((err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  }, "end");
  const _return = /* @__PURE__ */ __name(() => {
    buffer3 = new FIFO();
    end();
    return { done: true };
  }, "_return");
  const _throw = /* @__PURE__ */ __name((err) => {
    end(err);
    return { done: true };
  }, "_throw");
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer3.size;
    },
    onEmpty: async (options2) => {
      const signal = options2?.signal;
      signal?.throwIfAborted();
      if (buffer3.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = /* @__PURE__ */ __name(() => {
            reject(new AbortError());
          }, "listener");
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain2.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal?.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}
__name(_pushable, "_pushable");

// node_modules/it-merge/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable3, "isAsyncIterable");
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable3(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return function* () {
      for (const source of syncSources) {
        yield* source;
      }
    }();
  }
  return async function* () {
    const output3 = pushable({
      objectMode: true
    });
    void Promise.resolve().then(async () => {
      try {
        await Promise.all(sources.map(async (source) => {
          for await (const item of source) {
            output3.push(item);
          }
        }));
        output3.end();
      } catch (err) {
        output3.end(err);
      }
    });
    yield* output3;
  }();
}
__name(merge, "merge");
var src_default5 = merge;

// node_modules/blockstore-core/dist/src/tiered.js
var log2 = logger2("blockstore:core:tiered");

// node_modules/blockstore-core/dist/src/index.js
var Errors = {
  ...errors_exports
};

// node_modules/datastore-core/dist/src/errors.js
var import_err_code2 = __toESM(require_err_code(), 1);
function notFoundError2(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code2.default)(err, "ERR_NOT_FOUND");
}
__name(notFoundError2, "notFoundError");

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bytes.js
var empty3 = new Uint8Array(0);
function equals4(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals4, "equals");
function coerce3(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce3, "coerce");
function fromString(str) {
  return new TextEncoder().encode(str);
}
__name(fromString, "fromString");
function toString(b) {
  return new TextDecoder().decode(b);
}
__name(toString, "toString");

// node_modules/interface-datastore/node_modules/multiformats/dist/src/vendor/base-x.js
function base3(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base3, "base");
var src3 = base3;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base.js
var Encoder3 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or3(left, right) {
  return new ComposedDecoder3({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or3, "or");
var Codec3 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name14, prefix, baseEncode);
    this.decoder = new Decoder3(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from3({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec3(name14, prefix, encode79, decode97);
}
__name(from3, "from");
function baseX3({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default3(alphabet11, name14);
  return from3({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce3(decode97(text))
  });
}
__name(baseX3, "baseX");
function decode6(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode6, "decode");
function encode4(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode4, "encode");
function rfc46483({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from3({
    prefix,
    name: name14,
    encode(input) {
      return encode4(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode6(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc46483, "rfc4648");

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base10.js
var base10 = baseX3({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc46483({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc46483({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc46483({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode5(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
__name(encode5, "encode");
function decode7(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode7, "decode");
var base256emoji = from3({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode5,
  decode: decode7
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base323,
  base32hex: () => base32hex3,
  base32hexpad: () => base32hexpad3,
  base32hexpadupper: () => base32hexpadupper3,
  base32hexupper: () => base32hexupper3,
  base32pad: () => base32pad3,
  base32padupper: () => base32padupper3,
  base32upper: () => base32upper3,
  base32z: () => base32z3
});
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX3({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX3({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc3,
  base58flickr: () => base58flickr3
});
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
var base643 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc46483({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from3({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString(buf3),
  decode: (str) => fromString(str)
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/vendor/varint.js
var encode_12 = encode6;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode6(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode6.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode6, "encode");
var decode8 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
__name(read2, "read");
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = /* @__PURE__ */ __name(function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
}, "length");
var varint2 = {
  encode: encode_12,
  decode: decode8,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/interface-datastore/node_modules/multiformats/dist/src/varint.js
function decode9(data, offset = 0) {
  const code16 = varint_default2.decode(data, offset);
  return [code16, varint_default2.decode.bytes];
}
__name(decode9, "decode");
function encodeTo2(int, target, offset = 0) {
  varint_default2.encode(int, target, offset);
  return target;
}
__name(encodeTo2, "encodeTo");
function encodingLength2(int) {
  return varint_default2.encodingLength(int);
}
__name(encodingLength2, "encodingLength");

// node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/digest.js
function create2(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength2(code16);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo2(code16, bytes3, 0);
  encodeTo2(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest2(code16, size, digest13, bytes3);
}
__name(create2, "create");
function decode10(multihash) {
  const bytes3 = coerce3(multihash);
  const [code16, sizeOffset] = decode9(bytes3);
  const [size, digestOffset] = decode9(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code16, size, digest13, bytes3);
}
__name(decode10, "decode");
function equals5(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals4(a.bytes, data.bytes);
  }
}
__name(equals5, "equals");
var Digest2 = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/identity.js
var code2 = 0;
var name = "identity";
var encode7 = coerce3;
function digest(input) {
  return create2(code2, encode7(input));
}
__name(digest, "digest");
var identity2 = { code: code2, name, encode: encode7, digest };

// node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/hasher.js
function from4({ name: name14, code: code16, encode: encode79 }) {
  return new Hasher(name14, code16, encode79);
}
__name(from4, "from");
var Hasher = class {
  static {
    __name(this, "Hasher");
  }
  name;
  code;
  encode;
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest13) => create2(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha(name14) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name14, data));
}
__name(sha, "sha");
var sha256 = from4({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from4({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/interface-datastore/node_modules/multiformats/dist/src/cid.js
function format2(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV02(bytes3, baseCache2(link), base42 ?? base58btc3.encoder);
    default:
      return toStringV12(bytes3, baseCache2(link), base42 ?? base323.encoder);
  }
}
__name(format2, "format");
var cache2 = /* @__PURE__ */ new WeakMap();
function baseCache2(cid) {
  const baseCache14 = cache2.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache2, "baseCache");
var CID2 = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create2(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals5(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format2(this, base42);
  }
  toJSON() {
    return { "/": format2(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID2(version4, code16, multihash.bytes));
    } else if (value[cidSymbol2] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode10(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID2(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE2, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode9(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE2;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes2(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes2(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base42 ?? base58btc3;
      return [base58btc3.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base42 ?? base323;
      return [base323.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes2, "parseCIDtoBytes");
function toStringV02(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV02, "toStringV0");
function toStringV12(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV12, "toStringV1");
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
function encodeCID2(version4, code16, multihash) {
  const codeOffset = encodingLength2(version4);
  const hashOffset = codeOffset + encodingLength2(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version4, bytes3, 0);
  encodeTo2(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID2, "encodeCID");
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/interface-datastore/node_modules/multiformats/dist/src/basics.js
var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports2 };

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe, "allocUnsafe");

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: {
      decode: decode97
    }
  };
}
__name(createCodec, "createCodec");
var string = createCodec("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf3) => {
  let string8 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string8 += String.fromCharCode(buf3[i]);
  }
  return string8;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/from-string.js
function fromString2(string8, encoding = "utf8") {
  const base42 = bases_default[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.decoder.decode(`${base42.prefix}${string8}`);
}
__name(fromString2, "fromString");

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base42 = bases_default[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.encoder.encode(array).substring(1);
}
__name(toString2, "toString");

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  static {
    __name(this, "Key");
  }
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean) {
    if (typeof s2 === "string") {
      this._buf = fromString2(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString2(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
__name(namespaceType, "namespaceType");
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
__name(namespaceValue, "namespaceValue");
function flatten(arr) {
  return [].concat(...arr);
}
__name(flatten, "flatten");

// node_modules/datastore-core/dist/src/shard.js
var SHARDING_FN = "SHARDING";

// node_modules/it-all/dist/src/index.js
function isAsyncIterable4(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable4, "isAsyncIterable");
function all(source) {
  if (isAsyncIterable4(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
__name(all, "all");
var src_default6 = all;

// node_modules/it-sort/dist/src/index.js
function isAsyncIterable5(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable5, "isAsyncIterable");
function sort(source, sorter) {
  if (isAsyncIterable5(source)) {
    return async function* () {
      const arr = await src_default6(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default6(source);
    yield* arr.sort(sorter);
  }();
}
__name(sort, "sort");
var src_default7 = sort;

// node_modules/it-take/dist/src/index.js
function isAsyncIterable6(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable6, "isAsyncIterable");
function take(source, limit) {
  if (isAsyncIterable6(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
__name(take, "take");
var src_default8 = take;

// node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  static {
    __name(this, "BaseDatastore");
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default2(this.putMany(puts, options));
        puts = [];
        await src_default2(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default4(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default4(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default7(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default4(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default8(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default4(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default4(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default7(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default4(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default8(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  static {
    __name(this, "MemoryDatastore");
  }
  data;
  constructor() {
    super();
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw notFoundError2();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key(key);
    }
  }
};

// node_modules/it-map/dist/src/index.js
function isAsyncIterable7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable7, "isAsyncIterable");
function map(source, func) {
  let index = 0;
  if (isAsyncIterable7(source)) {
    return async function* () {
      for await (const val of source) {
        yield func(val, index++);
      }
    }();
  }
  const peekable2 = src_default3(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return /* @__PURE__ */ function* () {
    }();
  }
  const res = func(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable2) {
        yield func(val, index++);
      }
    }();
  }
  const fn = func;
  return function* () {
    yield res;
    for (const val of peekable2) {
      yield fn(val, index++);
    }
  }();
}
__name(map, "map");
var src_default9 = map;

// node_modules/it-pipe/dist/src/index.js
function pipe(first2, ...rest) {
  if (first2 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first2)) {
    const duplex = first2;
    first2 = /* @__PURE__ */ __name(() => duplex.source, "first");
  } else if (isIterable(first2) || isAsyncIterable8(first2)) {
    const source = first2;
    first2 = /* @__PURE__ */ __name(() => source, "first");
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}
__name(pipe, "pipe");
var rawPipe = /* @__PURE__ */ __name((...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
}, "rawPipe");
var isAsyncIterable8 = /* @__PURE__ */ __name((obj) => {
  return obj?.[Symbol.asyncIterator] != null;
}, "isAsyncIterable");
var isIterable = /* @__PURE__ */ __name((obj) => {
  return obj?.[Symbol.iterator] != null;
}, "isIterable");
var isDuplex = /* @__PURE__ */ __name((obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
}, "isDuplex");
var duplexPipelineFn = /* @__PURE__ */ __name((duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable8(source2)) {
        sourceWrap = /* @__PURE__ */ __name(async function* () {
          yield* source2;
          stream.end();
        }, "sourceWrap");
      } else if (isIterable(source2)) {
        sourceWrap = /* @__PURE__ */ __name(function* () {
          yield* source2;
          stream.end();
        }, "sourceWrap");
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default5(stream, sourceWrap());
    }
    return duplex.source;
  };
}, "duplexPipelineFn");

// node_modules/datastore-core/dist/src/sharding.js
var shardKey = new Key(SHARDING_FN);

// node_modules/datastore-core/node_modules/multiformats/dist/src/bytes.js
var empty4 = new Uint8Array(0);
function coerce4(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce4, "coerce");

// node_modules/datastore-core/node_modules/multiformats/dist/src/vendor/base-x.js
function base4(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base4, "base");
var src4 = base4;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base.js
var Encoder4 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or4(left, right) {
  return new ComposedDecoder4({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or4, "or");
var Codec4 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name14, prefix, baseEncode);
    this.decoder = new Decoder4(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from5({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec4(name14, prefix, encode79, decode97);
}
__name(from5, "from");
function baseX4({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default4(alphabet11, name14);
  return from5({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce4(decode97(text))
  });
}
__name(baseX4, "baseX");
function decode11(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode11, "decode");
function encode8(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode8, "encode");
function rfc46484({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from5({
    prefix,
    name: name14,
    encode(input) {
      return encode8(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode11(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc46484, "rfc4648");

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base32.js
var base324 = rfc46484({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46484({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46484({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46484({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46484({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46484({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46484({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46484({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46484({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base58.js
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base64.js
var base644 = rfc46484({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad4 = rfc46484({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url4 = rfc46484({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad4 = rfc46484({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/datastore-core/node_modules/@libp2p/logger/dist/src/index.js
src_default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc4.baseEncode(v);
};
src_default.formatters.t = (v) => {
  return v == null ? "undefined" : base324.baseEncode(v);
};
src_default.formatters.m = (v) => {
  return v == null ? "undefined" : base644.baseEncode(v);
};
src_default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger3(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger3, "createDisabledLogger");
function logger3(name14) {
  let trace = createDisabledLogger3(`${name14}:trace`);
  if (src_default.enabled(`${name14}:trace`) && src_default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = src_default(`${name14}:trace`);
  }
  return Object.assign(src_default(name14), {
    error: src_default(`${name14}:error`),
    trace
  });
}
__name(logger3, "logger");

// node_modules/datastore-core/dist/src/tiered.js
var log3 = logger3("datastore:core:tiered");

// node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  __name(onAbort, "onAbort");
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  __name(clear, "clear");
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}
__name(anySignal, "anySignal");

// node_modules/it-foreach/dist/src/index.js
function isAsyncIterable9(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable9, "isAsyncIterable");
function isPromise(thing) {
  return thing?.then != null;
}
__name(isPromise, "isPromise");
function forEach(source, fn) {
  let index = 0;
  if (isAsyncIterable9(source)) {
    return async function* () {
      for await (const val of source) {
        const res2 = fn(val, index++);
        if (isPromise(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const peekable2 = src_default3(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return /* @__PURE__ */ function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res?.then === "function") {
    return async function* () {
      yield value;
      for await (const val of peekable2) {
        const res2 = fn(val, index++);
        if (isPromise(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const func = fn;
  return function* () {
    yield value;
    for (const val of peekable2) {
      func(val, index++);
      yield val;
    }
  }();
}
__name(forEach, "forEach");
var src_default10 = forEach;

// node_modules/helia/node_modules/multiformats/vendor/varint.js
var encode_13 = encode9;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode9(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode9.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode9, "encode");
var decode12 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
__name(read3, "read");
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = /* @__PURE__ */ __name(function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
}, "length");
var varint3 = {
  encode: encode_13,
  decode: decode12,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/helia/node_modules/multiformats/src/varint.js
var decode13 = /* @__PURE__ */ __name((data, offset = 0) => {
  const code16 = varint_default3.decode(data, offset);
  return [code16, varint_default3.decode.bytes];
}, "decode");
var encodeTo3 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default3.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength3 = /* @__PURE__ */ __name((int) => {
  return varint_default3.encodingLength(int);
}, "encodingLength");

// node_modules/helia/node_modules/multiformats/src/hashes/digest.js
var create3 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength3(code16);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo3(code16, bytes3, 0);
  encodeTo3(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest3(code16, size, digest13, bytes3);
}, "create");
var decode14 = /* @__PURE__ */ __name((multihash) => {
  const bytes3 = coerce(multihash);
  const [code16, sizeOffset] = decode13(bytes3);
  const [size, digestOffset] = decode13(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code16, size, digest13, bytes3);
}, "decode");
var equals6 = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
  }
}, "equals");
var Digest3 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/helia/node_modules/multiformats/src/cid.js
var format3 = /* @__PURE__ */ __name((link, base42) => {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV03(
        bytes3,
        baseCache3(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base42 || base58btc.encoder
      );
    default:
      return toStringV13(
        bytes3,
        baseCache3(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base42 || base32.encoder
      );
  }
}, "format");
var cache3 = /* @__PURE__ */ new WeakMap();
var baseCache3 = /* @__PURE__ */ __name((cid) => {
  const baseCache14 = cache3.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}, "baseCache");
var CID3 = class _CID {
  static {
    __name(this, "CID");
  }
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create3(code16, digest13);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals6(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base42) {
    return format3(this, base42);
  }
  toJSON() {
    return { "/": format3(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(
        version4,
        code16,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes3 || encodeCID3(version4, code16, multihash.bytes)
      );
    } else if (value[cidSymbol3] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode14(multihash)
      );
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE3) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`
          );
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID3(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE3, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(
      bytes3.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest13 = new Digest3(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest13
    ) : _CID.createV1(specs.codec, digest13);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode13(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE3
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes3(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes3 = /* @__PURE__ */ __name((source, base42) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base42 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base42 || base32;
      return [
        /** @type {Prefix} */
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base42 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base42.decode(source)
      ];
    }
  }
}, "parseCIDtoBytes");
var toStringV03 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV0");
var toStringV13 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV1");
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
var encodeCID3 = /* @__PURE__ */ __name((version4, code16, multihash) => {
  const codeOffset = encodingLength3(version4);
  const hashOffset = codeOffset + encodingLength3(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version4, bytes3, 0);
  encodeTo3(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}, "encodeCID");
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/tracked-map/dist/src/index.js
var TrackedMap = class extends Map {
  static {
    __name(this, "TrackedMap");
  }
  metric;
  constructor(init) {
    super();
    const { name: name14, metrics } = init;
    this.metric = metrics.registerMetric(name14);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name14, metrics } = config;
  let map3;
  if (metrics != null) {
    map3 = new TrackedMap({ name: name14, metrics });
  } else {
    map3 = /* @__PURE__ */ new Map();
  }
  return map3;
}
__name(trackedMap, "trackedMap");

// node_modules/@libp2p/interfaces/dist/src/errors.js
var AbortError2 = class _AbortError extends Error {
  static {
    __name(this, "AbortError");
  }
  code;
  type;
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.code = _AbortError.code;
    this.type = _AbortError.type;
  }
  static code = "ABORT_ERR";
  static type = "aborted";
};
var CodeError = class extends Error {
  static {
    __name(this, "CodeError");
  }
  code;
  props;
  constructor(message2, code16, props) {
    super(message2);
    this.code = code16;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};

// node_modules/helia/node_modules/multiformats/src/hashes/hasher.js
var from6 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher2(name14, code16, encode79), "from");
var Hasher2 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest13) => create3(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/helia/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha2562 = from6({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5122 = from6({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/message/index.js
var import_varint_decoder = __toESM(require_src(), 1);

// node_modules/uint8arrays/dist/src/equals.js
function equals7(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
__name(equals7, "equals");

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/wantlist/entry.js
var WantListEntry = class {
  static {
    __name(this, "WantListEntry");
  }
  _refCounter;
  cid;
  priority;
  wantType;
  constructor(cid, priority, wantType) {
    this._refCounter = 1;
    this.cid = cid;
    this.priority = priority ?? 1;
    this.wantType = wantType;
  }
  inc() {
    this._refCounter += 1;
  }
  dec() {
    this._refCounter = Math.max(0, this._refCounter - 1);
  }
  hasRefs() {
    return this._refCounter > 0;
  }
  // So that console.log prints a nice description of this object
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
  }
  equals(other) {
    return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/message/entry.js
var BitswapMessageEntry = class {
  static {
    __name(this, "BitswapMessageEntry");
  }
  entry;
  cancel;
  sendDontHave;
  constructor(cid, priority, wantType, cancel, sendDontHave) {
    this.entry = new WantListEntry(cid, priority, wantType);
    this.cancel = Boolean(cancel);
    this.sendDontHave = Boolean(sendDontHave);
  }
  get cid() {
    return this.entry.cid;
  }
  set cid(cid) {
    this.entry.cid = cid;
  }
  get priority() {
    return this.entry.priority;
  }
  set priority(val) {
    this.entry.priority = val;
  }
  get wantType() {
    return this.entry.wantType;
  }
  set wantType(val) {
    this.entry.wantType = val;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
  }
  equals(other) {
    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/utils/index.js
var logger4 = /* @__PURE__ */ __name((id, subsystem) => {
  const name14 = ["bitswap"];
  if (subsystem != null) {
    name14.push(subsystem);
  }
  if (id != null) {
    name14.push(`${id.toString().slice(0, 8)}`);
  }
  return logger(name14.join(":"));
}, "logger");
var isMapEqual = /* @__PURE__ */ __name((a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, valueA] of a) {
    const valueB = b.get(key);
    if (valueB === void 0) {
      return false;
    }
    if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals7(valueA, valueB)) {
      return false;
    }
    if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
      return false;
    }
  }
  return true;
}, "isMapEqual");

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js
var varint4 = __toESM(require_varint2(), 1);
function varintEncoder(buf3) {
  let out = new Uint8Array(buf3.reduce((acc, curr) => {
    return acc + varint4.default.encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf3) {
    out = varint4.encode(num, out, offset);
    offset += varint4.default.encodingLength(num);
  }
  return out;
}
__name(varintEncoder, "varintEncoder");
var varint_encoder_default = varintEncoder;

// node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe2(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe2, "allocUnsafe");

// node_modules/uint8-varint/dist/src/index.js
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var MSB4 = 128;
var REST4 = 127;
function encodingLength4(value) {
  if (value < N14) {
    return 1;
  }
  if (value < N24) {
    return 2;
  }
  if (value < N34) {
    return 3;
  }
  if (value < N44) {
    return 4;
  }
  if (value < N54) {
    return 5;
  }
  if (value < N64) {
    return 6;
  }
  if (value < N74) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
__name(encodingLength4, "encodingLength");
function encodeUint8Array(value, buf3, offset = 0) {
  switch (encodingLength4(value)) {
    case 8: {
      buf3[offset++] = value & 255 | MSB4;
      value /= 128;
    }
    case 7: {
      buf3[offset++] = value & 255 | MSB4;
      value /= 128;
    }
    case 6: {
      buf3[offset++] = value & 255 | MSB4;
      value /= 128;
    }
    case 5: {
      buf3[offset++] = value & 255 | MSB4;
      value /= 128;
    }
    case 4: {
      buf3[offset++] = value & 255 | MSB4;
      value >>>= 7;
    }
    case 3: {
      buf3[offset++] = value & 255 | MSB4;
      value >>>= 7;
    }
    case 2: {
      buf3[offset++] = value & 255 | MSB4;
      value >>>= 7;
    }
    case 1: {
      buf3[offset++] = value & 255;
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf3;
}
__name(encodeUint8Array, "encodeUint8Array");
function encodeUint8ArrayList(value, buf3, offset = 0) {
  switch (encodingLength4(value)) {
    case 8: {
      buf3.set(offset++, value & 255 | MSB4);
      value /= 128;
    }
    case 7: {
      buf3.set(offset++, value & 255 | MSB4);
      value /= 128;
    }
    case 6: {
      buf3.set(offset++, value & 255 | MSB4);
      value /= 128;
    }
    case 5: {
      buf3.set(offset++, value & 255 | MSB4);
      value /= 128;
    }
    case 4: {
      buf3.set(offset++, value & 255 | MSB4);
      value >>>= 7;
    }
    case 3: {
      buf3.set(offset++, value & 255 | MSB4);
      value >>>= 7;
    }
    case 2: {
      buf3.set(offset++, value & 255 | MSB4);
      value >>>= 7;
    }
    case 1: {
      buf3.set(offset++, value & 255);
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf3;
}
__name(encodeUint8ArrayList, "encodeUint8ArrayList");
function decodeUint8Array(buf3, offset) {
  let b = buf3[offset];
  let res = 0;
  res += b & REST4;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 1];
  res += (b & REST4) << 7;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 2];
  res += (b & REST4) << 14;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 3];
  res += (b & REST4) << 21;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 4];
  res += (b & REST4) * N44;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 5];
  res += (b & REST4) * N54;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 6];
  res += (b & REST4) * N64;
  if (b < MSB4) {
    return res;
  }
  b = buf3[offset + 7];
  res += (b & REST4) * N74;
  if (b < MSB4) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
__name(decodeUint8Array, "decodeUint8Array");
function decodeUint8ArrayList(buf3, offset) {
  let b = buf3.get(offset);
  let res = 0;
  res += b & REST4;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 1);
  res += (b & REST4) << 7;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 2);
  res += (b & REST4) << 14;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 3);
  res += (b & REST4) << 21;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 4);
  res += (b & REST4) * N44;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 5);
  res += (b & REST4) * N54;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 6);
  res += (b & REST4) * N64;
  if (b < MSB4) {
    return res;
  }
  b = buf3.get(offset + 7);
  res += (b & REST4) * N74;
  if (b < MSB4) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
__name(decodeUint8ArrayList, "decodeUint8ArrayList");
function encode11(value, buf3, offset = 0) {
  if (buf3 == null) {
    buf3 = allocUnsafe2(encodingLength4(value));
  }
  if (buf3 instanceof Uint8Array) {
    return encodeUint8Array(value, buf3, offset);
  } else {
    return encodeUint8ArrayList(value, buf3, offset);
  }
}
__name(encode11, "encode");
function decode15(buf3, offset = 0) {
  if (buf3 instanceof Uint8Array) {
    return decodeUint8Array(buf3, offset);
  } else {
    return decodeUint8ArrayList(buf3, offset);
  }
}
__name(decode15, "decode");

// node_modules/protons-runtime/dist/src/utils/float.js
var f32 = new Float32Array([-0]);
var f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf3, pos) {
  f32[0] = val;
  buf3[pos] = f8b[0];
  buf3[pos + 1] = f8b[1];
  buf3[pos + 2] = f8b[2];
  buf3[pos + 3] = f8b[3];
}
__name(writeFloatLE, "writeFloatLE");
function readFloatLE(buf3, pos) {
  f8b[0] = buf3[pos];
  f8b[1] = buf3[pos + 1];
  f8b[2] = buf3[pos + 2];
  f8b[3] = buf3[pos + 3];
  return f32[0];
}
__name(readFloatLE, "readFloatLE");
var f64 = new Float64Array([-0]);
var d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf3, pos) {
  f64[0] = val;
  buf3[pos] = d8b[0];
  buf3[pos + 1] = d8b[1];
  buf3[pos + 2] = d8b[2];
  buf3[pos + 3] = d8b[3];
  buf3[pos + 4] = d8b[4];
  buf3[pos + 5] = d8b[5];
  buf3[pos + 6] = d8b[6];
  buf3[pos + 7] = d8b[7];
}
__name(writeDoubleLE, "writeDoubleLE");
function readDoubleLE(buf3, pos) {
  d8b[0] = buf3[pos];
  d8b[1] = buf3[pos + 1];
  d8b[2] = buf3[pos + 2];
  d8b[3] = buf3[pos + 3];
  d8b[4] = buf3[pos + 4];
  d8b[5] = buf3[pos + 5];
  d8b[6] = buf3[pos + 6];
  d8b[7] = buf3[pos + 7];
  return f64[0];
}
__name(readDoubleLE, "readDoubleLE");

// node_modules/protons-runtime/dist/src/utils/longbits.js
var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
var LongBits = class _LongBits {
  static {
    __name(this, "LongBits");
  }
  lo;
  hi;
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Converts this long bits to a possibly unsafe JavaScript number
   */
  toNumber(unsigned3 = false) {
    if (!unsigned3 && this.hi >>> 31 > 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }
  /**
   * Converts this long bits to a bigint
   */
  toBigInt(unsigned3 = false) {
    if (unsigned3) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Converts this long bits to a string
   */
  toString(unsigned3 = false) {
    return this.toBigInt(unsigned3).toString();
  }
  /**
   * Zig-zag encodes this long bits
   */
  zzEncode() {
    const mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Zig-zag decodes this long bits
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Calculates the length of this longbits when encoded as a varint.
   */
  length() {
    const part0 = this.lo;
    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
    const part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromBigInt(value) {
    if (value === 0n) {
      return zero;
    }
    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
      return this.fromNumber(Number(value));
    }
    const negative = value < 0n;
    if (negative) {
      value = -value;
    }
    let hi = value >> 32n;
    let lo = value - (hi << 32n);
    if (negative) {
      hi = ~hi | 0n;
      lo = ~lo | 0n;
      if (++lo > TWO_32) {
        lo = 0n;
        if (++hi > TWO_32) {
          hi = 0n;
        }
      }
    }
    return new _LongBits(Number(lo), Number(hi));
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromNumber(value) {
    if (value === 0) {
      return zero;
    }
    const sign4 = value < 0;
    if (sign4) {
      value = -value;
    }
    let lo = value >>> 0;
    let hi = (value - lo) / 4294967296 >>> 0;
    if (sign4) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new _LongBits(lo, hi);
  }
  /**
   * Constructs new long bits from a number, long or string
   */
  static from(value) {
    if (typeof value === "number") {
      return _LongBits.fromNumber(value);
    }
    if (typeof value === "bigint") {
      return _LongBits.fromBigInt(value);
    }
    if (typeof value === "string") {
      return _LongBits.fromBigInt(BigInt(value));
    }
    return value.low != null || value.high != null ? new _LongBits(value.low >>> 0, value.high >>> 0) : zero;
  }
};
var zero = new LongBits(0, 0);
zero.toBigInt = function() {
  return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var TWO_32 = 4294967296n;

// node_modules/protons-runtime/dist/src/utils/utf8.js
function length4(string8) {
  let len = 0;
  let c = 0;
  for (let i = 0; i < string8.length; ++i) {
    c = string8.charCodeAt(i);
    if (c < 128) {
      len += 1;
    } else if (c < 2048) {
      len += 2;
    } else if ((c & 64512) === 55296 && (string8.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else {
      len += 3;
    }
  }
  return len;
}
__name(length4, "length");
function read4(buffer3, start, end) {
  const len = end - start;
  if (len < 1) {
    return "";
  }
  let parts;
  const chunk = [];
  let i = 0;
  let t;
  while (start < end) {
    t = buffer3[start++];
    if (t < 128) {
      chunk[i++] = t;
    } else if (t > 191 && t < 224) {
      chunk[i++] = (t & 31) << 6 | buffer3[start++] & 63;
    } else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (buffer3[start++] & 63) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63) - 65536;
      chunk[i++] = 55296 + (t >> 10);
      chunk[i++] = 56320 + (t & 1023);
    } else {
      chunk[i++] = (t & 15) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63;
    }
    if (i > 8191) {
      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (parts != null) {
    if (i > 0) {
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    }
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}
__name(read4, "read");
function write(string8, buffer3, offset) {
  const start = offset;
  let c1;
  let c2;
  for (let i = 0; i < string8.length; ++i) {
    c1 = string8.charCodeAt(i);
    if (c1 < 128) {
      buffer3[offset++] = c1;
    } else if (c1 < 2048) {
      buffer3[offset++] = c1 >> 6 | 192;
      buffer3[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string8.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer3[offset++] = c1 >> 18 | 240;
      buffer3[offset++] = c1 >> 12 & 63 | 128;
      buffer3[offset++] = c1 >> 6 & 63 | 128;
      buffer3[offset++] = c1 & 63 | 128;
    } else {
      buffer3[offset++] = c1 >> 12 | 224;
      buffer3[offset++] = c1 >> 6 & 63 | 128;
      buffer3[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start;
}
__name(write, "write");

// node_modules/protons-runtime/dist/src/utils/reader.js
function indexOutOfRange(reader2, writeLength) {
  return RangeError(`index out of range: ${reader2.pos} + ${writeLength ?? 1} > ${reader2.len}`);
}
__name(indexOutOfRange, "indexOutOfRange");
function readFixed32End(buf3, end) {
  return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
}
__name(readFixed32End, "readFixed32End");
var Uint8ArrayReader = class {
  static {
    __name(this, "Uint8ArrayReader");
  }
  buf;
  pos;
  len;
  _slice = Uint8Array.prototype.subarray;
  constructor(buffer3) {
    this.buf = buffer3;
    this.pos = 0;
    this.len = buffer3.length;
  }
  /**
   * Reads a varint as an unsigned 32 bit value
   */
  uint32() {
    let value = 4294967295;
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  }
  /**
   * Reads a varint as a signed 32 bit value
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value
   */
  sint32() {
    const value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  }
  /**
   * Reads a varint as a boolean
   */
  bool() {
    return this.uint32() !== 0;
  }
  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer
   */
  fixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4);
    return res;
  }
  /**
   * Reads fixed 32 bits as a signed 32 bit integer
   */
  sfixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4) | 0;
    return res;
  }
  /**
   * Reads a float (32 bit) as a number
   */
  float() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  }
  /**
   * Reads a double (64 bit float) as a number
   */
  double() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  }
  /**
   * Reads a sequence of bytes preceded by its length as a varint
   */
  bytes() {
    const length21 = this.uint32();
    const start = this.pos;
    const end = this.pos + length21;
    if (end > this.len) {
      throw indexOutOfRange(this, length21);
    }
    this.pos += length21;
    return start === end ? new Uint8Array(0) : this.buf.subarray(start, end);
  }
  /**
   * Reads a string preceded by its byte length as a varint
   */
  string() {
    const bytes3 = this.bytes();
    return read4(bytes3, 0, bytes3.length);
  }
  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint
   */
  skip(length21) {
    if (typeof length21 === "number") {
      if (this.pos + length21 > this.len) {
        throw indexOutOfRange(this, length21);
      }
      this.pos += length21;
    } else {
      do {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
      } while ((this.buf[this.pos++] & 128) !== 0);
    }
    return this;
  }
  /**
   * Skips the next element of the specified wire type
   */
  skipType(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
    }
    return this;
  }
  readLongVarint() {
    const bits3 = new LongBits(0, 0);
    let i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits3.lo = (bits3.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits3;
        }
      }
      bits3.lo = (bits3.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits3.hi = (bits3.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return bits3;
      }
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits3.lo = (bits3.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits3;
        }
      }
      bits3.lo = (bits3.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits3;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits3.hi = (bits3.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits3;
        }
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits3.hi = (bits3.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits3;
        }
      }
    }
    throw Error("invalid varint encoding");
  }
  readFixed64() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 8);
    }
    const lo = readFixed32End(this.buf, this.pos += 4);
    const hi = readFixed32End(this.buf, this.pos += 4);
    return new LongBits(lo, hi);
  }
  /**
   * Reads a varint as a signed 64 bit value
   */
  int64() {
    return this.readLongVarint().toBigInt();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  int64Number() {
    return this.readLongVarint().toNumber();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a string
   */
  int64String() {
    return this.readLongVarint().toString();
  }
  /**
   * Reads a varint as an unsigned 64 bit value
   */
  uint64() {
    return this.readLongVarint().toBigInt(true);
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  uint64Number() {
    const value = decodeUint8Array(this.buf, this.pos);
    this.pos += encodingLength4(value);
    return value;
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a string
   */
  uint64String() {
    return this.readLongVarint().toString(true);
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value
   */
  sint64() {
    return this.readLongVarint().zzDecode().toBigInt();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * possibly unsafe JavaScript number
   */
  sint64Number() {
    return this.readLongVarint().zzDecode().toNumber();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * string
   */
  sint64String() {
    return this.readLongVarint().zzDecode().toString();
  }
  /**
   * Reads fixed 64 bits
   */
  fixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
   */
  fixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads fixed 64 bits returned as a string
   */
  fixed64String() {
    return this.readFixed64().toString();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits
   */
  sfixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
   * JavaScript number
   */
  sfixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a string
   */
  sfixed64String() {
    return this.readFixed64().toString();
  }
};
function createReader(buf3) {
  return new Uint8ArrayReader(buf3 instanceof Uint8Array ? buf3 : buf3.subarray());
}
__name(createReader, "createReader");

// node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf3, codec, opts) {
  const reader2 = createReader(buf3);
  return codec.decode(reader2, void 0, opts);
}
__name(decodeMessage, "decodeMessage");

// node_modules/protons-runtime/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe3(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe3, "allocUnsafe");

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bytes.js
var empty5 = new Uint8Array(0);
function equals8(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals8, "equals");
function coerce5(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce5, "coerce");
function fromString3(str) {
  return new TextEncoder().encode(str);
}
__name(fromString3, "fromString");
function toString3(b) {
  return new TextDecoder().decode(b);
}
__name(toString3, "toString");

// node_modules/protons-runtime/node_modules/multiformats/dist/src/vendor/base-x.js
function base5(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base5, "base");
var src5 = base5;
var _brrp__multiformats_scope_baseX5 = src5;
var base_x_default5 = _brrp__multiformats_scope_baseX5;

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base.js
var Encoder5 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or5(this, decoder);
  }
};
var ComposedDecoder5 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or5(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or5(left, right) {
  return new ComposedDecoder5({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or5, "or");
var Codec5 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name14, prefix, baseEncode);
    this.decoder = new Decoder5(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from7({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec5(name14, prefix, encode79, decode97);
}
__name(from7, "from");
function baseX5({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default5(alphabet11, name14);
  return from7({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce5(decode97(text))
  });
}
__name(baseX5, "baseX");
function decode16(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode16, "decode");
function encode12(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode12, "encode");
function rfc46485({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from7({
    prefix,
    name: name14,
    encode(input) {
      return encode12(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode16(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc46485, "rfc4648");

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base10.js
var base102 = baseX5({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc46485({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46485({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base23
});
var base23 = rfc46485({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode13(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
__name(encode13, "encode");
function decode17(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode17, "decode");
var base256emoji2 = from7({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode13,
  decode: decode17
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base325,
  base32hex: () => base32hex5,
  base32hexpad: () => base32hexpad5,
  base32hexpadupper: () => base32hexpadupper5,
  base32hexupper: () => base32hexupper5,
  base32pad: () => base32pad5,
  base32padupper: () => base32padupper5,
  base32upper: () => base32upper5,
  base32z: () => base32z5
});
var base325 = rfc46485({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper5 = rfc46485({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad5 = rfc46485({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper5 = rfc46485({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex5 = rfc46485({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper5 = rfc46485({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad5 = rfc46485({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper5 = rfc46485({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z5 = rfc46485({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362 = baseX5({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX5({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc5,
  base58flickr: () => base58flickr5
});
var base58btc5 = baseX5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr5 = baseX5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base645,
  base64pad: () => base64pad5,
  base64url: () => base64url5,
  base64urlpad: () => base64urlpad5
});
var base645 = rfc46485({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad5 = rfc46485({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url5 = rfc46485({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad5 = rfc46485({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc46485({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var identity3 = from7({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString3(buf3),
  decode: (str) => fromString3(str)
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/vendor/varint.js
var encode_14 = encode14;
var MSB5 = 128;
var REST5 = 127;
var MSBALL4 = ~REST5;
var INT4 = Math.pow(2, 31);
function encode14(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode14.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode14, "encode");
var decode18 = read5;
var MSB$14 = 128;
var REST$14 = 127;
function read5(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read5.bytes = counter - offset;
  return res;
}
__name(read5, "read");
var N15 = Math.pow(2, 7);
var N25 = Math.pow(2, 14);
var N35 = Math.pow(2, 21);
var N45 = Math.pow(2, 28);
var N55 = Math.pow(2, 35);
var N65 = Math.pow(2, 42);
var N75 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length5 = /* @__PURE__ */ __name(function(value) {
  return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
}, "length");
var varint5 = {
  encode: encode_14,
  decode: decode18,
  encodingLength: length5
};
var _brrp_varint4 = varint5;
var varint_default4 = _brrp_varint4;

// node_modules/protons-runtime/node_modules/multiformats/dist/src/varint.js
function decode19(data, offset = 0) {
  const code16 = varint_default4.decode(data, offset);
  return [code16, varint_default4.decode.bytes];
}
__name(decode19, "decode");
function encodeTo4(int, target, offset = 0) {
  varint_default4.encode(int, target, offset);
  return target;
}
__name(encodeTo4, "encodeTo");
function encodingLength5(int) {
  return varint_default4.encodingLength(int);
}
__name(encodingLength5, "encodingLength");

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/digest.js
function create4(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength5(code16);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo4(code16, bytes3, 0);
  encodeTo4(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest4(code16, size, digest13, bytes3);
}
__name(create4, "create");
function decode20(multihash) {
  const bytes3 = coerce5(multihash);
  const [code16, sizeOffset] = decode19(bytes3);
  const [size, digestOffset] = decode19(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code16, size, digest13, bytes3);
}
__name(decode20, "decode");
function equals9(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals8(a.bytes, data.bytes);
  }
}
__name(equals9, "equals");
var Digest4 = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/identity.js
var code3 = 0;
var name2 = "identity";
var encode15 = coerce5;
function digest2(input) {
  return create4(code3, encode15(input));
}
__name(digest2, "digest");
var identity4 = { code: code3, name: name2, encode: encode15, digest: digest2 };

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2563,
  sha512: () => sha5123
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/hasher.js
function from8({ name: name14, code: code16, encode: encode79 }) {
  return new Hasher3(name14, code16, encode79);
}
__name(from8, "from");
var Hasher3 = class {
  static {
    __name(this, "Hasher");
  }
  name;
  code;
  encode;
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest13) => create4(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha3(name14) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name14, data));
}
__name(sha3, "sha");
var sha2563 = from8({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5123 = from8({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/cid.js
function format4(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV04(bytes3, baseCache4(link), base42 ?? base58btc5.encoder);
    default:
      return toStringV14(bytes3, baseCache4(link), base42 ?? base325.encoder);
  }
}
__name(format4, "format");
var cache4 = /* @__PURE__ */ new WeakMap();
function baseCache4(cid) {
  const baseCache14 = cache4.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache4.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache4, "baseCache");
var CID4 = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create4(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals9(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format4(this, base42);
  }
  toJSON() {
    return { "/": format4(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID4(version4, code16, multihash.bytes));
    } else if (value[cidSymbol4] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode20(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE4) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID4(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE4, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce5(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode19(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE4;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes4(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache4(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes4(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc5;
      return [
        base58btc5.prefix,
        decoder.decode(`${base58btc5.prefix}${source}`)
      ];
    }
    case base58btc5.prefix: {
      const decoder = base42 ?? base58btc5;
      return [base58btc5.prefix, decoder.decode(source)];
    }
    case base325.prefix: {
      const decoder = base42 ?? base325;
      return [base325.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes4, "parseCIDtoBytes");
function toStringV04(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc5.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV04, "toStringV0");
function toStringV14(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV14, "toStringV1");
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
function encodeCID4(version4, code16, multihash) {
  const codeOffset = encodingLength5(version4);
  const hashOffset = codeOffset + encodingLength5(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version4, bytes3, 0);
  encodeTo4(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID4, "encodeCID");
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

// node_modules/protons-runtime/node_modules/multiformats/dist/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/protons-runtime/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: {
      decode: decode97
    }
  };
}
__name(createCodec2, "createCodec");
var string2 = createCodec2("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf3) => {
  let string8 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string8 += String.fromCharCode(buf3[i]);
  }
  return string8;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe3(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases2.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases2
};
var bases_default2 = BASES2;

// node_modules/protons-runtime/node_modules/uint8arrays/dist/src/from-string.js
function fromString4(string8, encoding = "utf8") {
  const base42 = bases_default2[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.decoder.decode(`${base42.prefix}${string8}`);
}
__name(fromString4, "fromString");

// node_modules/protons-runtime/dist/src/utils/pool.js
function pool(size) {
  const SIZE = size ?? 8192;
  const MAX = SIZE >>> 1;
  let slab;
  let offset = SIZE;
  return /* @__PURE__ */ __name(function poolAlloc(size2) {
    if (size2 < 1 || size2 > MAX) {
      return allocUnsafe3(size2);
    }
    if (offset + size2 > SIZE) {
      slab = allocUnsafe3(SIZE);
      offset = 0;
    }
    const buf3 = slab.subarray(offset, offset += size2);
    if ((offset & 7) !== 0) {
      offset = (offset | 7) + 1;
    }
    return buf3;
  }, "poolAlloc");
}
__name(pool, "pool");

// node_modules/protons-runtime/dist/src/utils/writer.js
var Op = class {
  static {
    __name(this, "Op");
  }
  /**
   * Function to call
   */
  fn;
  /**
   * Value byte length
   */
  len;
  /**
   * Next operation
   */
  next;
  /**
   * Value to write
   */
  val;
  constructor(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
};
function noop() {
}
__name(noop, "noop");
var State = class {
  static {
    __name(this, "State");
  }
  /**
   * Current head
   */
  head;
  /**
   * Current tail
   */
  tail;
  /**
   * Current buffer length
   */
  len;
  /**
   * Next state
   */
  next;
  constructor(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
};
var bufferPool = pool();
function alloc(size) {
  if (globalThis.Buffer != null) {
    return allocUnsafe3(size);
  }
  return bufferPool(size);
}
__name(alloc, "alloc");
var Uint8ArrayWriter = class {
  static {
    __name(this, "Uint8ArrayWriter");
  }
  /**
   * Current length
   */
  len;
  /**
   * Operations head
   */
  head;
  /**
   * Operations tail
   */
  tail;
  /**
   * Linked forked states
   */
  states;
  constructor() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  /**
   * Pushes a new operation to the queue
   */
  _push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  }
  /**
   * Writes an unsigned 32 bit value as a varint
   */
  uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  }
  /**
   * Writes a signed 32 bit value as a varint`
   */
  int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  }
  /**
   * Writes a 32 bit value as a varint, zig-zag encoded
   */
  sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64(value) {
    const bits3 = LongBits.fromBigInt(value);
    return this._push(writeVarint64, bits3.length(), bits3);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64Number(value) {
    return this._push(encodeUint8Array, encodingLength4(value), value);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64String(value) {
    return this.uint64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64(value) {
    return this.uint64(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64Number(value) {
    return this.uint64Number(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64String(value) {
    return this.uint64String(value);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64(value) {
    const bits3 = LongBits.fromBigInt(value).zzEncode();
    return this._push(writeVarint64, bits3.length(), bits3);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64Number(value) {
    const bits3 = LongBits.fromNumber(value).zzEncode();
    return this._push(writeVarint64, bits3.length(), bits3);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64String(value) {
    return this.sint64(BigInt(value));
  }
  /**
   * Writes a boolish value as a varint
   */
  bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  }
  /**
   * Writes an unsigned 32 bit value as fixed 32 bits
   */
  fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  }
  /**
   * Writes a signed 32 bit value as fixed 32 bits
   */
  sfixed32(value) {
    return this.fixed32(value);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64(value) {
    const bits3 = LongBits.fromBigInt(value);
    return this._push(writeFixed32, 4, bits3.lo)._push(writeFixed32, 4, bits3.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64Number(value) {
    const bits3 = LongBits.fromNumber(value);
    return this._push(writeFixed32, 4, bits3.lo)._push(writeFixed32, 4, bits3.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64String(value) {
    return this.fixed64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64(value) {
    return this.fixed64(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64Number(value) {
    return this.fixed64Number(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64String(value) {
    return this.fixed64String(value);
  }
  /**
   * Writes a float (32 bit)
   */
  float(value) {
    return this._push(writeFloatLE, 4, value);
  }
  /**
   * Writes a double (64 bit float).
   *
   * @function
   * @param {number} value - Value to write
   * @returns {Writer} `this`
   */
  double(value) {
    return this._push(writeDoubleLE, 8, value);
  }
  /**
   * Writes a sequence of bytes
   */
  bytes(value) {
    const len = value.length >>> 0;
    if (len === 0) {
      return this._push(writeByte, 1, 0);
    }
    return this.uint32(len)._push(writeBytes, len, value);
  }
  /**
   * Writes a string
   */
  string(value) {
    const len = length4(value);
    return len !== 0 ? this.uint32(len)._push(write, len, value) : this._push(writeByte, 1, 0);
  }
  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   */
  fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  }
  /**
   * Resets this instance to the last state
   */
  reset() {
    if (this.states != null) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  }
  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   */
  ldelim() {
    const head = this.head;
    const tail = this.tail;
    const len = this.len;
    this.reset().uint32(len);
    if (len !== 0) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  }
  /**
   * Finishes the write operation
   */
  finish() {
    let head = this.head.next;
    const buf3 = alloc(this.len);
    let pos = 0;
    while (head != null) {
      head.fn(head.val, buf3, pos);
      pos += head.len;
      head = head.next;
    }
    return buf3;
  }
};
function writeByte(val, buf3, pos) {
  buf3[pos] = val & 255;
}
__name(writeByte, "writeByte");
function writeVarint32(val, buf3, pos) {
  while (val > 127) {
    buf3[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf3[pos] = val;
}
__name(writeVarint32, "writeVarint32");
var VarintOp = class extends Op {
  static {
    __name(this, "VarintOp");
  }
  next;
  constructor(len, val) {
    super(writeVarint32, len, val);
    this.next = void 0;
  }
};
function writeVarint64(val, buf3, pos) {
  while (val.hi !== 0) {
    buf3[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf3[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf3[pos++] = val.lo;
}
__name(writeVarint64, "writeVarint64");
function writeFixed32(val, buf3, pos) {
  buf3[pos] = val & 255;
  buf3[pos + 1] = val >>> 8 & 255;
  buf3[pos + 2] = val >>> 16 & 255;
  buf3[pos + 3] = val >>> 24;
}
__name(writeFixed32, "writeFixed32");
function writeBytes(val, buf3, pos) {
  buf3.set(val, pos);
}
__name(writeBytes, "writeBytes");
if (globalThis.Buffer != null) {
  Uint8ArrayWriter.prototype.bytes = function(value) {
    const len = value.length >>> 0;
    this.uint32(len);
    if (len > 0) {
      this._push(writeBytesBuffer, len, value);
    }
    return this;
  };
  Uint8ArrayWriter.prototype.string = function(value) {
    const len = globalThis.Buffer.byteLength(value);
    this.uint32(len);
    if (len > 0) {
      this._push(writeStringBuffer, len, value);
    }
    return this;
  };
}
function writeBytesBuffer(val, buf3, pos) {
  buf3.set(val, pos);
}
__name(writeBytesBuffer, "writeBytesBuffer");
function writeStringBuffer(val, buf3, pos) {
  if (val.length < 40) {
    write(val, buf3, pos);
  } else if (buf3.utf8Write != null) {
    buf3.utf8Write(val, pos);
  } else {
    buf3.set(fromString4(val), pos);
  }
}
__name(writeStringBuffer, "writeStringBuffer");
function createWriter() {
  return new Uint8ArrayWriter();
}
__name(createWriter, "createWriter");

// node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w2 = createWriter();
  codec.encode(message2, w2, {
    lengthDelimited: false
  });
  return w2.finish();
}
__name(encodeMessage, "encodeMessage");

// node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec3(name14, type, encode79, decode97) {
  return {
    name: name14,
    type,
    encode: encode79,
    decode: decode97
  };
}
__name(createCodec3, "createCodec");

// node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  __name(findValue, "findValue");
  const encode79 = /* @__PURE__ */ __name(function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  }, "enumEncode");
  const decode97 = /* @__PURE__ */ __name(function enumDecode(reader2) {
    const val = reader2.int32();
    return findValue(val);
  }, "enumDecode");
  return createCodec3("enum", CODEC_TYPES.VARINT, encode79, decode97);
}
__name(enumeration, "enumeration");

// node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode79, decode97) {
  return createCodec3("message", CODEC_TYPES.LENGTH_DELIMITED, encode79, decode97);
}
__name(message, "message");

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/message/message.js
var Message;
(function(Message7) {
  let Wantlist2;
  (function(Wantlist3) {
    let WantType3;
    (function(WantType4) {
      WantType4["Block"] = "Block";
      WantType4["Have"] = "Have";
    })(WantType3 = Wantlist3.WantType || (Wantlist3.WantType = {}));
    let __WantTypeValues;
    (function(__WantTypeValues2) {
      __WantTypeValues2[__WantTypeValues2["Block"] = 0] = "Block";
      __WantTypeValues2[__WantTypeValues2["Have"] = 1] = "Have";
    })(__WantTypeValues || (__WantTypeValues = {}));
    (function(WantType4) {
      WantType4.codec = () => {
        return enumeration(__WantTypeValues);
      };
    })(WantType3 = Wantlist3.WantType || (Wantlist3.WantType = {}));
    let Entry;
    (function(Entry2) {
      let _codec3;
      Entry2.codec = () => {
        if (_codec3 == null) {
          _codec3 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.block != null && obj.block.byteLength > 0) {
              w2.uint32(10);
              w2.bytes(obj.block);
            }
            if (obj.priority != null && obj.priority !== 0) {
              w2.uint32(16);
              w2.int32(obj.priority);
            }
            if (obj.cancel != null && obj.cancel !== false) {
              w2.uint32(24);
              w2.bool(obj.cancel);
            }
            if (obj.wantType != null && __WantTypeValues[obj.wantType] !== 0) {
              w2.uint32(32);
              Message7.Wantlist.WantType.codec().encode(obj.wantType, w2);
            }
            if (obj.sendDontHave != null && obj.sendDontHave !== false) {
              w2.uint32(40);
              w2.bool(obj.sendDontHave);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader2, length21) => {
            const obj = {
              block: new Uint8Array(0),
              priority: 0,
              cancel: false,
              wantType: WantType3.Block,
              sendDontHave: false
            };
            const end = length21 == null ? reader2.len : reader2.pos + length21;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.block = reader2.bytes();
                  break;
                case 2:
                  obj.priority = reader2.int32();
                  break;
                case 3:
                  obj.cancel = reader2.bool();
                  break;
                case 4:
                  obj.wantType = Message7.Wantlist.WantType.codec().decode(reader2);
                  break;
                case 5:
                  obj.sendDontHave = reader2.bool();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          });
        }
        return _codec3;
      };
      Entry2.encode = (obj) => {
        return encodeMessage(obj, Entry2.codec());
      };
      Entry2.decode = (buf3) => {
        return decodeMessage(buf3, Entry2.codec());
      };
    })(Entry = Wantlist3.Entry || (Wantlist3.Entry = {}));
    let _codec2;
    Wantlist3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.entries != null) {
            for (const value of obj.entries) {
              w2.uint32(10);
              Message7.Wantlist.Entry.codec().encode(value, w2);
            }
          }
          if (obj.full != null && obj.full !== false) {
            w2.uint32(16);
            w2.bool(obj.full);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            entries: [],
            full: false
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.entries.push(Message7.Wantlist.Entry.codec().decode(reader2, reader2.uint32()));
                break;
              case 2:
                obj.full = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Wantlist3.encode = (obj) => {
      return encodeMessage(obj, Wantlist3.codec());
    };
    Wantlist3.decode = (buf3) => {
      return decodeMessage(buf3, Wantlist3.codec());
    };
  })(Wantlist2 = Message7.Wantlist || (Message7.Wantlist = {}));
  let Block;
  (function(Block2) {
    let _codec2;
    Block2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.prefix != null && obj.prefix.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.prefix);
          }
          if (obj.data != null && obj.data.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            prefix: new Uint8Array(0),
            data: new Uint8Array(0)
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.prefix = reader2.bytes();
                break;
              case 2:
                obj.data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Block2.encode = (obj) => {
      return encodeMessage(obj, Block2.codec());
    };
    Block2.decode = (buf3) => {
      return decodeMessage(buf3, Block2.codec());
    };
  })(Block = Message7.Block || (Message7.Block = {}));
  let BlockPresenceType;
  (function(BlockPresenceType2) {
    BlockPresenceType2["Have"] = "Have";
    BlockPresenceType2["DontHave"] = "DontHave";
  })(BlockPresenceType = Message7.BlockPresenceType || (Message7.BlockPresenceType = {}));
  let __BlockPresenceTypeValues;
  (function(__BlockPresenceTypeValues2) {
    __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["Have"] = 0] = "Have";
    __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["DontHave"] = 1] = "DontHave";
  })(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));
  (function(BlockPresenceType2) {
    BlockPresenceType2.codec = () => {
      return enumeration(__BlockPresenceTypeValues);
    };
  })(BlockPresenceType = Message7.BlockPresenceType || (Message7.BlockPresenceType = {}));
  let BlockPresence;
  (function(BlockPresence2) {
    let _codec2;
    BlockPresence2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.cid != null && obj.cid.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.cid);
          }
          if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {
            w2.uint32(16);
            Message7.BlockPresenceType.codec().encode(obj.type, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            cid: new Uint8Array(0),
            type: BlockPresenceType.Have
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.cid = reader2.bytes();
                break;
              case 2:
                obj.type = Message7.BlockPresenceType.codec().decode(reader2);
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    BlockPresence2.encode = (obj) => {
      return encodeMessage(obj, BlockPresence2.codec());
    };
    BlockPresence2.decode = (buf3) => {
      return decodeMessage(buf3, BlockPresence2.codec());
    };
  })(BlockPresence = Message7.BlockPresence || (Message7.BlockPresence = {}));
  let _codec;
  Message7.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.wantlist != null) {
          w2.uint32(10);
          Message7.Wantlist.codec().encode(obj.wantlist, w2);
        }
        if (obj.blocks != null) {
          for (const value of obj.blocks) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (obj.payload != null) {
          for (const value of obj.payload) {
            w2.uint32(26);
            Message7.Block.codec().encode(value, w2);
          }
        }
        if (obj.blockPresences != null) {
          for (const value of obj.blockPresences) {
            w2.uint32(34);
            Message7.BlockPresence.codec().encode(value, w2);
          }
        }
        if (obj.pendingBytes != null && obj.pendingBytes !== 0) {
          w2.uint32(40);
          w2.int32(obj.pendingBytes);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          blocks: [],
          payload: [],
          blockPresences: [],
          pendingBytes: 0
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.wantlist = Message7.Wantlist.codec().decode(reader2, reader2.uint32());
              break;
            case 2:
              obj.blocks.push(reader2.bytes());
              break;
            case 3:
              obj.payload.push(Message7.Block.codec().decode(reader2, reader2.uint32()));
              break;
            case 4:
              obj.blockPresences.push(Message7.BlockPresence.codec().decode(reader2, reader2.uint32()));
              break;
            case 5:
              obj.pendingBytes = reader2.int32();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message7.encode = (obj) => {
    return encodeMessage(obj, Message7.codec());
  };
  Message7.decode = (buf3) => {
    return decodeMessage(buf3, Message7.codec());
  };
})(Message || (Message = {}));

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/message/index.js
var BitswapMessage = class _BitswapMessage {
  static {
    __name(this, "BitswapMessage");
  }
  static Entry = BitswapMessageEntry;
  static WantType = {
    Block: Message.Wantlist.WantType.Block,
    Have: Message.Wantlist.WantType.Have
  };
  static BlockPresenceType = {
    Have: Message.BlockPresenceType.Have,
    DontHave: Message.BlockPresenceType.DontHave
  };
  static deserialize = async (raw, hashLoader2) => {
    const decoded = Message.decode(raw);
    const isFull = decoded.wantlist?.full === true;
    const msg = new _BitswapMessage(isFull);
    decoded.wantlist?.entries.forEach((entry) => {
      if (entry.block == null) {
        return;
      }
      const cid = CID3.decode(entry.block);
      msg.addEntry(cid, entry.priority ?? 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
    decoded.blockPresences.forEach((blockPresence) => {
      if (blockPresence.cid == null) {
        return;
      }
      const cid = CID3.decode(blockPresence.cid);
      if (blockPresence.type === _BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid);
      } else {
        msg.addDontHave(cid);
      }
    });
    if (decoded.blocks.length > 0) {
      await Promise.all(decoded.blocks.map(async (b) => {
        const hash3 = await sha2562.digest(b);
        const cid = CID3.createV0(hash3);
        msg.addBlock(cid, b);
      }));
      return msg;
    }
    if (decoded.payload.length > 0) {
      await Promise.all(decoded.payload.map(async (p) => {
        if (p.prefix == null || p.data == null) {
          return;
        }
        const values = (0, import_varint_decoder.default)(p.prefix);
        const cidVersion = values[0];
        const multicodec = values[1];
        const hashAlg = values[2];
        const hasher = hashAlg === sha2562.code ? sha2562 : await hashLoader2?.getHasher(hashAlg);
        if (hasher == null) {
          throw new CodeError("Unknown hash algorithm", "ERR_UNKNOWN_HASH_ALG");
        }
        const hash3 = await hasher.digest(p.data);
        const cid = CID3.create(cidVersion, multicodec, hash3);
        msg.addBlock(cid, p.data);
      }));
      msg.setPendingBytes(decoded.pendingBytes);
      return msg;
    }
    return msg;
  };
  static blockPresenceSize = (cid) => {
    return cid.bytes.length + 1;
  };
  full;
  wantlist;
  blocks;
  blockPresences;
  pendingBytes;
  constructor(full) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = _BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58btc);
    const entry = this.wantlist.get(cidStr);
    if (entry != null) {
      if (entry.wantType === wantType) {
        entry.priority = priority;
      }
      if (cancel === true) {
        entry.cancel = Boolean(cancel);
      }
      if (sendDontHave === true) {
        entry.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === _BitswapMessage.WantType.Block && entry.wantType === _BitswapMessage.WantType.Have) {
        entry.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  addBlock(cid, block) {
    const cidStr = cid.toString(base58btc);
    this.blocks.set(cidStr, block);
  }
  addHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, _BitswapMessage.BlockPresenceType.Have);
    }
  }
  addDontHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, _BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  cancel(cid) {
    const cidStr = cid.toString(base58btc);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, _BitswapMessage.WantType.Block, true, false);
  }
  setPendingBytes(size) {
    this.pendingBytes = size;
  }
  /**
   * Serializes to Bitswap Message protobuf of
   * version 1.0.0
   */
  serializeToBitswap100() {
    return Message.encode({
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel),
            wantType: Message.Wantlist.WantType.Block,
            sendDontHave: false
          };
        }),
        full: Boolean(this.full)
      },
      blocks: Array.from(this.blocks.values())
    });
  }
  /**
   * Serializes to Bitswap Message protobuf of
   * version 1.1.0
   */
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: Boolean(this.full)
      },
      blockPresences: [],
      payload: [],
      pendingBytes: this.pendingBytes,
      blocks: []
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid = CID3.parse(cidStr);
      const version4 = cid.version;
      const codec = cid.code;
      const multihash = cid.multihash.code;
      const digestLength = cid.multihash.digest.length;
      const prefix = varint_encoder_default([
        version4,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push({
        prefix,
        data
      });
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push({
        cid: CID3.parse(cidStr).bytes,
        type: bpType
      });
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return Message.encode(msg);
  }
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || // @TODO - Is this a bug ?
    // @ts-expect-error - isMap equals map values to be objects not numbers
    !isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/wantlist/index.js
var WantType = {
  Block: Message.Wantlist.WantType.Block,
  Have: Message.Wantlist.WantType.Have
};
var sortBy = /* @__PURE__ */ __name((fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b) => {
    const aa = fn(a);
    const bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
}, "sortBy");
var Wantlist = class {
  static {
    __name(this, "Wantlist");
  }
  static Entry = WantListEntry;
  set;
  _stats;
  constructor(stats, libp2p) {
    this.set = libp2p != null ? trackedMap({
      name: "ipfs_bitswap_wantlist",
      metrics: libp2p.metrics
    }) : /* @__PURE__ */ new Map();
    this._stats = stats;
  }
  get length() {
    return this.set.size;
  }
  add(cid, priority, wantType) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (entry != null) {
      entry.inc();
      entry.priority = priority;
      if (entry.wantType === WantType.Have && wantType === WantType.Block) {
        entry.wantType = wantType;
      }
    } else {
      this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
      if (this._stats != null) {
        this._stats.push(void 0, "wantListSize", 1);
      }
    }
  }
  remove(cid) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (entry == null) {
      return;
    }
    entry.dec();
    if (entry.hasRefs()) {
      return;
    }
    this.set.delete(cidStr);
    if (this._stats != null) {
      this._stats.push(void 0, "wantListSize", -1);
    }
  }
  removeForce(cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr);
    }
  }
  forEach(fn) {
    this.set.forEach(fn);
  }
  entries() {
    return this.set.entries();
  }
  sortedEntries() {
    return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
  }
  contains(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.has(cidStr);
  }
  get(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.get(cidStr);
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js
var Ledger = class {
  static {
    __name(this, "Ledger");
  }
  partner;
  wantlist;
  exchangeCount;
  accounting;
  lastExchange;
  constructor(peerId) {
    this.partner = peerId;
    this.wantlist = new Wantlist();
    this.exchangeCount = 0;
    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    };
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.accounting.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.accounting.bytesRecv += n;
  }
  wants(cid, priority, wantType) {
    this.wantlist.add(cid, priority, wantType);
  }
  /**
   * @param {CID} cid
   * @returns {void}
   */
  cancelWant(cid) {
    this.wantlist.remove(cid);
  }
  wantlistContains(cid) {
    return this.wantlist.get(cid);
  }
  debtRatio() {
    return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js
var SortedMap = class extends Map {
  static {
    __name(this, "SortedMap");
  }
  _cmp;
  _keys;
  constructor(entries, cmp) {
    super();
    this._cmp = cmp ?? this._defaultSort;
    this._keys = [];
    for (const [k, v] of entries ?? []) {
      this.set(k, v);
    }
  }
  /**
   * Call update to update the position of the key when it should change.
   * For example if the compare function sorts by the priority field, and the
   * priority changes, call update.
   * Call indexOf() to get the index _before_ the change happens.
   */
  update(i) {
    if (i < 0 || i >= this._keys.length) {
      return;
    }
    const k = this._keys[i];
    this._keys.splice(i, 1);
    const newIdx = this._find(k);
    this._keys.splice(newIdx, 0, k);
  }
  set(k, v) {
    if (this.has(k)) {
      const i2 = this.indexOf(k);
      this._keys.splice(i2, 1);
    }
    super.set(k, v);
    const i = this._find(k);
    this._keys.splice(i, 0, k);
    return this;
  }
  clear() {
    super.clear();
    this._keys = [];
  }
  delete(k) {
    if (!this.has(k)) {
      return false;
    }
    const i = this.indexOf(k);
    this._keys.splice(i, 1);
    return super.delete(k);
  }
  indexOf(k) {
    if (!this.has(k)) {
      return -1;
    }
    const i = this._find(k);
    if (this._keys[i] === k) {
      return i;
    }
    for (let j = 1; j < this._keys.length; j++) {
      if (this._keys[i + j] === k)
        return i + j;
      if (this._keys[i - j] === k)
        return i - j;
    }
    return -1;
  }
  _find(k) {
    let lower = 0;
    let upper = this._keys.length;
    while (lower < upper) {
      const pivot = lower + upper >>> 1;
      const cmp = this._kCmp(this._keys[pivot], k);
      if (cmp < 0) {
        lower = pivot + 1;
      } else if (cmp > 0) {
        upper = pivot;
      } else {
        return pivot;
      }
    }
    return lower;
  }
  *keys() {
    for (const k of this._keys) {
      yield k;
    }
    return void 0;
  }
  *values() {
    for (const k of this._keys) {
      yield this.get(k);
    }
    return void 0;
  }
  *entries() {
    for (const k of this._keys) {
      yield [k, this.get(k)];
    }
    return void 0;
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void
  forEach(cb, thisArg = this) {
    if (cb == null) {
      return;
    }
    for (const k of this._keys) {
      const val = this.get(k);
      if (val == null) {
        throw new Error("Value cannot be undefined");
      }
      cb.apply(thisArg, [[k, val]]);
    }
  }
  _defaultSort(a, b) {
    if (a[0] < b[0])
      return -1;
    if (b[0] < a[0])
      return 1;
    return 0;
  }
  _kCmp(a, b) {
    return this._cmp(
      // @ts-expect-error - get may return undefined
      [a, this.get(a)],
      [b, this.get(b)]
    );
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js
var DefaultTaskMerger = {
  hasNewInfo() {
    return false;
  },
  merge() {
  }
};
var RequestQueue = class {
  static {
    __name(this, "RequestQueue");
  }
  _taskMerger;
  _byPeer;
  constructor(taskMerger = DefaultTaskMerger) {
    this._taskMerger = taskMerger;
    this._byPeer = new SortedMap([], PeerTasks.compare);
  }
  /**
   * Push tasks onto the queue for the given peer
   */
  pushTasks(peerId, tasks) {
    let peerTasks = this._byPeer.get(peerId.toString());
    if (peerTasks == null) {
      peerTasks = new PeerTasks(peerId, this._taskMerger);
    }
    peerTasks.pushTasks(tasks);
    this._byPeer.set(peerId.toString(), peerTasks);
  }
  /**
   * Choose the peer with the least active work (or if all have the same active
   * work, the most pending tasks) and pop off the highest priority tasks until
   * the total size is at least targetMinBytes.
   * This puts the popped tasks into the "active" state, meaning they are
   * actively being processed (and cannot be modified).
   */
  popTasks(targetMinBytes) {
    const peerTasks = this._head();
    if (peerTasks === void 0) {
      return { tasks: [], pendingSize: 0 };
    }
    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
    if (tasks.length === 0) {
      return { tasks, pendingSize };
    }
    const peerId = peerTasks.peerId;
    if (peerTasks.isIdle()) {
      this._byPeer.delete(peerId.toString());
    } else {
      this._byPeer.update(0);
    }
    return {
      peerId,
      tasks,
      pendingSize
    };
  }
  _head() {
    if (this._byPeer.size === 0) {
      return void 0;
    }
    for (const [, v] of this._byPeer) {
      return v;
    }
    return void 0;
  }
  /**
   * Remove the task with the given topic for the given peer.
   */
  remove(topic, peerId) {
    const peerTasks = this._byPeer.get(peerId.toString());
    peerTasks?.remove(topic);
  }
  /**
   * Called when the tasks for the given peer complete.
   */
  tasksDone(peerId, tasks) {
    const peerTasks = this._byPeer.get(peerId.toString());
    if (peerTasks == null) {
      return;
    }
    const i = this._byPeer.indexOf(peerId.toString());
    for (const task of tasks) {
      peerTasks.taskDone(task);
    }
    this._byPeer.update(i);
  }
};
var PeerTasks = class {
  static {
    __name(this, "PeerTasks");
  }
  peerId;
  _taskMerger;
  _activeTotalSize;
  _pending;
  _active;
  constructor(peerId, taskMerger) {
    this.peerId = peerId;
    this._taskMerger = taskMerger;
    this._activeTotalSize = 0;
    this._pending = new PendingTasks();
    this._active = /* @__PURE__ */ new Set();
  }
  /**
   * Push tasks onto the queue
   */
  pushTasks(tasks) {
    for (const t of tasks) {
      this._pushTask(t);
    }
  }
  _pushTask(task) {
    if (!this._taskHasMoreInfoThanActiveTasks(task)) {
      return;
    }
    const existingTask = this._pending.get(task.topic);
    if (existingTask != null) {
      if (task.priority > existingTask.priority) {
        this._pending.updatePriority(task.topic, task.priority);
      }
      this._taskMerger.merge(task, existingTask);
      return;
    }
    this._pending.add(task);
  }
  /**
   * Indicates whether the new task adds any more information over tasks that are
   * already in the active task queue
   */
  _taskHasMoreInfoThanActiveTasks(task) {
    const tasksWithTopic = [];
    for (const activeTask of this._active) {
      if (activeTask.topic === task.topic) {
        tasksWithTopic.push(activeTask);
      }
    }
    if (tasksWithTopic.length === 0) {
      return true;
    }
    return this._taskMerger.hasNewInfo(task, tasksWithTopic);
  }
  /**
   * Pop tasks off the queue such that the total size is at least targetMinBytes
   */
  popTasks(targetMinBytes) {
    let size = 0;
    const tasks = [];
    const pendingTasks = this._pending.tasks();
    for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {
      const task = pendingTasks[i];
      tasks.push(task);
      size += task.size;
      this._pending.delete(task.topic);
      this._activeTotalSize += task.size;
      this._active.add(task);
    }
    return {
      tasks,
      pendingSize: this._pending.totalSize
    };
  }
  /**
   * Called when a task completes.
   * Note: must be the same reference as returned from popTasks.
   */
  taskDone(task) {
    if (this._active.has(task)) {
      this._activeTotalSize -= task.size;
      this._active.delete(task);
    }
  }
  /**
   * Remove pending tasks with the given topic
   */
  remove(topic) {
    this._pending.delete(topic);
  }
  /**
   * No work to be done, this PeerTasks object can be freed.
   */
  isIdle() {
    return this._pending.length === 0 && this._active.size === 0;
  }
  /**
   * Compare PeerTasks
   */
  static compare(a, b) {
    if (a[1]._pending.length === 0) {
      return 1;
    }
    if (b[1]._pending.length === 0) {
      return -1;
    }
    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
      return b[1]._pending.length - a[1]._pending.length;
    }
    return a[1]._activeTotalSize - b[1]._activeTotalSize;
  }
};
var PendingTasks = class {
  static {
    __name(this, "PendingTasks");
  }
  _tasks;
  constructor() {
    this._tasks = new SortedMap([], this._compare);
  }
  get length() {
    return this._tasks.size;
  }
  /**
   * Sum of the size of all pending tasks
   **/
  get totalSize() {
    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
  }
  get(topic) {
    return this._tasks?.get(topic)?.task;
  }
  add(task) {
    this._tasks.set(task.topic, {
      created: Date.now(),
      task
    });
  }
  delete(topic) {
    this._tasks.delete(topic);
  }
  // All pending tasks, in priority order
  tasks() {
    return [...this._tasks.values()].map((i) => i.task);
  }
  /**
   * Update the priority of the task with the given topic, and update the order
   **/
  updatePriority(topic, priority) {
    const obj = this._tasks.get(topic);
    if (obj == null) {
      return;
    }
    const i = this._tasks.indexOf(topic);
    obj.task.priority = priority;
    this._tasks.update(i);
  }
  /**
   * Sort by priority desc then FIFO
   */
  _compare(a, b) {
    if (a[1].task.priority === b[1].task.priority) {
      return a[1].created - b[1].created;
    }
    return b[1].task.priority - a[1].task.priority;
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js
var DefaultTaskMerger2 = {
  /**
   * Indicates whether the given task has newer information than the active
   * tasks with the same topic.
   *
   * @param {Task} task
   * @param {Task[]} tasksWithTopic
   * @returns {boolean}
   */
  hasNewInfo(task, tasksWithTopic) {
    let haveBlock = false;
    let isWantBlock = false;
    for (const existing of tasksWithTopic) {
      if (existing.data.haveBlock) {
        haveBlock = true;
      }
      if (existing.data.isWantBlock) {
        isWantBlock = true;
      }
    }
    if (!isWantBlock && task.data.isWantBlock) {
      return true;
    }
    if (!haveBlock && task.data.haveBlock) {
      return true;
    }
    return false;
  },
  /**
   * Merge the information from the given task into the existing task (with the
   * same topic)
   */
  merge(newTask, existingTask) {
    const taskData = newTask.data;
    const existingData = existingTask.data;
    if (!existingData.haveBlock && taskData.haveBlock) {
      existingData.haveBlock = taskData.haveBlock;
      existingData.blockSize = taskData.blockSize;
    }
    if (!existingData.isWantBlock && taskData.isWantBlock) {
      existingData.isWantBlock = true;
      if (!existingData.haveBlock || taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingTask.size = newTask.size;
      }
    }
    if (existingData.isWantBlock && existingData.haveBlock) {
      existingTask.size = existingData.blockSize;
    }
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/decision-engine/index.js
var WantType2 = BitswapMessage.WantType;
var TARGET_MESSAGE_SIZE = 16 * 1024;
var MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DecisionEngine = class {
  static {
    __name(this, "DecisionEngine");
  }
  _log;
  blockstore;
  network;
  _stats;
  _opts;
  ledgerMap;
  _running;
  _requestQueue;
  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {
    this._log = logger4(peerId, "engine");
    this.blockstore = blockstore;
    this.network = network;
    this._stats = stats;
    this._opts = this._processOpts(opts);
    this.ledgerMap = trackedMap({
      name: "ipfs_bitswap_ledger_map",
      metrics: libp2p.metrics
    });
    this._running = false;
    this._requestQueue = new RequestQueue(DefaultTaskMerger2);
  }
  _processOpts(opts) {
    return {
      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
      targetMessageSize: TARGET_MESSAGE_SIZE,
      ...opts
    };
  }
  _scheduleProcessTasks() {
    setTimeout(() => {
      this._processTasks().catch((err) => {
        this._log.error("error processing stats", err);
      });
    });
  }
  /**
   * Pull tasks off the request queue and send a message to the corresponding
   * peer
   */
  async _processTasks() {
    if (!this._running) {
      return;
    }
    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
    if (tasks.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    msg.setPendingBytes(pendingSize);
    const blockCids = [];
    const blockTasks = /* @__PURE__ */ new Map();
    for (const task of tasks) {
      const cid = CID3.parse(task.topic);
      if (task.data.haveBlock) {
        if (task.data.isWantBlock) {
          blockCids.push(cid);
          blockTasks.set(task.topic, task.data);
        } else {
          msg.addHave(cid);
        }
      } else {
        msg.addDontHave(cid);
      }
    }
    const blocks = await this._getBlocks(blockCids);
    for (const [topic, taskData] of blockTasks) {
      const cid = CID3.parse(topic);
      const blk = blocks.get(topic);
      if (blk != null) {
        msg.addBlock(cid, blk);
      } else {
        if (taskData.sendDontHave) {
          msg.addDontHave(cid);
        }
      }
    }
    if (msg.empty) {
      peerId != null && this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
      return;
    }
    try {
      peerId != null && await this.network.sendMessage(peerId, msg);
      for (const [cidStr, block] of blocks.entries()) {
        peerId != null && this.messageSent(peerId, CID3.parse(cidStr), block);
      }
    } catch (err) {
      this._log.error(err);
    }
    peerId != null && this._requestQueue.tasksDone(peerId, tasks);
    this._scheduleProcessTasks();
  }
  wantlistForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    return ledger != null ? ledger.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
  }
  ledgerForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger == null) {
      return void 0;
    }
    return {
      peer: ledger.partner,
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    };
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner);
  }
  /**
   * Receive blocks either from an incoming message from the network, or from
   * blocks being added by the client on the localhost (eg IPFS add)
   */
  receivedBlocks(blocks) {
    if (blocks.length === 0) {
      return;
    }
    for (const ledger of this.ledgerMap.values()) {
      for (const { cid, block } of blocks) {
        const want = ledger.wantlistContains(cid);
        if (want == null) {
          continue;
        }
        const blockSize = block.length;
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        this._requestQueue.pushTasks(ledger.partner, [{
          topic: want.cid.toString(base58btc),
          priority: want.priority,
          size: entrySize,
          data: {
            blockSize,
            isWantBlock,
            haveBlock: true,
            sendDontHave: false
          }
        }]);
      }
    }
    this._scheduleProcessTasks();
  }
  /**
   * Handle incoming messages
   */
  async messageReceived(peerId, msg) {
    const ledger = this._findOrCreate(peerId);
    if (msg.empty) {
      return;
    }
    if (msg.full) {
      ledger.wantlist = new Wantlist();
    }
    this._updateBlockAccounting(msg.blocks, ledger);
    if (msg.wantlist.size === 0) {
      this._scheduleProcessTasks();
      return;
    }
    const cancels = [];
    const wants = [];
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid);
        cancels.push(entry.cid);
      } else {
        ledger.wants(entry.cid, entry.priority, entry.wantType);
        wants.push(entry);
      }
    });
    this._cancelWants(peerId, cancels);
    await this._addWants(peerId, wants);
    this._scheduleProcessTasks();
  }
  _cancelWants(peerId, cids) {
    for (const c of cids) {
      this._requestQueue.remove(c.toString(base58btc), peerId);
    }
  }
  async _addWants(peerId, wants) {
    const blockSizes = await this._getBlockSizes(wants.map((w2) => w2.cid));
    const tasks = [];
    for (const want of wants) {
      const id = want.cid.toString(base58btc);
      const blockSize = blockSizes.get(id);
      if (blockSize == null) {
        if (want.sendDontHave) {
          tasks.push({
            topic: id,
            priority: want.priority,
            size: BitswapMessage.blockPresenceSize(want.cid),
            data: {
              isWantBlock: want.wantType === WantType2.Block,
              blockSize: 0,
              haveBlock: false,
              sendDontHave: want.sendDontHave
            }
          });
        }
      } else {
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        tasks.push({
          topic: id,
          priority: want.priority,
          size: entrySize,
          data: {
            isWantBlock,
            blockSize,
            haveBlock: true,
            sendDontHave: want.sendDontHave
          }
        });
      }
      this._requestQueue.pushTasks(peerId, tasks);
    }
  }
  _sendAsBlock(wantType, blockSize) {
    return wantType === WantType2.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
  }
  async _getBlockSizes(cids) {
    const blocks = await this._getBlocks(cids);
    return new Map([...blocks].map(([k, v]) => [k, v.length]));
  }
  async _getBlocks(cids) {
    const res = /* @__PURE__ */ new Map();
    await Promise.all(cids.map(async (cid) => {
      try {
        const block = await this.blockstore.get(cid);
        res.set(cid.toString(base58btc), block);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          this._log.error("failed to query blockstore for %s: %s", cid, err);
        }
      }
    }));
    return res;
  }
  _updateBlockAccounting(blocksMap, ledger) {
    for (const block of blocksMap.values()) {
      this._log("got block (%s bytes)", block.length);
      ledger.receivedBytes(block.length);
    }
  }
  /**
   * Clear up all accounting things after message was sent
   */
  messageSent(peerId, cid, block) {
    const ledger = this._findOrCreate(peerId);
    ledger.sentBytes(block.length);
    ledger.wantlist.remove(cid);
  }
  numBytesSentTo(peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent;
  }
  numBytesReceivedFrom(peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv;
  }
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId.toString());
  }
  _findOrCreate(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger != null) {
      return ledger;
    }
    const l = new Ledger(peerId);
    this.ledgerMap.set(peerIdStr, l);
    if (this._stats != null) {
      this._stats.push(peerIdStr, "peerCount", 1);
    }
    return l;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
};

// node_modules/@libp2p/interface-registrar/dist/src/index.js
var topologySymbol = Symbol.for("@libp2p/topology");
function isTopology(other) {
  return other != null && Boolean(other[topologySymbol]);
}
__name(isTopology, "isTopology");

// node_modules/@libp2p/topology/dist/src/index.js
var noop2 = /* @__PURE__ */ __name(() => {
}, "noop");
var TopologyImpl = class {
  static {
    __name(this, "TopologyImpl");
  }
  min;
  max;
  /**
   * Set of peers that support the protocol
   */
  peers;
  onConnect;
  onDisconnect;
  registrar;
  constructor(init) {
    this.min = init.min ?? 0;
    this.max = init.max ?? Infinity;
    this.peers = /* @__PURE__ */ new Set();
    this.onConnect = init.onConnect ?? noop2;
    this.onDisconnect = init.onDisconnect ?? noop2;
  }
  get [Symbol.toStringTag]() {
    return topologySymbol.toString();
  }
  [topologySymbol] = true;
  async setRegistrar(registrar) {
    this.registrar = registrar;
  }
  /**
   * Notify about peer disconnected event
   */
  disconnect(peerId) {
    this.onDisconnect(peerId);
  }
};
function createTopology(init) {
  return new TopologyImpl(init);
}
__name(createTopology, "createTopology");

// node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}
__name(getIterator, "getIterator");

// node_modules/abortable-iterator/dist/src/abort-error.js
var AbortError3 = class extends Error {
  static {
    __name(this, "AbortError");
  }
  type;
  code;
  constructor(message2, code16, name14) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code16 ?? "ABORT_ERR";
    this.name = name14 ?? "AbortError";
  }
};

// node_modules/abortable-iterator/dist/src/index.js
function abortableSource(source, signal, options) {
  const opts = options ?? {};
  const iterator = getIterator(source);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = /* @__PURE__ */ __name(() => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    }, "abortHandler");
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode, abortName } = opts;
          throw new AbortError3(abortMessage, abortCode, abortName);
        }
        const abort = new Promise((resolve, reject) => {
          nextAbortHandler = /* @__PURE__ */ __name(() => {
            const { abortMessage, abortCode, abortName } = opts;
            reject(new AbortError3(abortMessage, abortCode, abortName));
          }, "nextAbortHandler");
        });
        result = await Promise.race([abort, iterator.next()]);
        nextAbortHandler = null;
      } catch (err) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          opts.onAbort(source);
        }
        if (typeof iterator.return === "function") {
          try {
            const p = iterator.return();
            if (p instanceof Promise) {
              p.catch((err2) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err2);
                }
              });
            }
          } catch (err2) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err2);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  __name(abortable, "abortable");
  return abortable();
}
__name(abortableSource, "abortableSource");
function abortableSink(sink, signal, options) {
  return (source) => sink(abortableSource(source, signal, options));
}
__name(abortableSink, "abortableSink");
function abortableDuplex(duplex, signal, options) {
  return {
    sink: abortableSink(duplex.sink, signal, {
      ...options,
      onAbort: void 0
    }),
    source: abortableSource(duplex.source, signal, options)
  };
}
__name(abortableDuplex, "abortableDuplex");

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js
function alloc2(size = 0) {
  return new Uint8Array(size);
}
__name(alloc2, "alloc");
function allocUnsafe4(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe4, "allocUnsafe");

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf3) {
  return buf3;
}
__name(asUint8Array, "asUint8Array");

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js
function concat(arrays, length21) {
  if (length21 == null) {
    length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe4(length21);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output3);
}
__name(concat, "concat");

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js
function equals10(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
__name(equals10, "equals");

// node_modules/uint8arraylist/dist/src/index.js
var symbol = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf3 of bufs) {
    const bufEnd = offset + buf3.byteLength;
    if (index < bufEnd) {
      return {
        buf: buf3,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
__name(findBufAndOffset, "findBufAndOffset");
function isUint8ArrayList(value) {
  return Boolean(value?.[symbol]);
}
__name(isUint8ArrayList, "isUint8ArrayList");
var Uint8ArrayList = class _Uint8ArrayList {
  static {
    __name(this, "Uint8ArrayList");
  }
  bufs;
  length;
  [symbol] = true;
  constructor(...data) {
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length21 = 0;
    for (const buf3 of bufs) {
      if (buf3 instanceof Uint8Array) {
        length21 += buf3.byteLength;
        this.bufs.push(buf3);
      } else if (isUint8ArrayList(buf3)) {
        length21 += buf3.byteLength;
        this.bufs.push(...buf3.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length21;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length21 = 0;
    for (const buf3 of bufs.reverse()) {
      if (buf3 instanceof Uint8Array) {
        length21 += buf3.byteLength;
        this.bufs.unshift(buf3);
      } else if (isUint8ArrayList(buf3)) {
        length21 += buf3.byteLength;
        this.bufs.unshift(...buf3.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length21;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf3, offset = 0) {
    if (buf3 instanceof Uint8Array) {
      for (let i = 0; i < buf3.length; i++) {
        this.set(offset + i, buf3[i]);
      }
    } else if (isUint8ArrayList(buf3)) {
      for (let i = 0; i < buf3.length; i++) {
        this.set(offset + i, buf3.get(i));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes3) {
    bytes3 = Math.trunc(bytes3);
    if (Number.isNaN(bytes3) || bytes3 <= 0) {
      return;
    }
    if (bytes3 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes3 >= this.bufs[0].byteLength) {
        bytes3 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes3);
        this.length -= bytes3;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length21 } = this._subList(beginInclusive, endExclusive);
    return concat(bufs, length21);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length21 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat(bufs, length21);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length21 } = this._subList(beginInclusive, endExclusive);
    const list = new _Uint8ArrayList();
    list.length = length21;
    list.bufs = [...bufs];
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: this.bufs, length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i = 0; i < this.bufs.length; i++) {
      const buf3 = this.bufs[i];
      const bufStart = offset;
      const bufEnd = bufStart + buf3.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf3);
          break;
        }
        const start = beginInclusive - bufStart;
        bufs.push(buf3.subarray(start, start + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf3);
          continue;
        }
        bufs.push(buf3.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf3);
          break;
        }
        bufs.push(buf3.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf3);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i = offset; i <= lastIndex; i += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf3 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value) {
    const buf3 = allocUnsafe4(1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setInt8(0, value);
    this.write(buf3, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value, littleEndian) {
    const buf3 = alloc2(2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setInt16(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value, littleEndian) {
    const buf3 = alloc2(4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setInt32(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value, littleEndian) {
    const buf3 = alloc2(8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setBigInt64(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getUint8(byteOffset) {
    const buf3 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value) {
    const buf3 = allocUnsafe4(1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setUint8(0, value);
    this.write(buf3, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value, littleEndian) {
    const buf3 = alloc2(2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setUint16(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value, littleEndian) {
    const buf3 = alloc2(4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setUint32(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value, littleEndian) {
    const buf3 = alloc2(8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setBigUint64(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value, littleEndian) {
    const buf3 = alloc2(4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setFloat32(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value, littleEndian) {
    const buf3 = alloc2(8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setFloat64(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof _Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i = 0; i < this.bufs.length; i++) {
      if (!equals10(this.bufs[i], other.bufs[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length21) {
    const list = new _Uint8ArrayList();
    list.bufs = bufs;
    if (length21 == null) {
      length21 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length21;
    return list;
  }
};

// node_modules/it-length-prefixed/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe5(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe5, "allocUnsafe");

// node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable10(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable10, "isAsyncIterable");

// node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = /* @__PURE__ */ __name((length21) => {
  const lengthLength = encodingLength4(length21);
  const lengthBuf = allocUnsafe5(lengthLength);
  encode11(length21, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
}, "defaultEncoder");
defaultEncoder.bytes = 0;
function encode16(source, options) {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  function* maybeYield(chunk) {
    const length21 = encodeLength(chunk.byteLength);
    if (length21 instanceof Uint8Array) {
      yield length21;
    } else {
      yield* length21;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  __name(maybeYield, "maybeYield");
  if (isAsyncIterable10(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
__name(encode16, "encode");
encode16.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};

// node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  static {
    __name(this, "InvalidMessageLengthError");
  }
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
var InvalidDataLengthError = class extends Error {
  static {
    __name(this, "InvalidDataLengthError");
  }
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
var InvalidDataLengthLengthError = class extends Error {
  static {
    __name(this, "InvalidDataLengthLengthError");
  }
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};
var UnexpectedEOFError = class extends Error {
  static {
    __name(this, "UnexpectedEOFError");
  }
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
};

// node_modules/it-length-prefixed/dist/src/decode.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = /* @__PURE__ */ __name((buf3) => {
  const length21 = decode15(buf3);
  defaultDecoder.bytes = encodingLength4(length21);
  return length21;
}, "defaultDecoder");
defaultDecoder.bytes = 0;
function decode21(source, options) {
  const buffer3 = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer3.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer3);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer3.consume(dataLengthLength);
          if (options?.onLength != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer3.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer3.byteLength < dataLength) {
          break;
        }
        const data = buffer3.sublist(0, dataLength);
        buffer3.consume(dataLength);
        if (options?.onData != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  __name(maybeYield, "maybeYield");
  if (isAsyncIterable10(source)) {
    return async function* () {
      for await (const buf3 of source) {
        buffer3.append(buf3);
        yield* maybeYield();
      }
      if (buffer3.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf3 of source) {
      buffer3.append(buf3);
      yield* maybeYield();
    }
    if (buffer3.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  }();
}
__name(decode21, "decode");
decode21.fromReader = (reader2, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader2.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = /* @__PURE__ */ __name((l) => {
    byteLength = l;
  }, "onLength");
  return decode21(varByteSource, {
    ...options ?? {},
    onLength
  });
};

// node_modules/progress-events/dist/src/index.js
var CustomProgressEvent = class extends Event {
  static {
    __name(this, "CustomProgressEvent");
  }
  type;
  detail;
  constructor(type, detail) {
    super(type);
    this.type = type;
    this.detail = detail;
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/network.js
var import_timeout_abort_controller = __toESM(require_timeout_abort_controller(), 1);

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/constants.js
var SECOND = 1e3;
var maxProvidersPerRequest = 3;
var providerRequestTimeout = 10 * SECOND;
var hasBlockTimeout = 15 * SECOND;
var provideTimeout = 15 * SECOND;
var kMaxPriority = Math.pow(2, 31) - 1;
var maxListeners = 1e3;
var wantlistSendDebounceMs = 1;

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/network.js
var BITSWAP100 = "/ipfs/bitswap/1.0.0";
var BITSWAP110 = "/ipfs/bitswap/1.1.0";
var BITSWAP120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_INBOUND_STREAMS = 1024;
var DEFAULT_MAX_OUTBOUND_STREAMS = 1024;
var DEFAULT_INCOMING_STREAM_TIMEOUT = 3e4;
var Network = class {
  static {
    __name(this, "Network");
  }
  _log;
  _libp2p;
  _bitswap;
  _protocols;
  _stats;
  _running;
  _hashLoader;
  _maxInboundStreams;
  _maxOutboundStreams;
  _incomingStreamTimeout;
  _registrarIds;
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger4(libp2p.peerId, "network");
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (options.b100Only !== true) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader ?? {
      async getHasher() {
        throw new Error("Not implemented");
      }
    };
    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;
  }
  async start() {
    this._running = true;
    await this._libp2p.handle(this._protocols, this._onConnection, {
      maxInboundStreams: this._maxInboundStreams,
      maxOutboundStreams: this._maxOutboundStreams
    });
    const topology = createTopology({
      onConnect: this._onPeerConnect,
      onDisconnect: this._onPeerDisconnect
    });
    this._registrarIds = [];
    for (const protocol of this._protocols) {
      this._registrarIds.push(await this._libp2p.register(protocol, topology));
    }
    this._libp2p.getConnections().forEach((conn) => {
      this._onPeerConnect(conn.remotePeer);
    });
  }
  async stop() {
    this._running = false;
    await this._libp2p.unhandle(this._protocols);
    if (this._registrarIds != null) {
      for (const id of this._registrarIds) {
        this._libp2p.unregister(id);
      }
      this._registrarIds = [];
    }
  }
  /**
   * Handles both types of incoming bitswap messages
   */
  _onConnection(info) {
    if (!this._running) {
      return;
    }
    const { stream, connection } = info;
    const controller = new import_timeout_abort_controller.TimeoutController(this._incomingStreamTimeout);
    Promise.resolve().then(async () => {
      this._log("incoming new bitswap %s connection from %p", stream.stat.protocol, connection.remotePeer);
      await pipe(abortableSource(stream.source, controller.signal), (source) => decode21(source), async (source) => {
        for await (const data of source) {
          try {
            const message2 = await BitswapMessage.deserialize(data.subarray(), this._hashLoader);
            await this._bitswap._receiveMessage(connection.remotePeer, message2);
          } catch (err) {
            this._bitswap._receiveError(err);
            break;
          }
          controller.reset();
        }
      });
    }).catch((err) => {
      this._log(err);
      stream.abort(err);
    }).finally(() => {
      controller.clear();
      stream.close();
    });
  }
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  /**
   * Find providers given a `cid`.
   */
  findProviders(cid, options = {}) {
    options.onProgress?.(new CustomProgressEvent("bitswap:network:find-providers", cid));
    return this._libp2p.contentRouting.findProviders(cid, options);
  }
  /**
   * Find the providers of a given `cid` and connect to them.
   */
  async findAndConnect(cid, options) {
    await src_default2(src_default8(src_default9(this.findProviders(cid, options), async (provider) => this.connectTo(provider.id, options).catch((err) => {
      this._log.error(err);
    })), maxProvidersPerRequest)).catch((err) => {
      this._log.error(err);
    });
  }
  /**
   * Tell the network we can provide content for the passed CID
   */
  async provide(cid, options = {}) {
    options.onProgress?.(new CustomProgressEvent("bitswap:network:provide", cid));
    await this._libp2p.contentRouting.provide(cid, options);
  }
  /**
   * Connect to the given peer
   * Send the given msg (instance of Message) to the given peer
   */
  async sendMessage(peer, msg, options = {}) {
    if (!this._running)
      throw new Error("network isn't running");
    const stringId = peer.toString();
    this._log("sendMessage to %s", stringId, msg);
    options.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist", peer));
    await this._writeMessage(peer, msg, options);
    this._updateSentStats(peer, msg.blocks);
  }
  /**
   * Connects to another peer
   */
  async connectTo(peer, options = {}) {
    if (!this._running) {
      throw new Error("network isn't running");
    }
    options.onProgress?.(new CustomProgressEvent("bitswap:network:dial", peer));
    return this._libp2p.dial(peer, options);
  }
  _updateSentStats(peer, blocks) {
    const peerId = peer.toString();
    if (this._stats != null) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, "dataSent", block.length);
      }
      this._stats.push(peerId, "blocksSent", blocks.size);
    }
  }
  async _writeMessage(peerId, msg, options = {}) {
    const stream = await this._libp2p.dialProtocol(peerId, [BITSWAP120, BITSWAP110, BITSWAP100]);
    try {
      let serialized;
      switch (stream.stat.protocol) {
        case BITSWAP100:
          serialized = msg.serializeToBitswap100();
          break;
        case BITSWAP110:
        case BITSWAP120:
          serialized = msg.serializeToBitswap110();
          break;
        default:
          throw new Error(`Unknown protocol: ${stream.stat.protocol}`);
      }
      await pipe([serialized], (source) => encode16(source), stream);
    } catch (err) {
      options.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist:error", { peer: peerId, error: err }));
      this._log(err);
    } finally {
      stream.close();
    }
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/notifications.js
var import_events = __toESM(require_events(), 1);

// node_modules/multiformats/src/bases/base10.js
var base10_exports3 = {};
__export(base10_exports3, {
  base10: () => base103
});

// node_modules/multiformats/vendor/base-x.js
function base6(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base6, "base");
var src6 = base6;
var _brrp__multiformats_scope_baseX6 = src6;
var base_x_default6 = _brrp__multiformats_scope_baseX6;

// node_modules/multiformats/src/bytes.js
var empty6 = new Uint8Array(0);
var equals11 = /* @__PURE__ */ __name((aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}, "equals");
var coerce6 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");
var fromString5 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString");
var toString4 = /* @__PURE__ */ __name((b) => new TextDecoder().decode(b), "toString");

// node_modules/multiformats/src/bases/base.js
var Encoder6 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder6 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or6(this, decoder);
  }
};
var ComposedDecoder6 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or6(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or6 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder6(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec6 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder6(name14, prefix, baseEncode);
    this.decoder = new Decoder6(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from9 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec6(name14, prefix, encode79, decode97), "from");
var baseX6 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default6(alphabet11, name14);
  return from9({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce6(decode97(text))
  });
}, "baseX");
var decode22 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode17 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc46486 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from9({
    prefix,
    name: name14,
    encode(input) {
      return encode17(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode22(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/multiformats/src/bases/base10.js
var base103 = baseX6({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/src/bases/base16.js
var base16_exports3 = {};
__export(base16_exports3, {
  base16: () => base163,
  base16upper: () => base16upper3
});
var base163 = rfc46486({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper3 = rfc46486({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/src/bases/base2.js
var base2_exports3 = {};
__export(base2_exports3, {
  base2: () => base24
});
var base24 = rfc46486({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports3 = {};
__export(base256emoji_exports3, {
  base256emoji: () => base256emoji3
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars3 = (
  /** @type {string[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes3 = (
  /** @type {number[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode18(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars3[c];
    return p;
  }, "");
}
__name(encode18, "encode");
function decode23(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes3[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode23, "decode");
var base256emoji3 = from9({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode18,
  decode: decode23
});

// node_modules/multiformats/src/bases/base32.js
var base32_exports3 = {};
__export(base32_exports3, {
  base32: () => base326,
  base32hex: () => base32hex6,
  base32hexpad: () => base32hexpad6,
  base32hexpadupper: () => base32hexpadupper6,
  base32hexupper: () => base32hexupper6,
  base32pad: () => base32pad6,
  base32padupper: () => base32padupper6,
  base32upper: () => base32upper6,
  base32z: () => base32z6
});
var base326 = rfc46486({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper6 = rfc46486({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad6 = rfc46486({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper6 = rfc46486({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex6 = rfc46486({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper6 = rfc46486({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad6 = rfc46486({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper6 = rfc46486({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z6 = rfc46486({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/src/bases/base36.js
var base36_exports3 = {};
__export(base36_exports3, {
  base36: () => base363,
  base36upper: () => base36upper3
});
var base363 = baseX6({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX6({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/src/bases/base58.js
var base58_exports3 = {};
__export(base58_exports3, {
  base58btc: () => base58btc6,
  base58flickr: () => base58flickr6
});
var base58btc6 = baseX6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr6 = baseX6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/src/bases/base64.js
var base64_exports3 = {};
__export(base64_exports3, {
  base64: () => base646,
  base64pad: () => base64pad6,
  base64url: () => base64url6,
  base64urlpad: () => base64urlpad6
});
var base646 = rfc46486({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad6 = rfc46486({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url6 = rfc46486({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad6 = rfc46486({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/multiformats/src/bases/base8.js
var base8_exports3 = {};
__export(base8_exports3, {
  base8: () => base83
});
var base83 = rfc46486({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/src/bases/identity.js
var identity_exports5 = {};
__export(identity_exports5, {
  identity: () => identity5
});
var identity5 = from9({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString4(buf3),
  decode: (str) => fromString5(str)
});

// node_modules/multiformats/src/codecs/json.js
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// node_modules/multiformats/src/hashes/identity.js
var identity_exports6 = {};
__export(identity_exports6, {
  identity: () => identity6
});

// node_modules/multiformats/vendor/varint.js
var encode_15 = encode19;
var MSB6 = 128;
var REST6 = 127;
var MSBALL5 = ~REST6;
var INT5 = Math.pow(2, 31);
function encode19(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT5) {
    out[offset++] = num & 255 | MSB6;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset++] = num & 255 | MSB6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode19.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode19, "encode");
var decode24 = read6;
var MSB$15 = 128;
var REST$15 = 127;
function read6(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$15);
  read6.bytes = counter - offset;
  return res;
}
__name(read6, "read");
var N16 = Math.pow(2, 7);
var N26 = Math.pow(2, 14);
var N36 = Math.pow(2, 21);
var N46 = Math.pow(2, 28);
var N56 = Math.pow(2, 35);
var N66 = Math.pow(2, 42);
var N76 = Math.pow(2, 49);
var N85 = Math.pow(2, 56);
var N95 = Math.pow(2, 63);
var length6 = /* @__PURE__ */ __name(function(value) {
  return value < N16 ? 1 : value < N26 ? 2 : value < N36 ? 3 : value < N46 ? 4 : value < N56 ? 5 : value < N66 ? 6 : value < N76 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
}, "length");
var varint6 = {
  encode: encode_15,
  decode: decode24,
  encodingLength: length6
};
var _brrp_varint5 = varint6;
var varint_default5 = _brrp_varint5;

// node_modules/multiformats/src/varint.js
var decode25 = /* @__PURE__ */ __name((data, offset = 0) => {
  const code16 = varint_default5.decode(data, offset);
  return [code16, varint_default5.decode.bytes];
}, "decode");
var encodeTo5 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default5.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength6 = /* @__PURE__ */ __name((int) => {
  return varint_default5.encodingLength(int);
}, "encodingLength");

// node_modules/multiformats/src/hashes/digest.js
var create5 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength6(code16);
  const digestOffset = sizeOffset + encodingLength6(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo5(code16, bytes3, 0);
  encodeTo5(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest5(code16, size, digest13, bytes3);
}, "create");
var decode26 = /* @__PURE__ */ __name((multihash) => {
  const bytes3 = coerce6(multihash);
  const [code16, sizeOffset] = decode25(bytes3);
  const [size, digestOffset] = decode25(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest5(code16, size, digest13, bytes3);
}, "decode");
var equals12 = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals11(a.bytes, data.bytes);
  }
}, "equals");
var Digest5 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/multiformats/src/hashes/identity.js
var code4 = 0;
var name3 = "identity";
var encode20 = coerce6;
var digest3 = /* @__PURE__ */ __name((input) => create5(code4, encode20(input)), "digest");
var identity6 = { code: code4, name: name3, encode: encode20, digest: digest3 };

// node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports3 = {};
__export(sha2_browser_exports3, {
  sha256: () => sha2564,
  sha512: () => sha5124
});

// node_modules/multiformats/src/hashes/hasher.js
var from10 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher4(name14, code16, encode79), "from");
var Hasher4 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest13) => create5(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/multiformats/src/hashes/sha2-browser.js
var sha4 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha2564 = from10({
  name: "sha2-256",
  code: 18,
  encode: sha4("SHA-256")
});
var sha5124 = from10({
  name: "sha2-512",
  code: 19,
  encode: sha4("SHA-512")
});

// node_modules/multiformats/src/cid.js
var format5 = /* @__PURE__ */ __name((link, base42) => {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV05(
        bytes3,
        baseCache5(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base42 || base58btc6.encoder
      );
    default:
      return toStringV15(
        bytes3,
        baseCache5(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base42 || base326.encoder
      );
  }
}, "format");
var cache5 = /* @__PURE__ */ new WeakMap();
var baseCache5 = /* @__PURE__ */ __name((cid) => {
  const baseCache14 = cache5.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache5.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}, "baseCache");
var CID5 = class _CID {
  static {
    __name(this, "CID");
  }
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create5(code16, digest13);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals12(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base42) {
    return format5(this, base42);
  }
  /**
   * @returns {API.LinkJSON<this>}
   */
  toJSON() {
    return { "/": format5(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(
        version4,
        code16,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes3 || encodeCID5(version4, code16, multihash.bytes)
      );
    } else if (value[cidSymbol5] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode26(multihash)
      );
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE5) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`
          );
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID5(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE5, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce6(
      bytes3.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest13 = new Digest5(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest13
    ) : _CID.createV1(specs.codec, digest13);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode25(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE5
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes5(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache5(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes5 = /* @__PURE__ */ __name((source, base42) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 || base58btc6;
      return [
        /** @type {Prefix} */
        base58btc6.prefix,
        decoder.decode(`${base58btc6.prefix}${source}`)
      ];
    }
    case base58btc6.prefix: {
      const decoder = base42 || base58btc6;
      return [
        /** @type {Prefix} */
        base58btc6.prefix,
        decoder.decode(source)
      ];
    }
    case base326.prefix: {
      const decoder = base42 || base326;
      return [
        /** @type {Prefix} */
        base326.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base42 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base42.decode(source)
      ];
    }
  }
}, "parseCIDtoBytes");
var toStringV05 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  if (prefix !== base58btc6.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV0");
var toStringV15 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV1");
var DAG_PB_CODE5 = 112;
var SHA_256_CODE5 = 18;
var encodeCID5 = /* @__PURE__ */ __name((version4, code16, multihash) => {
  const codeOffset = encodingLength6(version4);
  const hashOffset = codeOffset + encodingLength6(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo5(version4, bytes3, 0);
  encodeTo5(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}, "encodeCID");
var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

// node_modules/multiformats/src/basics.js
var bases3 = { ...identity_exports5, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports3 };
var hashes3 = { ...sha2_browser_exports3, ...identity_exports6 };

// node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf3) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength);
  }
  return buf3;
}
__name(asUint8Array2, "asUint8Array");

// node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe6(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array2(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
__name(allocUnsafe6, "allocUnsafe");

// node_modules/uint8arrays/dist/src/util/bases.js
function createCodec4(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: {
      decode: decode97
    }
  };
}
__name(createCodec4, "createCodec");
var string3 = createCodec4("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii3 = createCodec4("ascii", "a", (buf3) => {
  let string8 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string8 += String.fromCharCode(buf3[i]);
  }
  return string8;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe6(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES3 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases3.base16,
  latin1: ascii3,
  ascii: ascii3,
  binary: ascii3,
  ...bases3
};
var bases_default3 = BASES3;

// node_modules/uint8arrays/dist/src/to-string.js
function toString5(array, encoding = "utf8") {
  const base42 = bases_default3[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base42.encoder.encode(array).substring(1);
}
__name(toString5, "toString");

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/notifications.js
var unwantEvent = /* @__PURE__ */ __name((cid) => `unwant:${toString5(cid.multihash.bytes, "base64")}`, "unwantEvent");
var blockEvent = /* @__PURE__ */ __name((cid) => `block:${toString5(cid.multihash.bytes, "base64")}`, "blockEvent");
var Notifications = class extends import_events.EventEmitter {
  static {
    __name(this, "Notifications");
  }
  _log;
  /**
   * Internal module used to track events about incoming blocks,
   * wants and unwants.
   */
  constructor(peerId) {
    super();
    this.setMaxListeners(maxListeners);
    this._log = logger4(peerId, "notif");
  }
  /**
   * Signal the system that we received `block`.
   */
  hasBlock(cid, block) {
    const event = blockEvent(cid);
    this._log(event);
    this.emit(event, block);
  }
  /**
   * Signal the system that we are waiting to receive the
   * block associated with the given `cid`.
   * Returns a Promise that resolves to the block when it is received,
   * or undefined when the block is unwanted.
   */
  async wantBlock(cid, options = {}) {
    if (cid == null) {
      throw new Error("Not a valid cid");
    }
    const blockEvt = blockEvent(cid);
    const unwantEvt = unwantEvent(cid);
    this._log(`wantBlock:${cid}`);
    return new Promise((resolve, reject) => {
      const onUnwant = /* @__PURE__ */ __name(() => {
        this.removeListener(blockEvt, onBlock);
        options.onProgress?.(new CustomProgressEvent("bitswap:want-block:unwant", cid));
        reject(new Error(`Block for ${cid} unwanted`));
      }, "onUnwant");
      const onBlock = /* @__PURE__ */ __name((data) => {
        this.removeListener(unwantEvt, onUnwant);
        options.onProgress?.(new CustomProgressEvent("bitswap:want-block:block", cid));
        resolve(data);
      }, "onBlock");
      this.once(unwantEvt, onUnwant);
      this.once(blockEvt, onBlock);
      options.signal?.addEventListener("abort", () => {
        this.removeListener(blockEvt, onBlock);
        this.removeListener(unwantEvt, onUnwant);
        reject(new Error(`Want for ${cid} aborted`));
      });
    });
  }
  /**
   * Signal that the block is not wanted anymore
   */
  unwantBlock(cid) {
    const event = unwantEvent(cid);
    this._log(event);
    this.emit(event);
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/stats/index.js
var import_events3 = __toESM(require_events(), 1);

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/stats/stat.js
var import_events2 = __toESM(require_events(), 1);
var import_moving_average = __toESM(require_moving_average(), 1);
var Stat = class extends import_events2.EventEmitter {
  static {
    __name(this, "Stat");
  }
  _options;
  _queue;
  _stats;
  _frequencyLastTime;
  _frequencyAccumulators;
  _movingAverages;
  _enabled;
  _timeout;
  constructor(initialCounters, options) {
    super();
    this._options = options;
    this._queue = [];
    this._stats = {};
    this._frequencyLastTime = Date.now();
    this._frequencyAccumulators = {};
    this._movingAverages = {};
    this._update = this._update.bind(this);
    initialCounters.forEach((key) => {
      this._stats[key] = BigInt(0);
      this._movingAverages[key] = {};
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = (0, import_moving_average.default)(interval);
        ma.push(this._frequencyLastTime, 0);
      });
    });
    this._enabled = this._options.enabled;
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
  }
  stop() {
    if (this._timeout != null) {
      clearTimeout(this._timeout);
    }
  }
  get snapshot() {
    return Object.assign({}, this._stats);
  }
  get movingAverages() {
    return Object.assign({}, this._movingAverages);
  }
  push(counter, inc) {
    if (this._enabled) {
      this._queue.push([counter, inc, Date.now()]);
      this._resetComputeTimeout();
    }
  }
  _resetComputeTimeout() {
    if (this._timeout != null) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
  }
  _update() {
    this._timeout = void 0;
    if (this._queue.length > 0) {
      let last;
      while (this._queue.length > 0) {
        const op = last = this._queue.shift();
        op != null && this._applyOp(op);
      }
      last != null && this._updateFrequency(last[2]);
      this.emit("update", this._stats);
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime;
    if (timeDiff > 0) {
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
    }
    this._frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] ?? 0;
    this._frequencyAccumulators[key] = 0;
    const hz = count / timeDiffMS * 1e3;
    let movingAverages = this._movingAverages[key];
    if (movingAverages == null) {
      movingAverages = this._movingAverages[key] = {};
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage = movingAverages[movingAverageInterval];
      if (movingAverage == null) {
        movingAverage = movingAverages[movingAverageInterval] = (0, import_moving_average.default)(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    });
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error(`invalid increment number: ${inc}`);
    }
    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
      this._stats[key] = BigInt(0);
    }
    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
    if (this._frequencyAccumulators[key] == null) {
      this._frequencyAccumulators[key] = 0;
    }
    this._frequencyAccumulators[key] += inc;
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/stats/index.js
var defaultOptions = {
  enabled: false,
  computeThrottleTimeout: 1e3,
  computeThrottleMaxQueueSize: 1e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
    // 15 minutes
  ]
};
var Stats = class extends import_events3.EventEmitter {
  static {
    __name(this, "Stats");
  }
  _initialCounters;
  _options;
  _enabled;
  _global;
  _peers;
  constructor(libp2p, initialCounters = [], _options = defaultOptions) {
    super();
    const options = Object.assign({}, defaultOptions, _options);
    if (typeof options.computeThrottleTimeout !== "number") {
      throw new Error("need computeThrottleTimeout");
    }
    if (typeof options.computeThrottleMaxQueueSize !== "number") {
      throw new Error("need computeThrottleMaxQueueSize");
    }
    this._initialCounters = initialCounters;
    this._options = options;
    this._enabled = this._options.enabled;
    this._global = new Stat(initialCounters, options);
    this._global.on("update", (stats) => this.emit("update", stats));
    this._peers = trackedMap({
      name: "ipfs_bitswap_stats_peers",
      metrics: libp2p.metrics
    });
  }
  enable() {
    this._enabled = true;
    this._options.enabled = true;
    this._global.enable();
  }
  disable() {
    this._enabled = false;
    this._options.enabled = false;
    this._global.disable();
  }
  stop() {
    this._enabled = false;
    this._global.stop();
    for (const peerStat of this._peers) {
      peerStat[1].stop();
    }
  }
  get snapshot() {
    return this._global.snapshot;
  }
  get movingAverages() {
    return this._global.movingAverages;
  }
  forPeer(peerId) {
    const peerIdStr = peerId.toString();
    return this._peers.get(peerIdStr);
  }
  push(peer, counter, inc) {
    if (this._enabled) {
      this._global.push(counter, inc);
      if (peer != null) {
        let peerStats = this._peers.get(peer);
        if (peerStats == null) {
          peerStats = new Stat(this._initialCounters, this._options);
          this._peers.set(peer, peerStats);
        }
        peerStats.push(counter, inc);
      }
    }
  }
  disconnected(peer) {
    const peerId = peer.toString();
    const peerStats = this._peers.get(peerId);
    if (peerStats != null) {
      peerStats.stop();
      this._peers.delete(peerId);
    }
  }
};

// node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = /* @__PURE__ */ __name(function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  }, "clear");
  var flush = /* @__PURE__ */ __name(function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  }, "flush");
  var debounceWrapper = /* @__PURE__ */ __name(function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = /* @__PURE__ */ __name(function() {
      fn.apply(context, args);
    }, "debouncedFn");
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  }, "debounceWrapper");
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}
__name(debounce, "debounce");

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js
var MsgQueue = class {
  static {
    __name(this, "MsgQueue");
  }
  peerId;
  refcnt;
  network;
  _entries;
  _log;
  constructor(selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId;
    this.network = network;
    this.refcnt = 1;
    this._entries = [];
    this._log = logger4(selfPeerId, "msgqueue");
    this.sendEntries = functionDebounce(this.sendEntries.bind(this), wantlistSendDebounceMs);
  }
  addMessage(msg, options = {}) {
    if (msg.empty) {
      return;
    }
    void this.send(msg, options);
  }
  addEntries(entries, options = {}) {
    this._entries = this._entries.concat(entries);
    this.sendEntries(options);
  }
  sendEntries(options = {}) {
    if (this._entries.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    this._entries.forEach((entry) => {
      if (entry.cancel === true) {
        msg.cancel(entry.cid);
      } else {
        msg.addEntry(entry.cid, entry.priority);
      }
    });
    this._entries = [];
    this.addMessage(msg, options);
  }
  async send(msg, options = {}) {
    try {
      await this.network.connectTo(this.peerId, options);
    } catch (err) {
      this._log.error("cant connect to peer %p: %s", this.peerId, err.message);
      return;
    }
    this._log("sending message to peer %p", this.peerId);
    this.network.sendMessage(this.peerId, msg, options).catch((err) => {
      this._log.error("send error", err);
    });
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/want-manager/index.js
var WantManager = class {
  static {
    __name(this, "WantManager");
  }
  peers;
  wantlist;
  network;
  _peerId;
  _log;
  constructor(peerId, network, stats, libp2p) {
    this.peers = trackedMap({
      name: "ipfs_bitswap_want_manager_peers",
      metrics: libp2p.metrics
    });
    this.wantlist = new Wantlist(stats, libp2p);
    this.network = network;
    this._peerId = peerId;
    this._log = logger4(peerId, "want");
  }
  _addEntries(cids, cancel, force, options = {}) {
    const entries = cids.map((cid, i) => {
      return new BitswapMessage.Entry(cid, kMaxPriority - i, BitswapMessage.WantType.Block, cancel);
    });
    entries.forEach((e) => {
      if (e.cancel) {
        if (force === true) {
          this.wantlist.removeForce(e.cid.toString(base58btc));
        } else {
          this.wantlist.remove(e.cid);
        }
      } else {
        this._log("adding to wantlist");
        this.wantlist.add(e.cid, e.priority);
      }
    });
    for (const p of this.peers.values()) {
      p.addEntries(entries, options);
    }
  }
  _startPeerHandler(peerId) {
    let mq = this.peers.get(peerId.toString());
    if (mq != null) {
      mq.refcnt++;
      return;
    }
    mq = new MsgQueue(this._peerId, peerId, this.network);
    const fullwantlist = new BitswapMessage(true);
    for (const entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority);
    }
    mq.addMessage(fullwantlist);
    this.peers.set(peerId.toString(), mq);
    return mq;
  }
  _stopPeerHandler(peerId) {
    const mq = this.peers.get(peerId.toString());
    if (mq == null) {
      return;
    }
    mq.refcnt--;
    if (mq.refcnt > 0) {
      return;
    }
    this.peers.delete(peerId.toString());
  }
  /**
   * add all the cids to the wantlist
   */
  wantBlocks(cids, options = {}) {
    this._addEntries(cids, false, false, options);
    options.signal?.addEventListener("abort", () => {
      this.cancelWants(cids);
    });
  }
  /**
   * Remove blocks of all the given keys without respecting refcounts
   */
  unwantBlocks(cids) {
    this._log("unwant blocks: %s", cids.length);
    this._addEntries(cids, true, true);
  }
  /**
   * Cancel wanting all of the given keys
   */
  cancelWants(cids) {
    this._log("cancel wants: %s", cids.length);
    this._addEntries(cids, true);
  }
  /**
   * Returns a list of all currently connected peers
   */
  connectedPeers() {
    return Array.from(this.peers.keys());
  }
  connected(peerId) {
    this._startPeerHandler(peerId);
  }
  disconnected(peerId) {
    this._stopPeerHandler(peerId);
  }
  start() {
  }
  stop() {
    this.peers.forEach((mq) => {
      this.disconnected(mq.peerId);
    });
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/bitswap.js
var hashLoader = {
  async getHasher() {
    throw new Error("Not implemented");
  }
};
var defaultOptions2 = {
  maxInboundStreams: 1024,
  maxOutboundStreams: 1024,
  incomingStreamTimeout: 3e4,
  hashLoader,
  statsEnabled: false,
  statsComputeThrottleTimeout: 1e3,
  statsComputeThrottleMaxQueueSize: 1e3
};
var statsKeys = [
  "blocksReceived",
  "dataReceived",
  "dupBlksReceived",
  "dupDataReceived",
  "blocksSent",
  "dataSent",
  "providesBufferLength",
  "wantListLength",
  "peerCount"
];
var DefaultBitswap = class {
  static {
    __name(this, "DefaultBitswap");
  }
  _libp2p;
  _log;
  stats;
  network;
  blockstore;
  engine;
  wm;
  notifications;
  started;
  constructor(libp2p, blockstore, options = {}) {
    this._libp2p = libp2p;
    this._log = logger4(this.peerId);
    options = Object.assign({}, defaultOptions2, options);
    this.stats = new Stats(libp2p, statsKeys, {
      enabled: options.statsEnabled,
      computeThrottleTimeout: options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: options.statsComputeThrottleMaxQueueSize
    });
    this.network = new Network(libp2p, this, this.stats, {
      hashLoader: options.hashLoader,
      maxInboundStreams: options.maxInboundStreams,
      maxOutboundStreams: options.maxOutboundStreams,
      incomingStreamTimeout: options.incomingStreamTimeout
    });
    this.blockstore = blockstore;
    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this.stats, libp2p);
    this.wm = new WantManager(this.peerId, this.network, this.stats, libp2p);
    this.notifications = new Notifications(this.peerId);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  get peerId() {
    return this._libp2p.peerId;
  }
  /**
   * handle messages received through the network
   */
  async _receiveMessage(peerId, incoming) {
    try {
      await this.engine.messageReceived(peerId, incoming);
    } catch (err) {
      this._log("failed to receive message", incoming);
    }
    if (incoming.blocks.size === 0) {
      return;
    }
    const received = [];
    for (const [cidStr, data] of incoming.blocks.entries()) {
      const cid = CID3.parse(cidStr);
      received.push({
        wasWanted: this.wm.wantlist.contains(cid),
        cid,
        data
      });
    }
    this.wm.cancelWants(received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid));
    await Promise.all(received.map(async ({ cid, wasWanted, data }) => {
      await this._handleReceivedBlock(peerId, cid, data, wasWanted);
    }));
  }
  async _handleReceivedBlock(peerId, cid, data, wasWanted) {
    this._log("received block");
    const has = await this.blockstore.has(cid);
    this._updateReceiveCounters(peerId.toString(), cid, data, has);
    if (!wasWanted) {
      return;
    }
    await this.put(cid, data);
  }
  _updateReceiveCounters(peerIdStr, cid, data, exists3) {
    this.stats.push(peerIdStr, "blocksReceived", 1);
    this.stats.push(peerIdStr, "dataReceived", data.length);
    if (exists3) {
      this.stats.push(peerIdStr, "dupBlksReceived", 1);
      this.stats.push(peerIdStr, "dupDataReceived", data.length);
    }
  }
  /**
   * handle errors on the receiving channel
   */
  _receiveError(err) {
    this._log.error("ReceiveError", err);
  }
  /**
   * handle new peers
   */
  _onPeerConnected(peerId) {
    this.wm.connected(peerId);
  }
  /**
   * handle peers being disconnected
   */
  _onPeerDisconnected(peerId) {
    this.wm.disconnected(peerId);
    this.engine.peerDisconnected(peerId);
    this.stats.disconnected(peerId);
  }
  enableStats() {
    this.stats.enable();
  }
  disableStats() {
    this.stats.disable();
  }
  /**
   * Return the current wantlist for a given `peerId`
   */
  wantlistForPeer(peerId, _options) {
    return this.engine.wantlistForPeer(peerId);
  }
  /**
   * Return ledger information for a given `peerId`
   */
  ledgerForPeer(peerId) {
    return this.engine.ledgerForPeer(peerId);
  }
  /**
   * Fetch a given block by cid. If the block is in the local
   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.
   */
  async want(cid, options = {}) {
    const fetchFromNetwork = /* @__PURE__ */ __name(async (cid2, options2) => {
      this.wm.wantBlocks([cid2], options2);
      return this.notifications.wantBlock(cid2, options2);
    }, "fetchFromNetwork");
    let promptedNetwork = false;
    const loadOrFetchFromNetwork = /* @__PURE__ */ __name(async (cid2, options2) => {
      try {
        const block = await this.blockstore.get(cid2, options2);
        return block;
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
        if (!promptedNetwork) {
          promptedNetwork = true;
          this.network.findAndConnect(cid2, options2).catch((err2) => {
            this._log.error(err2);
          });
        }
        return await fetchFromNetwork(cid2, options2);
      }
    }, "loadOrFetchFromNetwork");
    const controller = new AbortController();
    const signal = anySignal([controller.signal, options.signal]);
    try {
      const block = await Promise.race([
        this.notifications.wantBlock(cid, {
          ...options,
          signal
        }),
        loadOrFetchFromNetwork(cid, {
          ...options,
          signal
        })
      ]);
      return block;
    } finally {
      controller.abort();
      signal.clear();
    }
  }
  /**
   * Removes the given CIDs from the wantlist independent of any ref counts.
   *
   * This will cause all outstanding promises for a given block to reject.
   *
   * If you want to cancel the want for a block without doing that, pass an
   * AbortSignal in to `.get` or `.getMany` and abort it.
   */
  unwant(cids) {
    const cidsArray = Array.isArray(cids) ? cids : [cids];
    this.wm.unwantBlocks(cidsArray);
    cidsArray.forEach((cid) => {
      this.notifications.unwantBlock(cid);
    });
  }
  /**
   * Removes the given keys from the want list. This may cause pending promises
   * for blocks to never resolve.  If you wish these promises to abort instead
   * call `unwant(cids)` instead.
   */
  cancelWants(cids) {
    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
  }
  /**
   * Put the given block to the underlying blockstore and
   * send it to nodes that have it in their wantlist.
   */
  async put(cid, block, _options) {
    await this.blockstore.put(cid, block);
    this.notify(cid, block);
  }
  /**
   * Put the given blocks to the underlying blockstore and
   * send it to nodes that have it them their wantlist.
   */
  async *putMany(source, options) {
    yield* this.blockstore.putMany(src_default10(source, ({ cid, block }) => {
      this.notify(cid, block);
    }), options);
  }
  /**
   * Sends notifications about the arrival of a block
   */
  notify(cid, block, options = {}) {
    this.notifications.hasBlock(cid, block);
    this.engine.receivedBlocks([{ cid, block }]);
    this.network.provide(cid, options).catch((err) => {
      this._log.error("Failed to provide: %s", err.message);
    });
  }
  /**
   * Get the current list of wants
   */
  getWantlist() {
    return this.wm.wantlist.entries();
  }
  /**
   * Get the current list of partners
   */
  get peers() {
    return this.engine.peers();
  }
  /**
   * Start the bitswap node
   */
  async start() {
    this.wm.start();
    await this.network.start();
    this.engine.start();
    this.started = true;
  }
  /**
   * Stop the bitswap node
   */
  async stop() {
    this.stats.stop();
    this.wm.stop();
    await this.network.stop();
    this.engine.stop();
    this.started = false;
  }
};

// node_modules/helia/node_modules/ipfs-bitswap/dist/src/index.js
var createBitswap = /* @__PURE__ */ __name((libp2p, blockstore, options = {}) => {
  return new DefaultBitswap(libp2p, blockstore, options);
}, "createBitswap");

// node_modules/helia/node_modules/multiformats/src/hashes/identity.js
var code5 = 0;
var name4 = "identity";
var encode21 = coerce;
var digest4 = /* @__PURE__ */ __name((input) => create3(code5, encode21(input)), "digest");
var identity7 = { code: code5, name: name4, encode: encode21, digest: digest4 };

// node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
__name(is, "is");
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
__name(isBuffer, "isBuffer");
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
__name(getObjectType, "getObjectType");

// node_modules/cborg/esm/lib/token.js
var Type = class {
  static {
    __name(this, "Type");
  }
  constructor(major, name14, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name14;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  static {
    __name(this, "Token");
  }
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder4 = new TextDecoder();
var textEncoder4 = new TextEncoder();
function isBuffer2(buf3) {
  return useBuffer && globalThis.Buffer.isBuffer(buf3);
}
__name(isBuffer2, "isBuffer");
function asU8A(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer2(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
__name(asU8A, "asU8A");
var toString6 = useBuffer ? (bytes3, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes3.subarray(start, end)).toString("utf8") : utf8Slice(bytes3, start, end);
} : (bytes3, start, end) => {
  return end - start > 64 ? textDecoder4.decode(bytes3.subarray(start, end)) : utf8Slice(bytes3, start, end);
};
var fromString6 = useBuffer ? (string8) => {
  return string8.length > 64 ? globalThis.Buffer.from(string8) : utf8ToBytes(string8);
} : (string8) => {
  return string8.length > 64 ? textEncoder4.encode(string8) : utf8ToBytes(string8);
};
var fromArray = /* @__PURE__ */ __name((arr) => {
  return Uint8Array.from(arr);
}, "fromArray");
var slice = useBuffer ? (bytes3, start, end) => {
  if (isBuffer2(bytes3)) {
    return new Uint8Array(bytes3.subarray(start, end));
  }
  return bytes3.slice(start, end);
} : (bytes3, start, end) => {
  return bytes3.slice(start, end);
};
var concat2 = useBuffer ? (chunks, length21) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length21));
} : (chunks, length21) => {
  const out = new Uint8Array(length21);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc3 = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
__name(compare, "compare");
function utf8ToBytes(string8, units = Infinity) {
  let codePoint;
  const length21 = string8.length;
  let leadSurrogate = null;
  const bytes3 = [];
  for (let i = 0; i < length21; ++i) {
    codePoint = string8.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        } else if (i + 1 === length21) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes3.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes3.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes3;
}
__name(utf8ToBytes, "utf8ToBytes");
function utf8Slice(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
__name(utf8Slice, "utf8Slice");
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
__name(decodeCodePointsArray, "decodeCodePointsArray");

// node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  static {
    __name(this, "Bl");
  }
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes3) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes3.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes3, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
        topChunk = alloc3(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes3, 0);
      } else {
        this.chunks.push(bytes3);
        this.maxCursor += bytes3.length;
      }
    }
    this.cursor += bytes3.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
__name(assertEnoughData, "assertEnoughData");

// node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint8, "readUint8");
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint16, "readUint16");
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint32, "readUint32");
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
__name(readUint64, "readUint64");
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
__name(decodeUint8, "decodeUint8");
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
__name(decodeUint16, "decodeUint16");
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
__name(decodeUint32, "decodeUint32");
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
__name(decodeUint64, "decodeUint64");
function encodeUint(buf3, token) {
  return encodeUintValue(buf3, 0, token.value);
}
__name(encodeUint, "encodeUint");
function encodeUintValue(buf3, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf3.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf3.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf3.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf3.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
__name(encodeUintValue, "encodeUintValue");
encodeUint.encodedSize = /* @__PURE__ */ __name(function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");
encodeUintValue.encodedSize = /* @__PURE__ */ __name(function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
}, "encodedSize");
encodeUint.compareTokens = /* @__PURE__ */ __name(function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
}, "compareTokens");

// node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
__name(decodeNegint8, "decodeNegint8");
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
__name(decodeNegint16, "decodeNegint16");
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
__name(decodeNegint32, "decodeNegint32");
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
__name(decodeNegint64, "decodeNegint64");
function encodeNegint(buf3, token) {
  const negint = token.value;
  const unsigned3 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf3, token.type.majorEncoded, unsigned3);
}
__name(encodeNegint, "encodeNegint");
encodeNegint.encodedSize = /* @__PURE__ */ __name(function encodedSize3(token) {
  const negint = token.value;
  const unsigned3 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned3 < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned3 < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned3 < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned3 < uintBoundaries[3]) {
    return 5;
  }
  return 9;
}, "encodedSize");
encodeNegint.compareTokens = /* @__PURE__ */ __name(function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
}, "compareTokens");

// node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length21) {
  assertEnoughData(data, pos, prefix + length21);
  const buf3 = slice(data, pos + prefix, pos + prefix + length21);
  return new Token(Type.bytes, buf3, prefix + length21);
}
__name(toToken, "toToken");
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
__name(decodeBytesCompact, "decodeBytesCompact");
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeBytes8, "decodeBytes8");
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeBytes16, "decodeBytes16");
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeBytes32, "decodeBytes32");
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
__name(decodeBytes64, "decodeBytes64");
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString6(token.value) : token.value;
  }
  return token.encodedBytes;
}
__name(tokenBytes, "tokenBytes");
function encodeBytes(buf3, token) {
  const bytes3 = tokenBytes(token);
  encodeUintValue(buf3, token.type.majorEncoded, bytes3.length);
  buf3.push(bytes3);
}
__name(encodeBytes, "encodeBytes");
encodeBytes.encodedSize = /* @__PURE__ */ __name(function encodedSize4(token) {
  const bytes3 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes3.length) + bytes3.length;
}, "encodedSize");
encodeBytes.compareTokens = /* @__PURE__ */ __name(function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
}, "compareTokens");
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
__name(compareBytes, "compareBytes");

// node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length21, options) {
  const totLength = prefix + length21;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString6(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
__name(toToken2, "toToken");
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
__name(decodeStringCompact, "decodeStringCompact");
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
__name(decodeString8, "decodeString8");
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
__name(decodeString16, "decodeString16");
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
__name(decodeString32, "decodeString32");
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
__name(decodeString64, "decodeString64");
var encodeString = encodeBytes;

// node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length21) {
  return new Token(Type.array, length21, prefix);
}
__name(toToken3, "toToken");
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
__name(decodeArrayCompact, "decodeArrayCompact");
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeArray8, "decodeArray8");
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeArray16, "decodeArray16");
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeArray32, "decodeArray32");
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
__name(decodeArray64, "decodeArray64");
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
__name(decodeArrayIndefinite, "decodeArrayIndefinite");
function encodeArray(buf3, token) {
  encodeUintValue(buf3, Type.array.majorEncoded, token.value);
}
__name(encodeArray, "encodeArray");
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = /* @__PURE__ */ __name(function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");

// node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length21) {
  return new Token(Type.map, length21, prefix);
}
__name(toToken4, "toToken");
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
__name(decodeMapCompact, "decodeMapCompact");
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeMap8, "decodeMap8");
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeMap16, "decodeMap16");
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeMap32, "decodeMap32");
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
__name(decodeMap64, "decodeMap64");
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
__name(decodeMapIndefinite, "decodeMapIndefinite");
function encodeMap(buf3, token) {
  encodeUintValue(buf3, Type.map.majorEncoded, token.value);
}
__name(encodeMap, "encodeMap");
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = /* @__PURE__ */ __name(function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");

// node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
__name(decodeTagCompact, "decodeTagCompact");
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
__name(decodeTag8, "decodeTag8");
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
__name(decodeTag16, "decodeTag16");
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
__name(decodeTag32, "decodeTag32");
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
__name(decodeTag64, "decodeTag64");
function encodeTag(buf3, token) {
  encodeUintValue(buf3, Type.tag.majorEncoded, token.value);
}
__name(encodeTag, "encodeTag");
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = /* @__PURE__ */ __name(function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");

// node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
__name(decodeUndefined, "decodeUndefined");
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
__name(decodeBreak, "decodeBreak");
function createToken(value, bytes3, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes3);
}
__name(createToken, "createToken");
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
__name(decodeFloat16, "decodeFloat16");
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
__name(decodeFloat32, "decodeFloat32");
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
__name(decodeFloat64, "decodeFloat64");
function encodeFloat(buf3, token, options) {
  const float = token.value;
  if (float === false) {
    buf3.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf3.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf3.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf3.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf3.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf3.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf3.push(ui8a.slice(0, 9));
    }
  }
}
__name(encodeFloat, "encodeFloat");
encodeFloat.encodedSize = /* @__PURE__ */ __name(function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
}, "encodedSize");
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
__name(encodeFloat16, "encodeFloat16");
function readFloat16(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
__name(readFloat16, "readFloat16");
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
__name(encodeFloat32, "encodeFloat32");
function readFloat32(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
__name(readFloat32, "readFloat32");
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
__name(encodeFloat64, "encodeFloat64");
function readFloat64(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
__name(readFloat64, "readFloat64");
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
__name(invalidMinor, "invalidMinor");
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
__name(errorer, "errorer");
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
__name(quickEncodeToken, "quickEncodeToken");

// node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
__name(makeCborEncoders, "makeCborEncoders");
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  static {
    __name(this, "Ref");
  }
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length21 = isMap ? obj.size : keys.length;
    if (!length21) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length21),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length21),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
__name(objectToTokens, "objectToTokens");
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
__name(sortMapEntries, "sortMapEntries");
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
__name(mapSorter, "mapSorter");
function tokensToEncoded(buf3, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf3, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options);
  }
}
__name(tokensToEncoded, "tokensToEncoded");
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf3 = new Bl(size);
      encoder2(buf3, tokens, options);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf3.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
__name(encodeCustom, "encodeCustom");
function encode22(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
__name(encode22, "encode");

// node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  static {
    __name(this, "Tokeniser");
  }
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
__name(tokenToArray, "tokenToArray");
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
__name(tokenToMap, "tokenToMap");
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
__name(tokensToObject, "tokensToObject");
function decode27(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
__name(decode27, "decode");

// node_modules/helia/node_modules/multiformats/src/bases/base36.js
var base364 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper4 = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/helia/node_modules/eventemitter3/index.mjs
var import_index4 = __toESM(require_eventemitter3(), 1);

// node_modules/helia/node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError4 = class extends Error {
  static {
    __name(this, "AbortError");
  }
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException = /* @__PURE__ */ __name((errorMessage) => globalThis.DOMException === void 0 ? new AbortError4(errorMessage) : new DOMException(errorMessage), "getDOMException");
var getAbortedReason = /* @__PURE__ */ __name((signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
}, "getAbortedReason");
function pTimeout(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
__name(pTimeout, "pTimeout");

// node_modules/helia/node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
__name(lowerBound, "lowerBound");

// node_modules/helia/node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  static {
    __name(this, "PriorityQueue");
  }
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var priority_queue_default = PriorityQueue;

// node_modules/helia/node_modules/p-queue/dist/index.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pending;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_throwOnAbort;
var _PQueue_onEvent;
var AbortError5 = class extends Error {
  static {
    __name(this, "AbortError");
  }
};
var PQueue = class extends import_index4.default {
  static {
    __name(this, "PQueue");
  }
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pending.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: priority_queue_default,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f"),
      ...options
    };
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(async () => {
        var _a;
        var _b, _c;
        __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _b++, _b), "f");
        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
            throw new AbortError5("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet2(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = /* @__PURE__ */ __name(function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
}, "_PQueue_doesIntervalAllowAnother_get"), _PQueue_doesConcurrentAllowAnother_get = /* @__PURE__ */ __name(function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_pending, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
}, "_PQueue_doesConcurrentAllowAnother_get"), _PQueue_next = /* @__PURE__ */ __name(function _PQueue_next2() {
  var _a;
  __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _a--, _a), "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, "_PQueue_next"), _PQueue_onResumeInterval = /* @__PURE__ */ __name(function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, "_PQueue_onResumeInterval"), _PQueue_isIntervalPaused_get = /* @__PURE__ */ __name(function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === void 0) {
    const delay = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, "_PQueue_isIntervalPaused_get"), _PQueue_tryToStartAnother = /* @__PURE__ */ __name(function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, "_PQueue_tryToStartAnother"), _PQueue_initializeIntervalIfNeeded = /* @__PURE__ */ __name(function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
}, "_PQueue_initializeIntervalIfNeeded"), _PQueue_onInterval = /* @__PURE__ */ __name(function _PQueue_onInterval2() {
  if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, "_PQueue_onInterval"), _PQueue_processQueue = /* @__PURE__ */ __name(function _PQueue_processQueue2() {
  while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, "_PQueue_processQueue"), _PQueue_throwOnAbort = /* @__PURE__ */ __name(async function _PQueue_throwOnAbort2(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError5("The task was aborted."));
    }, { once: true });
  });
}, "_PQueue_throwOnAbort"), _PQueue_onEvent = /* @__PURE__ */ __name(async function _PQueue_onEvent2(event, filter2) {
  return new Promise((resolve) => {
    const listener = /* @__PURE__ */ __name(() => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    }, "listener");
    this.on(event, listener);
  });
}, "_PQueue_onEvent");
var dist_default2 = PQueue;

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bytes.js
var empty7 = new Uint8Array(0);
function equals13(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals13, "equals");
function coerce7(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce7, "coerce");

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/vendor/base-x.js
function base7(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base7, "base");
var src7 = base7;
var _brrp__multiformats_scope_baseX7 = src7;
var base_x_default7 = _brrp__multiformats_scope_baseX7;

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base.js
var Encoder7 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder7 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or7(this, decoder);
  }
};
var ComposedDecoder7 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or7(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or7(left, right) {
  return new ComposedDecoder7({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or7, "or");
var Codec7 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder7(name14, prefix, baseEncode);
    this.decoder = new Decoder7(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from11({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec7(name14, prefix, encode79, decode97);
}
__name(from11, "from");
function baseX7({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default7(alphabet11, name14);
  return from11({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce7(decode97(text))
  });
}
__name(baseX7, "baseX");
function decode28(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode28, "decode");
function encode23(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode23, "encode");
function rfc46487({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from11({
    prefix,
    name: name14,
    encode(input) {
      return encode23(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode28(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc46487, "rfc4648");

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base32.js
var base327 = rfc46487({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper7 = rfc46487({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad7 = rfc46487({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper7 = rfc46487({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex7 = rfc46487({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper7 = rfc46487({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad7 = rfc46487({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper7 = rfc46487({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z7 = rfc46487({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base58.js
var base58btc7 = baseX7({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr7 = baseX7({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/vendor/varint.js
var encode_16 = encode24;
var MSB7 = 128;
var REST7 = 127;
var MSBALL6 = ~REST7;
var INT6 = Math.pow(2, 31);
function encode24(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT6) {
    out[offset++] = num & 255 | MSB7;
    num /= 128;
  }
  while (num & MSBALL6) {
    out[offset++] = num & 255 | MSB7;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode24.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode24, "encode");
var decode29 = read7;
var MSB$16 = 128;
var REST$16 = 127;
function read7(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$16);
  read7.bytes = counter - offset;
  return res;
}
__name(read7, "read");
var N17 = Math.pow(2, 7);
var N27 = Math.pow(2, 14);
var N37 = Math.pow(2, 21);
var N47 = Math.pow(2, 28);
var N57 = Math.pow(2, 35);
var N67 = Math.pow(2, 42);
var N77 = Math.pow(2, 49);
var N86 = Math.pow(2, 56);
var N96 = Math.pow(2, 63);
var length7 = /* @__PURE__ */ __name(function(value) {
  return value < N17 ? 1 : value < N27 ? 2 : value < N37 ? 3 : value < N47 ? 4 : value < N57 ? 5 : value < N67 ? 6 : value < N77 ? 7 : value < N86 ? 8 : value < N96 ? 9 : 10;
}, "length");
var varint7 = {
  encode: encode_16,
  decode: decode29,
  encodingLength: length7
};
var _brrp_varint6 = varint7;
var varint_default6 = _brrp_varint6;

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/varint.js
function decode30(data, offset = 0) {
  const code16 = varint_default6.decode(data, offset);
  return [code16, varint_default6.decode.bytes];
}
__name(decode30, "decode");
function encodeTo6(int, target, offset = 0) {
  varint_default6.encode(int, target, offset);
  return target;
}
__name(encodeTo6, "encodeTo");
function encodingLength7(int) {
  return varint_default6.encodingLength(int);
}
__name(encodingLength7, "encodingLength");

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/hashes/digest.js
function create6(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength7(code16);
  const digestOffset = sizeOffset + encodingLength7(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo6(code16, bytes3, 0);
  encodeTo6(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest6(code16, size, digest13, bytes3);
}
__name(create6, "create");
function decode31(multihash) {
  const bytes3 = coerce7(multihash);
  const [code16, sizeOffset] = decode30(bytes3);
  const [size, digestOffset] = decode30(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest6(code16, size, digest13, bytes3);
}
__name(decode31, "decode");
function equals14(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals13(a.bytes, data.bytes);
  }
}
__name(equals14, "equals");
var Digest6 = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js
function format6(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV06(bytes3, baseCache6(link), base42 ?? base58btc7.encoder);
    default:
      return toStringV16(bytes3, baseCache6(link), base42 ?? base327.encoder);
  }
}
__name(format6, "format");
var cache6 = /* @__PURE__ */ new WeakMap();
function baseCache6(cid) {
  const baseCache14 = cache6.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache6.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache6, "baseCache");
var CID6 = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create6(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals14(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format6(this, base42);
  }
  toJSON() {
    return { "/": format6(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID6(version4, code16, multihash.bytes));
    } else if (value[cidSymbol6] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode31(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE6) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID6(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE6, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce7(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode30(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE6;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes6(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache6(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes6(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc7;
      return [
        base58btc7.prefix,
        decoder.decode(`${base58btc7.prefix}${source}`)
      ];
    }
    case base58btc7.prefix: {
      const decoder = base42 ?? base58btc7;
      return [base58btc7.prefix, decoder.decode(source)];
    }
    case base327.prefix: {
      const decoder = base42 ?? base327;
      return [base327.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes6, "parseCIDtoBytes");
function toStringV06(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc7.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV06, "toStringV0");
function toStringV16(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV16, "toStringV1");
var DAG_PB_CODE6 = 112;
var SHA_256_CODE6 = 18;
function encodeCID6(version4, code16, multihash) {
  const codeOffset = encodingLength7(version4);
  const hashOffset = codeOffset + encodingLength7(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo6(version4, bytes3, 0);
  encodeTo6(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID6, "encodeCID");
var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@ipld/dag-pb/src/pb-decode.js
var textDecoder5 = new TextDecoder();
function decodeVarint(bytes3, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes3.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes3[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
__name(decodeVarint, "decodeVarint");
function decodeBytes(bytes3, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes3, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes3.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes3.subarray(offset, postOffset), postOffset];
}
__name(decodeBytes, "decodeBytes");
function decodeKey(bytes3, index) {
  let wire;
  [wire, index] = decodeVarint(bytes3, index);
  return [wire & 7, wire >> 3, index];
}
__name(decodeKey, "decodeKey");
function decodeLink(bytes3) {
  const link = {};
  const l = bytes3.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes3, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes3, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes3, index);
      link.Name = textDecoder5.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes3, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
__name(decodeLink, "decodeLink");
function decodeNode(bytes3) {
  const l = bytes3.length;
  let index = 0;
  let links = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes3, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes3, index);
      if (links) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links) {
        links = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes3, index);
      links.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links || [];
  return node;
}
__name(decodeNode, "decodeNode");

// node_modules/@ipld/dag-pb/src/pb-encode.js
var textEncoder5 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;

// node_modules/@ipld/dag-pb/src/util.js
var textEncoder6 = new TextEncoder();
function toByteView(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}
__name(toByteView, "toByteView");

// node_modules/@ipld/dag-pb/src/index.js
var code6 = 112;
function decode32(bytes3) {
  const buf3 = toByteView(bytes3);
  const pbn = decodeNode(buf3);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID6.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}
__name(decode32, "decode");

// node_modules/cborg/esm/lib/json/encode.js
var JSONEncoder = class extends Array {
  static {
    __name(this, "JSONEncoder");
  }
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf3) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf3.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf3.push([44]);
          } else {
            buf3.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf3, token) {
    this.prefix(buf3);
    const is3 = String(token.value);
    const isa = [];
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
    }
    buf3.push(isa);
  }
  [Type.negint.major](buf3, token) {
    this[Type.uint.major](buf3, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf3, token) {
    this.prefix(buf3);
    const byts = fromString6(JSON.stringify(token.value));
    buf3.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf3, _token) {
    this.prefix(buf3);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf3.push([91]);
  }
  [Type.map.major](buf3, _token) {
    this.prefix(buf3);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf3.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf3, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf3.push([93]);
        } else if (recurs.type === Type.map) {
          buf3.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf3);
    if (token.type.name === "true") {
      buf3.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf3.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf3.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is3 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf3.push(isa);
  }
};

// node_modules/cborg/esm/lib/json/decode.js
var Tokenizer = class {
  static {
    __name(this, "Tokenizer");
  }
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this.pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float = false;
    const swallow = /* @__PURE__ */ __name((chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    }, "swallow");
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i = this.pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i));
        this.pos = i + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this.pos;
    const chars = [];
    const readu4 = /* @__PURE__ */ __name(() => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    }, "readu4");
    const readUtf8Char = /* @__PURE__ */ __name(() => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this.pos += bytesPerSequence;
    }, "readUtf8Char");
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
};
function decode33(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode27(data, options);
}
__name(decode33, "decode");

// node_modules/helia/node_modules/multiformats/src/codecs/raw.js
var code7 = 85;

// node_modules/helia/dist/src/utils/dag-walkers.js
var dagPbWalker = {
  codec: code6,
  async *walk(block) {
    const node = decode32(block);
    yield* node.Links.map((l) => l.Hash);
  }
};
var rawWalker = {
  codec: code7,
  async *walk() {
  }
};
var CID_TAG = 42;
var cborWalker = {
  codec: 113,
  async *walk(block) {
    const cids = [];
    const tags = [];
    tags[CID_TAG] = (bytes3) => {
      if (bytes3[0] !== 0) {
        throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
      }
      const cid = CID3.decode(bytes3.subarray(1));
      cids.push(cid);
      return cid;
    };
    decode27(block, {
      tags
    });
    yield* cids;
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  static {
    __name(this, "DagJsonTokenizer");
  }
  tokenBuffer;
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   */
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes3 = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes3, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var jsonWalker = {
  codec: 297,
  async *walk(block) {
    const cids = [];
    const tags = [];
    tags[CID_TAG] = (string8) => {
      const cid = CID3.parse(string8);
      cids.push(cid);
      return cid;
    };
    decode33(block, {
      tags,
      tokenizer: new DagJsonTokenizer(block, {
        tags,
        allowIndefinite: true,
        allowUndefined: true,
        allowNaN: true,
        allowInfinity: true,
        allowBigInt: true,
        strict: false,
        rejectDuplicateMapKeys: false
      })
    });
    yield* cids;
  }
};

// node_modules/helia/dist/src/pins.js
var DEFAULT_DAG_WALKERS = [
  rawWalker,
  dagPbWalker,
  cborWalker,
  jsonWalker
];
var DATASTORE_PIN_PREFIX = "/pin/";
var DATASTORE_BLOCK_PREFIX = "/pinned-block/";
var DATASTORE_ENCODING = base364;
var DAG_WALK_QUEUE_CONCURRENCY = 1;
function toDSKey(cid) {
  if (cid.version === 0) {
    cid = cid.toV1();
  }
  return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);
}
__name(toDSKey, "toDSKey");
var PinsImpl = class {
  static {
    __name(this, "PinsImpl");
  }
  datastore;
  blockstore;
  dagWalkers;
  constructor(datastore, blockstore, dagWalkers) {
    this.datastore = datastore;
    this.blockstore = blockstore;
    this.dagWalkers = {};
    [...DEFAULT_DAG_WALKERS, ...dagWalkers].forEach((dagWalker) => {
      this.dagWalkers[dagWalker.codec] = dagWalker;
    });
  }
  async add(cid, options = {}) {
    const pinKey = toDSKey(cid);
    if (await this.datastore.has(pinKey)) {
      throw new Error("Already pinned");
    }
    const depth = Math.round(options.depth ?? Infinity);
    if (depth < 0) {
      throw new Error("Depth must be greater than or equal to 0");
    }
    const queue = new dist_default2({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    void queue.add(async () => {
      await this.#walkDag(cid, queue, (pinnedBlock) => {
        if (pinnedBlock.pinnedBy.find((c) => equals7(c, cid.bytes)) != null) {
          return;
        }
        pinnedBlock.pinCount++;
        pinnedBlock.pinnedBy.push(cid.bytes);
      }, {
        ...options,
        depth
      });
    });
    const deferred = pDefer();
    queue.on("error", (err) => {
      queue.clear();
      deferred.reject(err);
    });
    await Promise.race([
      queue.onIdle(),
      deferred.promise
    ]);
    const pin = {
      depth,
      metadata: options.metadata ?? {}
    };
    await this.datastore.put(pinKey, encode22(pin), options);
    return {
      cid,
      ...pin
    };
  }
  /**
   * Walk the DAG behind the passed CID, ensure all blocks are present in the blockstore
   * and update the pin count for them
   */
  async #walkDag(cid, queue, withPinnedBlock, options) {
    if (options.depth === -1) {
      return;
    }
    const dagWalker = this.dagWalkers[cid.code];
    if (dagWalker == null) {
      throw new Error(`No dag walker found for cid codec ${cid.code}`);
    }
    const block = await this.blockstore.get(cid, options);
    await this.#updatePinnedBlock(cid, withPinnedBlock, options);
    for await (const cid2 of dagWalker.walk(block)) {
      void queue.add(async () => {
        await this.#walkDag(cid2, queue, withPinnedBlock, {
          ...options,
          depth: options.depth - 1
        });
      });
    }
  }
  /**
   * Update the pin count for the CID
   */
  async #updatePinnedBlock(cid, withPinnedBlock, options) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    let pinnedBlock = {
      pinCount: 0,
      pinnedBy: []
    };
    try {
      pinnedBlock = decode27(await this.datastore.get(blockKey, options));
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    withPinnedBlock(pinnedBlock);
    if (pinnedBlock.pinCount === 0) {
      if (await this.datastore.has(blockKey)) {
        await this.datastore.delete(blockKey);
        return;
      }
    }
    await this.datastore.put(blockKey, encode22(pinnedBlock), options);
    options.onProgress?.(new CustomProgressEvent("helia:pin:add", { detail: cid }));
  }
  async rm(cid, options = {}) {
    const pinKey = toDSKey(cid);
    const buf3 = await this.datastore.get(pinKey, options);
    const pin = decode27(buf3);
    await this.datastore.delete(pinKey, options);
    const queue = new dist_default2({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    void queue.add(async () => {
      await this.#walkDag(cid, queue, (pinnedBlock) => {
        pinnedBlock.pinCount--;
        pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter((c) => equals7(c, cid.bytes));
      }, {
        ...options,
        depth: pin.depth
      });
    });
    await queue.onIdle();
    return {
      cid,
      ...pin
    };
  }
  async *ls(options = {}) {
    for await (const { key, value } of this.datastore.query({
      prefix: DATASTORE_PIN_PREFIX + (options.cid != null ? `${options.cid.toString(base364)}` : "")
    }, options)) {
      const cid = CID3.parse(key.toString().substring(5), base364);
      const pin = decode27(value);
      yield {
        cid,
        ...pin
      };
    }
  }
  async isPinned(cid, options = {}) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    return this.datastore.has(blockKey, options);
  }
};

// node_modules/p-queue/node_modules/eventemitter3/index.mjs
var import_index5 = __toESM(require_eventemitter32(), 1);

// node_modules/p-timeout/index.js
var TimeoutError2 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError6 = class extends Error {
  static {
    __name(this, "AbortError");
  }
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException2 = /* @__PURE__ */ __name((errorMessage) => globalThis.DOMException === void 0 ? new AbortError6(errorMessage) : new DOMException(errorMessage), "getDOMException");
var getAbortedReason2 = /* @__PURE__ */ __name((signal) => {
  const reason = signal.reason === void 0 ? getDOMException2("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException2(reason);
}, "getAbortedReason");
function pTimeout2(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason2(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason2(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError2();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
__name(pTimeout2, "pTimeout");

// node_modules/p-queue/dist/lower-bound.js
function lowerBound2(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
__name(lowerBound2, "lowerBound");

// node_modules/p-queue/dist/priority-queue.js
var PriorityQueue2 = class {
  static {
    __name(this, "PriorityQueue");
  }
  #queue = [];
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && this.#queue[this.size - 1].priority >= options.priority) {
      this.#queue.push(element);
      return;
    }
    const index = lowerBound2(this.#queue, element, (a, b) => b.priority - a.priority);
    this.#queue.splice(index, 0, element);
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options) {
    return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
};

// node_modules/p-queue/dist/index.js
var PQueue2 = class extends import_index5.default {
  static {
    __name(this, "PQueue");
  }
  #carryoverConcurrencyCount;
  #isIntervalIgnored;
  #intervalCount = 0;
  #intervalCap;
  #interval;
  #intervalEnd = 0;
  #intervalId;
  #timeoutId;
  #queue;
  #queueClass;
  #pending = 0;
  // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
  #concurrency;
  #isPaused;
  #throwOnTimeout;
  /**
      Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
  
      Applies to each future operation.
      */
  timeout;
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    super();
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue2,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
    }
    this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
    this.#intervalCap = options.intervalCap;
    this.#interval = options.interval;
    this.#queue = new options.queueClass();
    this.#queueClass = options.queueClass;
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    this.#throwOnTimeout = options.throwOnTimeout === true;
    this.#isPaused = options.autoStart === false;
  }
  get #doesIntervalAllowAnother() {
    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
  }
  get #doesConcurrentAllowAnother() {
    return this.#pending < this.#concurrency;
  }
  #next() {
    this.#pending--;
    this.#tryToStartAnother();
    this.emit("next");
  }
  #onResumeInterval() {
    this.#onInterval();
    this.#initializeIntervalIfNeeded();
    this.#timeoutId = void 0;
  }
  get #isIntervalPaused() {
    const now = Date.now();
    if (this.#intervalId === void 0) {
      const delay = this.#intervalEnd - now;
      if (delay < 0) {
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      } else {
        if (this.#timeoutId === void 0) {
          this.#timeoutId = setTimeout(() => {
            this.#onResumeInterval();
          }, delay);
        }
        return true;
      }
    }
    return false;
  }
  #tryToStartAnother() {
    if (this.#queue.size === 0) {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
      }
      this.#intervalId = void 0;
      this.emit("empty");
      if (this.#pending === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!this.#isPaused) {
      const canInitializeInterval = !this.#isIntervalPaused;
      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
        const job = this.#queue.dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          this.#initializeIntervalIfNeeded();
        }
        return true;
      }
    }
    return false;
  }
  #initializeIntervalIfNeeded() {
    if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
      return;
    }
    this.#intervalId = setInterval(() => {
      this.#onInterval();
    }, this.#interval);
    this.#intervalEnd = Date.now() + this.#interval;
  }
  #onInterval() {
    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
      clearInterval(this.#intervalId);
      this.#intervalId = void 0;
    }
    this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
    this.#processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  #processQueue() {
    while (this.#tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this.#concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    this.#concurrency = newConcurrency;
    this.#processQueue();
  }
  async #throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: this.#throwOnTimeout,
      ...options
    };
    return new Promise((resolve, reject) => {
      this.#queue.enqueue(async () => {
        this.#pending++;
        this.#intervalCount++;
        try {
          options.signal?.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout2(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError2 && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          this.#next();
        }
      }, options);
      this.emit("add");
      this.#tryToStartAnother();
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!this.#isPaused) {
      return this;
    }
    this.#isPaused = false;
    this.#processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this.#isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this.#queue = new this.#queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (this.#queue.size < limit) {
      return;
    }
    await this.#onEvent("next", () => this.#queue.size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (this.#pending === 0 && this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("idle");
  }
  async #onEvent(event, filter2) {
    return new Promise((resolve) => {
      const listener = /* @__PURE__ */ __name(() => {
        if (filter2 && !filter2()) {
          return;
        }
        this.off(event, listener);
        resolve();
      }, "listener");
      this.on(event, listener);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return this.#queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return this.#queue.filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return this.#pending;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this.#isPaused;
  }
};

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = /* @__PURE__ */ __name((worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
}, "observable");
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default11 = observable;

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/mortice/dist/src/utils.js
var nanoid = /* @__PURE__ */ __name((size = 21) => {
  return Math.random().toString().substring(2);
}, "nanoid");

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = /* @__PURE__ */ __name((emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          await new Promise((resolve) => {
            const releaseEventListener = /* @__PURE__ */ __name((event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            }, "releaseEventListener");
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
}, "handleWorkerLockRequest");
var makeWorkerLockRequest = /* @__PURE__ */ __name((name14, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name14
    });
    return new Promise((resolve) => {
      const listener = /* @__PURE__ */ __name((event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name14
            });
          });
        }
      }, "listener");
      globalThis.addEventListener("message", listener);
    });
  };
}, "makeWorkerLockRequest");
var defaultOptions3 = {
  singleProcess: false
};
var browser_default2 = /* @__PURE__ */ __name((options) => {
  options = Object.assign({}, defaultOptions3, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default11.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default11.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name14) => makeWorkerLockRequest(name14, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name14) => makeWorkerLockRequest(name14, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
}, "default");

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => pTimeout2((async () => {
    await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return p;
}
__name(createReleaseable, "createReleaseable");
var createMutex = /* @__PURE__ */ __name((name14, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name14, options),
      writeLock: implementation.writeLock(name14, options)
    };
  }
  const masterQueue = new PQueue2({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return createReleaseable(readQueue, options);
      }
      readQueue = new PQueue2({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock() {
      readQueue = null;
      return createReleaseable(masterQueue, options);
    }
  };
}, "createMutex");
var defaultOptions4 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions4, options);
  if (implementation == null) {
    implementation = browser_default2(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}
__name(createMortice, "createMortice");

// node_modules/helia/dist/src/storage.js
var BlockStorage = class {
  static {
    __name(this, "BlockStorage");
  }
  lock;
  child;
  pins;
  /**
   * Create a new BlockStorage
   */
  constructor(blockstore, pins, options = {}) {
    this.child = blockstore;
    this.pins = pins;
    this.lock = createMortice({
      singleProcess: options.holdGcLock
    });
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options = {}) {
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.put(cid, block, options);
    } finally {
      releaseLock();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options = {}) {
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.putMany(blocks, options);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options = {}) {
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.get(cid, options);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options = {}) {
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getMany(cids, options);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options = {}) {
    const releaseLock = await this.lock.writeLock();
    try {
      if (await this.pins.isPinned(cid)) {
        throw new Error("CID was pinned");
      }
      await this.child.delete(cid, options);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options = {}) {
    const releaseLock = await this.lock.writeLock();
    try {
      const storage2 = this;
      yield* this.child.deleteMany(async function* () {
        for await (const cid of cids) {
          if (await storage2.pins.isPinned(cid)) {
            throw new Error("CID was pinned");
          }
          yield cid;
        }
      }(), options);
    } finally {
      releaseLock();
    }
  }
  async has(cid, options = {}) {
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.has(cid, options);
    } finally {
      releaseLock();
    }
  }
  async *getAll(options = {}) {
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getAll(options);
    } finally {
      releaseLock();
    }
  }
};

// node_modules/uint8arrays/dist/src/from-string.js
function fromString7(string8, encoding = "utf8") {
  const base42 = bases_default3[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array2(globalThis.Buffer.from(string8, "utf-8"));
  }
  return base42.decoder.decode(`${base42.prefix}${string8}`);
}
__name(fromString7, "fromString");

// node_modules/helia/dist/src/utils/datastore-version.js
var DS_VERSION_KEY = new Key("/version");
var CURRENT_VERSION = 1;
async function assertDatastoreVersionIsCurrent(datastore) {
  if (!await datastore.has(DS_VERSION_KEY)) {
    await datastore.put(DS_VERSION_KEY, fromString7(`${CURRENT_VERSION}`));
    return;
  }
  const buf3 = await datastore.get(DS_VERSION_KEY);
  const str = toString5(buf3);
  const version4 = parseInt(str, 10);
  if (version4 !== CURRENT_VERSION) {
    throw new Error("Unknown datastore version, a datastore migration may be required");
  }
}
__name(assertDatastoreVersionIsCurrent, "assertDatastoreVersionIsCurrent");

// node_modules/helia/dist/src/utils/networked-storage.js
var NetworkedStorage = class {
  static {
    __name(this, "NetworkedStorage");
  }
  child;
  bitswap;
  /**
   * Create a new BlockStorage
   */
  constructor(blockstore, options = {}) {
    this.child = blockstore;
    this.bitswap = options.bitswap;
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options = {}) {
    if (await this.child.has(cid)) {
      options.onProgress?.(new CustomProgressEvent("blocks:put:duplicate", cid));
      return cid;
    }
    if (this.bitswap?.isStarted() === true) {
      options.onProgress?.(new CustomProgressEvent("blocks:put:bitswap:notify", cid));
      this.bitswap.notify(cid, block, options);
    }
    options.onProgress?.(new CustomProgressEvent("blocks:put:blockstore:put", cid));
    return this.child.put(cid, block, options);
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options = {}) {
    const missingBlocks = src_default4(blocks, async ({ cid }) => {
      const has = await this.child.has(cid);
      if (has) {
        options.onProgress?.(new CustomProgressEvent("blocks:put-many:duplicate", cid));
      }
      return !has;
    });
    const notifyEach = src_default10(missingBlocks, ({ cid, block }) => {
      options.onProgress?.(new CustomProgressEvent("blocks:put-many:bitswap:notify", cid));
      this.bitswap?.notify(cid, block, options);
    });
    options.onProgress?.(new CustomProgressEvent("blocks:put-many:blockstore:put-many"));
    yield* this.child.putMany(notifyEach, options);
  }
  /**
   * Get a block by cid
   */
  async get(cid, options = {}) {
    if (options.offline !== true && this.bitswap?.isStarted() != null && !await this.child.has(cid)) {
      options.onProgress?.(new CustomProgressEvent("blocks:get:bitswap:get", cid));
      const block = await this.bitswap.want(cid, options);
      options.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:put", cid));
      await this.child.put(cid, block, options);
      return block;
    }
    options.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:get", cid));
    return this.child.get(cid, options);
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options = {}) {
    options.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:get-many"));
    yield* this.child.getMany(src_default10(cids, async (cid) => {
      if (options.offline !== true && this.bitswap?.isStarted() === true && !await this.child.has(cid)) {
        options.onProgress?.(new CustomProgressEvent("blocks:get-many:bitswap:get", cid));
        const block = await this.bitswap.want(cid, options);
        options.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:put", cid));
        await this.child.put(cid, block, options);
      }
    }));
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options = {}) {
    options.onProgress?.(new CustomProgressEvent("blocks:delete:blockstore:delete", cid));
    await this.child.delete(cid, options);
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options = {}) {
    options.onProgress?.(new CustomProgressEvent("blocks:delete-many:blockstore:delete-many"));
    yield* this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cid;
      }
    }(), options);
  }
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  async *getAll(options = {}) {
    options.onProgress?.(new CustomProgressEvent("blocks:get-all:blockstore:get-many"));
    yield* this.child.getAll(options);
  }
};

// node_modules/helia/dist/src/helia.js
var log4 = logger("helia");
var HeliaImpl = class {
  static {
    __name(this, "HeliaImpl");
  }
  libp2p;
  blockstore;
  datastore;
  pins;
  #bitswap;
  constructor(init) {
    const hashers = [
      sha2562,
      sha5122,
      identity7,
      ...init.hashers ?? []
    ];
    this.#bitswap = createBitswap(init.libp2p, init.blockstore, {
      hashLoader: {
        getHasher: async (codecOrName) => {
          const hasher = hashers.find((hasher2) => {
            return hasher2.code === codecOrName || hasher2.name === codecOrName;
          });
          if (hasher != null) {
            return hasher;
          }
          throw new Error(`Could not load hasher for code/name "${codecOrName}"`);
        }
      }
    });
    const networkedStorage = new NetworkedStorage(init.blockstore, {
      bitswap: this.#bitswap
    });
    this.pins = new PinsImpl(init.datastore, networkedStorage, init.dagWalkers ?? []);
    this.libp2p = init.libp2p;
    this.blockstore = new BlockStorage(networkedStorage, this.pins, {
      holdGcLock: init.holdGcLock
    });
    this.datastore = init.datastore;
  }
  async start() {
    await assertDatastoreVersionIsCurrent(this.datastore);
    await this.#bitswap?.start();
    await this.libp2p.start();
  }
  async stop() {
    await this.libp2p.stop();
    await this.#bitswap?.stop();
  }
  async gc(options = {}) {
    const releaseLock = await this.blockstore.lock.writeLock();
    try {
      const helia = this;
      const blockstore = this.blockstore.unwrap();
      log4("gc start");
      await src_default2(blockstore.deleteMany(async function* () {
        for await (const { cid } of blockstore.getAll()) {
          try {
            if (await helia.pins.isPinned(cid, options)) {
              continue;
            }
            yield cid;
            options.onProgress?.(new CustomProgressEvent("helia:gc:deleted", cid));
          } catch (err) {
            log4.error("Error during gc", err);
            options.onProgress?.(new CustomProgressEvent("helia:gc:error", err));
          }
        }
      }()));
    } finally {
      releaseLock();
    }
    log4("gc finished");
  }
};

// node_modules/libp2p/dist/src/libp2p.js
var import_events7 = __toESM(require_events(), 1);

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var keys_exports2 = {};
__export(keys_exports2, {
  generateEphemeralKeyPair: () => ephemeral_keys_default,
  generateKeyPair: () => generateKeyPair4,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed2,
  importKey: () => importKey,
  keyStretcher: () => keyStretcher,
  keysPBM: () => keys_exports,
  marshalPrivateKey: () => marshalPrivateKey,
  marshalPublicKey: () => marshalPublicKey2,
  supportedKeys: () => supportedKeys,
  unmarshalPrivateKey: () => unmarshalPrivateKey3,
  unmarshalPublicKey: () => unmarshalPublicKey2
});
var import_asn12 = __toESM(require_asn1(), 1);
var import_pbe = __toESM(require_pbe(), 1);
var import_forge5 = __toESM(require_forge(), 1);

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var ed25519_class_exports = {};
__export(ed25519_class_exports, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  generateKeyPair: () => generateKeyPair,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey
});

// node_modules/@libp2p/crypto/node_modules/multiformats/vendor/base-x.js
function base9(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base9, "base");
var src8 = base9;
var _brrp__multiformats_scope_baseX8 = src8;
var base_x_default8 = _brrp__multiformats_scope_baseX8;

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bytes.js
var empty8 = new Uint8Array(0);
var coerce8 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base.js
var Encoder8 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder8 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or8(this, decoder);
  }
};
var ComposedDecoder8 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or8(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or8 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder8(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec8 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder8(name14, prefix, baseEncode);
    this.decoder = new Decoder8(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from12 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec8(name14, prefix, encode79, decode97), "from");
var baseX8 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default8(alphabet11, name14);
  return from12({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce8(decode97(text))
  });
}, "baseX");
var decode34 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode26 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc46488 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from12({
    prefix,
    name: name14,
    encode(input) {
      return encode26(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode34(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base58.js
var base58btc8 = baseX8({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr8 = baseX8({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/vendor/varint.js
var encode_17 = encode27;
var MSB8 = 128;
var REST8 = 127;
var MSBALL7 = ~REST8;
var INT7 = Math.pow(2, 31);
function encode27(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT7) {
    out[offset++] = num & 255 | MSB8;
    num /= 128;
  }
  while (num & MSBALL7) {
    out[offset++] = num & 255 | MSB8;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode27.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode27, "encode");
var decode35 = read8;
var MSB$17 = 128;
var REST$17 = 127;
function read8(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$17) << shift : (b & REST$17) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$17);
  read8.bytes = counter - offset;
  return res;
}
__name(read8, "read");
var N18 = Math.pow(2, 7);
var N28 = Math.pow(2, 14);
var N38 = Math.pow(2, 21);
var N48 = Math.pow(2, 28);
var N58 = Math.pow(2, 35);
var N68 = Math.pow(2, 42);
var N78 = Math.pow(2, 49);
var N87 = Math.pow(2, 56);
var N97 = Math.pow(2, 63);
var length8 = /* @__PURE__ */ __name(function(value) {
  return value < N18 ? 1 : value < N28 ? 2 : value < N38 ? 3 : value < N48 ? 4 : value < N58 ? 5 : value < N68 ? 6 : value < N78 ? 7 : value < N87 ? 8 : value < N97 ? 9 : 10;
}, "length");
var varint8 = {
  encode: encode_17,
  decode: decode35,
  encodingLength: length8
};
var _brrp_varint7 = varint8;
var varint_default7 = _brrp_varint7;

// node_modules/@libp2p/crypto/node_modules/multiformats/src/varint.js
var encodeTo7 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default7.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength8 = /* @__PURE__ */ __name((int) => {
  return varint_default7.encodingLength(int);
}, "encodingLength");

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/digest.js
var create7 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength8(code16);
  const digestOffset = sizeOffset + encodingLength8(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo7(code16, bytes3, 0);
  encodeTo7(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest7(code16, size, digest13, bytes3);
}, "create");
var Digest7 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/identity.js
var code8 = 0;
var name5 = "identity";
var encode28 = coerce8;
var digest5 = /* @__PURE__ */ __name((input) => create7(code8, encode28(input)), "digest");
var identity8 = { code: code8, name: name5, encode: encode28, digest: digest5 };

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/hasher.js
var from13 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher5(name14, code16, encode79), "from");
var Hasher5 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest13) => create7(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/sha2-browser.js
var sha5 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha2565 = from13({
  name: "sha2-256",
  code: 18,
  encode: sha5("SHA-256")
});
var sha5125 = from13({
  name: "sha2-512",
  code: 19,
  encode: sha5("SHA-512")
});

// node_modules/@noble/ed25519/lib/esm/index.js
var nodeCrypto = __toESM(require_crypto(), 1);
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class _ExtendedPoint {
  static {
    __name(this, "ExtendedPoint");
  }
  constructor(x, y2, z, t) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.t = t;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p.equals(Point.ZERO))
      return _ExtendedPoint.ZERO;
    return new _ExtendedPoint(p.x, p.y, _1n, mod2(p.x * p.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod2(X1 * Z2);
    const X2Z1 = mod2(X2 * Z1);
    const Y1Z2 = mod2(Y1 * Z2);
    const Y2Z1 = mod2(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new _ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a } = CURVE;
    const A = mod2(X1 * X1);
    const B = mod2(Y1 * Y1);
    const C = mod2(_2n * mod2(Z1 * Z1));
    const D = mod2(a * A);
    const x1y1 = X1 + Y1;
    const E = mod2(mod2(x1y1 * x1y1) - A - B);
    const G = D + B;
    const F = G - C;
    const H = D - B;
    const X3 = mod2(E * F);
    const Y3 = mod2(G * H);
    const T3 = mod2(E * H);
    const Z3 = mod2(F * G);
    return new _ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A = mod2((Y1 - X1) * (Y2 + X2));
    const B = mod2((Y1 + X1) * (Y2 - X2));
    const F = mod2(B - A);
    if (F === _0n)
      return this.double();
    const C = mod2(Z1 * _2n * T2);
    const D = mod2(T1 * _2n * Z2);
    const E = D + C;
    const G = B + A;
    const H = D - C;
    const X3 = mod2(E * F);
    const Y3 = mod2(G * H);
    const T3 = mod2(E * H);
    const Z3 = mod2(F * G);
    return new _ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p = this;
    let base42 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base42 = p;
      points.push(base42);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base42 = base42.add(p);
        points.push(base42);
      }
      p = base42.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(_ExtendedPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = _ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = _ExtendedPoint.ZERO;
    let f = _ExtendedPoint.BASE;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return _ExtendedPoint.normalizeZ([p, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar(scalar, CURVE.l, false);
    const G = _ExtendedPoint.BASE;
    const P0 = _ExtendedPoint.ZERO;
    if (n === _0n)
      return P0;
    if (this.equals(P0) || n === _1n)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p = P0;
    let d2 = this;
    while (n > _0n) {
      if (n & _1n)
        p = p.add(d2);
      d2 = d2.double();
      n >>= _1n;
    }
    return p;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(_ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    let p = this.multiplyUnsafe(CURVE.l / _2n).double();
    if (CURVE.l % _2n)
      p = p.add(this);
    return p.equals(_ExtendedPoint.ZERO);
  }
  toAffine(invZ) {
    const { x, y: y2, z } = this;
    const is0 = this.equals(_ExtendedPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z);
    const ax = mod2(x * invZ);
    const ay = mod2(y2 * invZ);
    const zz = mod2(z * invZ);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod2(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
__name(constTimeNegate, "constTimeNegate");
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
__name(assertExtPoint, "assertExtPoint");
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
__name(assertRstPoint, "assertRstPoint");
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
__name(legacyRist, "legacyRist");
var RistrettoPoint = class _RistrettoPoint {
  static {
    __name(this, "RistrettoPoint");
  }
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d: d2 } = CURVE;
    const r = mod2(SQRT_M1 * r0 * r0);
    const Ns = mod2((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod2((c - d2 * r) * mod2(r + d2));
    let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
    let s_ = mod2(s2 * r0);
    if (!edIsNegative(s_))
      s_ = mod2(-s_);
    if (!Ns_D_is_sq)
      s2 = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod2(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s22 = s2 * s2;
    const W0 = mod2((s2 + s2) * D);
    const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod2(_1n - s22);
    const W3 = mod2(_1n + s22);
    return new ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes(hex, 32);
    const { a, d: d2 } = CURVE;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s2 = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
      throw new Error(emsg);
    const s22 = mod2(s2 * s2);
    const u1 = mod2(_1n + a * s22);
    const u2 = mod2(_1n - a * s22);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v = mod2(a * d2 * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
    const Dx = mod2(I * u2);
    const Dy = mod2(I * Dx * v);
    let x = mod2((s2 + s2) * Dx);
    if (edIsNegative(x))
      x = mod2(-x);
    const y2 = mod2(u1 * Dy);
    const t = mod2(x * y2);
    if (!isValid || edIsNegative(t) || y2 === _0n)
      throw new Error(emsg);
    return new _RistrettoPoint(new ExtendedPoint(x, y2, _1n, t));
  }
  toRawBytes() {
    let { x, y: y2, z, t } = this.ep;
    const u1 = mod2(mod2(z + y2) * mod2(z - y2));
    const u2 = mod2(x * y2);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D2 * t);
    let D;
    if (edIsNegative(t * zInv)) {
      let _x = mod2(y2 * SQRT_M1);
      let _y = mod2(x * SQRT_M1);
      x = _x;
      y2 = _y;
      D = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (edIsNegative(x * zInv))
      y2 = mod2(-y2);
    let s2 = mod2((z - y2) * D);
    if (edIsNegative(s2))
      s2 = mod2(-s2);
    return numberTo32BytesLE(s2);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a = this.ep;
    const b = other.ep;
    const one = mod2(a.x * b.y) === mod2(a.y * b.x);
    const two = mod2(a.y * b.y) === mod2(a.x * b.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new _RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new _RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
};
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class _Point {
  static {
    __name(this, "Point");
  }
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d: d2, P } = CURVE;
    hex = ensureBytes(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y2 = bytesToNumberLE(normed);
    if (strict && y2 >= P)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y2 >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const y22 = mod2(y2 * y2);
    const u = mod2(y22 - _1n);
    const v = mod2(d2 * y22 + _1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x & _1n) === _1n;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x = mod2(-x);
    }
    return new _Point(x, y2);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes3 = numberTo32BytesLE(this.y);
    bytes3[31] |= this.x & _1n ? 128 : 0;
    return bytes3;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y: y2 } = this;
    const u = mod2((_1n + y2) * invert(_1n - y2));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new _Point(mod2(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
var Signature = class _Signature {
  static {
    __name(this, "Signature");
  }
  constructor(r, s2) {
    this.r = r;
    this.s = s2;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes3 = ensureBytes(hex, 64);
    const r = Point.fromHex(bytes3.slice(0, 32), false);
    const s2 = bytesToNumberLE(bytes3.slice(32, 64));
    return new _Signature(r, s2);
  }
  assertValidity() {
    const { r, s: s2 } = this;
    if (!(r instanceof Point))
      throw new Error("Expected Point instance");
    normalizeScalar(s2, CURVE.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length21 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length21);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
__name(concatBytes, "concatBytes");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
__name(bytesToHex, "bytesToHex");
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
__name(hexToBytes, "hexToBytes");
function numberTo32BytesBE(num) {
  const length21 = 32;
  const hex = num.toString(16).padStart(length21 * 2, "0");
  return hexToBytes(hex);
}
__name(numberTo32BytesBE, "numberTo32BytesBE");
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
__name(numberTo32BytesLE, "numberTo32BytesLE");
function edIsNegative(num) {
  return (mod2(num) & _1n) === _1n;
}
__name(edIsNegative, "edIsNegative");
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
__name(bytesToNumberLE, "bytesToNumberLE");
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes3) {
  return mod2(bytesToNumberLE(bytes3) & MAX_255B);
}
__name(bytes255ToNumberLE, "bytes255ToNumberLE");
function mod2(a, b = CURVE.P) {
  const res = a % b;
  return res >= _0n ? res : b + res;
}
__name(mod2, "mod");
function invert(number3, modulo = CURVE.P) {
  if (number3 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod2(number3, modulo);
  let b = modulo;
  let x = _0n, y2 = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m2 = x - u * q;
    const n = y2 - v * q;
    b = a, a = r, x = u, y2 = v, u = m2, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
__name(invert, "invert");
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod2(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod2(acc * tmp[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return tmp;
}
__name(invertBatch, "invertBatch");
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
__name(pow2, "pow2");
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n3 = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n3) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
__name(pow_2_252_3, "pow_2_252_3");
function uvRatio(u, v) {
  const v3 = mod2(v * v * v);
  const v7 = mod2(v3 * v3 * v);
  const pow3 = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod2(u * v3 * pow3);
  const vx2 = mod2(v * x * x);
  const root1 = x;
  const root2 = mod2(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u);
  const noRoot = vx2 === mod2(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod2(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
__name(uvRatio, "uvRatio");
function invertSqrt(number3) {
  return uvRatio(_1n, number3);
}
__name(invertSqrt, "invertSqrt");
function modlLE(hash3) {
  return mod2(bytesToNumberLE(hash3), CURVE.l);
}
__name(modlLE, "modlLE");
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
__name(equalBytes, "equalBytes");
function ensureBytes(hex, expectedLength) {
  const bytes3 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes3.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes3;
}
__name(ensureBytes, "ensureBytes");
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
__name(normalizeScalar, "normalizeScalar");
function adjustBytes25519(bytes3) {
  bytes3[0] &= 248;
  bytes3[31] &= 127;
  bytes3[31] |= 64;
  return bytes3;
}
__name(adjustBytes25519, "adjustBytes25519");
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
__name(checkPrivateKey, "checkPrivateKey");
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
__name(getKeyFromHash, "getKeyFromHash");
var _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
__name(getExtendedPublicKey, "getExtendedPublicKey");
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
__name(getPublicKey, "getPublicKey");
async function sign(message2, privateKey) {
  message2 = ensureBytes(message2);
  const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils.sha512(prefix, message2));
  const R = Point.BASE.multiply(r);
  const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message2));
  const s2 = mod2(r + k * scalar, CURVE.l);
  return new Signature(R, s2).toRawBytes();
}
__name(sign, "sign");
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes(message2);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r, s: s2 } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
  return { r, s: s2, SB, pub: publicKey, msg: message2 };
}
__name(prepareVerification, "prepareVerification");
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
__name(finishVerification, "finishVerification");
async function verify(sig, message2, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
__name(verify, "verify");
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  getExtendedPublicKey,
  mod: mod2,
  invert,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash3) => {
    hash3 = ensureBytes(hash3);
    if (hash3.length < 40 || hash3.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod2(bytesToNumberLE(hash3), CURVE.l - _1n) + _1n;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes: randomBytes4 } = crypto2.node;
      return new Uint8Array(randomBytes4(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.randomBytes(32);
  },
  sha512: async (...messages2) => {
    const message2 = concatBytes(...messages2);
    if (crypto2.web) {
      const buffer3 = await crypto2.web.subtle.digest("SHA-512", message2.buffer);
      return new Uint8Array(buffer3);
    } else if (crypto2.node) {
      return Uint8Array.from(crypto2.node.createHash("sha512").update(message2).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n);
    return cached;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
async function generateKey() {
  const privateKeyRaw = utils.randomPrivateKey();
  const publicKey = await getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
__name(generateKey, "generateKey");
async function generateKeyFromSeed(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey = await getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
__name(generateKeyFromSeed, "generateKeyFromSeed");
async function hashAndSign(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return sign(msg, privateKeyRaw);
}
__name(hashAndSign, "hashAndSign");
async function hashAndVerify(publicKey, sig, msg) {
  return verify(sig, msg, publicKey);
}
__name(hashAndVerify, "hashAndVerify");
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}
__name(concatKeys, "concatKeys");

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base64.js
var base647 = rfc46488({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad7 = rfc46488({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url7 = rfc46488({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad7 = rfc46488({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/uint8arrays/dist/src/concat.js
function concat3(arrays, length21) {
  if (length21 == null) {
    length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe6(length21);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output3);
}
__name(concat3, "concat");

// node_modules/@libp2p/crypto/dist/src/webcrypto.js
var webcrypto_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto == null || nativeCrypto.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
var derivedEmptyPasswordKey = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
function create8(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest13 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto5 = webcrypto_default.get();
  keyLength *= 8;
  async function encrypt3(data, password) {
    const salt = crypto5.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto5.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString7(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto5.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
        const runtimeDerivedEmptyPassword = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto5.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto5.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
      const rawKey = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto5.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto5.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat3([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  __name(encrypt3, "encrypt");
  async function decrypt3(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString7(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
        const runtimeDerivedEmptyPassword = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto5.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto5.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
      const rawKey = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto5.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto5.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  __name(decrypt3, "decrypt");
  const cipher = {
    encrypt: encrypt3,
    decrypt: decrypt3
  };
  return cipher;
}
__name(create8, "create");

// node_modules/@libp2p/crypto/dist/src/keys/exporter.js
async function exporter(privateKey, password) {
  const cipher = create8();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base647.encode(encryptedKey);
}
__name(exporter, "exporter");

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var keys_exports = {};
__export(keys_exports, {
  KeyType: () => KeyType,
  PrivateKey: () => PrivateKey,
  PublicKey: () => PublicKey
});
var KeyType;
(function(KeyType3) {
  KeyType3["RSA"] = "RSA";
  KeyType3["Ed25519"] = "Ed25519";
  KeyType3["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues3) {
  __KeyTypeValues3[__KeyTypeValues3["RSA"] = 0] = "RSA";
  __KeyTypeValues3[__KeyTypeValues3["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues3[__KeyTypeValues3["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType3) {
  KeyType3.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey3) {
  let _codec;
  PublicKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey3.encode = (obj) => {
    return encodeMessage(obj, PublicKey3.codec());
  };
  PublicKey3.decode = (buf3) => {
    return decodeMessage(buf3, PublicKey3.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey3) {
  let _codec;
  PrivateKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey3.encode = (obj) => {
    return encodeMessage(obj, PrivateKey3.codec());
  };
  PrivateKey3.decode = (buf3) => {
    return decodeMessage(buf3, PrivateKey3.codec());
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var Ed25519PublicKey = class {
  static {
    __name(this, "Ed25519PublicKey");
  }
  _key;
  constructor(key) {
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  async verify(data, sig) {
    return hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2565.digest(this.bytes);
    return bytes3;
  }
};
var Ed25519PrivateKey = class {
  static {
    __name(this, "Ed25519PrivateKey");
  }
  _key;
  _publicKey;
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  async sign(message2) {
    return hashAndSign(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2565.digest(this.bytes);
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const encoding = identity8.digest(this.public.bytes);
    return base58btc8.encode(encoding.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format14 = "libp2p-key") {
    if (format14 === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format14}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalEd25519PrivateKey(bytes3) {
  if (bytes3.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes3 = ensureKey(bytes3, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes3.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes3.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes3.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes3 = ensureKey(bytes3, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes3.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes3.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
__name(unmarshalEd25519PrivateKey, "unmarshalEd25519PrivateKey");
function unmarshalEd25519PublicKey(bytes3) {
  bytes3 = ensureKey(bytes3, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes3);
}
__name(unmarshalEd25519PublicKey, "unmarshalEd25519PublicKey");
async function generateKeyPair() {
  const { privateKey, publicKey } = await generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
__name(generateKeyPair, "generateKeyPair");
async function generateKeyPairFromSeed(seed) {
  const { privateKey, publicKey } = await generateKeyFromSeed(seed);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
__name(generateKeyPairFromSeed, "generateKeyPairFromSeed");
function ensureKey(key, length21) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length21) {
    throw new CodeError(`Key must be a Uint8Array of length ${length21}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
  }
  return key;
}
__name(ensureKey, "ensureKey");

// node_modules/@libp2p/crypto/dist/src/util.js
var import_util2 = __toESM(require_util(), 1);
var import_jsbn = __toESM(require_jsbn(), 1);
var import_forge = __toESM(require_forge(), 1);
function bigIntegerToUintBase64url(num, len) {
  let buf3 = Uint8Array.from(num.abs().toByteArray());
  buf3 = buf3[0] === 0 ? buf3.subarray(1) : buf3;
  if (len != null) {
    if (buf3.length > len)
      throw new Error("byte array longer than desired length");
    buf3 = concat3([new Uint8Array(len - buf3.length), buf3]);
  }
  return toString5(buf3, "base64url");
}
__name(bigIntegerToUintBase64url, "bigIntegerToUintBase64url");
function base64urlToBigInteger(str) {
  const buf3 = base64urlToBuffer(str);
  return new import_forge.default.jsbn.BigInteger(toString5(buf3, "base16"), 16);
}
__name(base64urlToBigInteger, "base64urlToBigInteger");
function base64urlToBuffer(str, len) {
  let buf3 = fromString7(str, "base64urlpad");
  if (len != null) {
    if (buf3.length > len)
      throw new Error("byte array longer than desired length");
    buf3 = concat3([new Uint8Array(len - buf3.length), buf3]);
  }
  return buf3;
}
__name(base64urlToBuffer, "base64urlToBuffer");

// node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js
var bits = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
var curveTypes = Object.keys(bits);
var names = curveTypes.join(" / ");
async function generateEphmeralKeyPair(curve) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, "ERR_INVALID_CURVE");
  }
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "ECDH",
    namedCurve: curve
  }, true, ["deriveBits"]);
  const genSharedKey = /* @__PURE__ */ __name(async (theirPub, forcePrivate) => {
    let privateKey;
    if (forcePrivate != null) {
      privateKey = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
        name: "ECDH",
        namedCurve: curve
      }, false, ["deriveBits"]);
    } else {
      privateKey = pair2.privateKey;
    }
    const key = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
      name: "ECDH",
      namedCurve: curve
    }, false, []);
    const buffer3 = await webcrypto_default.get().subtle.deriveBits({
      name: "ECDH",
      // @ts-expect-error namedCurve is missing from the types
      namedCurve: curve,
      public: key
    }, privateKey, bits[curve]);
    return new Uint8Array(buffer3, 0, buffer3.byteLength);
  }, "genSharedKey");
  const publicKey = await webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey);
  const ecdhKey = {
    key: marshalPublicKey(publicKey),
    genSharedKey
  };
  return ecdhKey;
}
__name(generateEphmeralKeyPair, "generateEphmeralKeyPair");
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
function marshalPublicKey(jwk) {
  if (jwk.crv == null || jwk.x == null || jwk.y == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  if (jwk.crv !== "P-256" && jwk.crv !== "P-384" && jwk.crv !== "P-521") {
    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[jwk.crv];
  return concat3([
    Uint8Array.from([4]),
    base64urlToBuffer(jwk.x, byteLen),
    base64urlToBuffer(jwk.y, byteLen)
  ], 1 + byteLen * 2);
}
__name(marshalPublicKey, "marshalPublicKey");
function unmarshalPublicKey(curve, key) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[curve];
  if (!equals7(key.subarray(0, 1), Uint8Array.from([4]))) {
    throw new CodeError("Cannot unmarshal public key - invalid key format", "ERR_INVALID_KEY_FORMAT");
  }
  return {
    kty: "EC",
    crv: curve,
    x: toString5(key.subarray(1, byteLen + 1), "base64url"),
    y: toString5(key.subarray(1 + byteLen), "base64url"),
    ext: true
  };
}
__name(unmarshalPublicKey, "unmarshalPublicKey");
var unmarshalPrivateKey = /* @__PURE__ */ __name((curve, key) => ({
  ...unmarshalPublicKey(curve, key.public),
  d: toString5(key.private, "base64url")
}), "unmarshalPrivateKey");

// node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js
var ephemeral_keys_default = generateEphmeralKeyPair;

// node_modules/@libp2p/crypto/dist/src/keys/importer.js
async function importer(privateKey, password) {
  const encryptedKey = base647.decode(privateKey);
  const cipher = create8();
  return cipher.decrypt(encryptedKey, password);
}
__name(importer, "importer");

// node_modules/@libp2p/crypto/dist/src/hmac/lengths.js
var lengths_default = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
};

// node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js
var hashTypes = {
  SHA1: "SHA-1",
  SHA256: "SHA-256",
  SHA512: "SHA-512"
};
var sign2 = /* @__PURE__ */ __name(async (key, data) => {
  const buf3 = await webcrypto_default.get().subtle.sign({ name: "HMAC" }, key, data);
  return new Uint8Array(buf3, 0, buf3.byteLength);
}, "sign");
async function create9(hashType, secret) {
  const hash3 = hashTypes[hashType];
  const key = await webcrypto_default.get().subtle.importKey("raw", secret, {
    name: "HMAC",
    hash: { name: hash3 }
  }, false, ["sign"]);
  return {
    async digest(data) {
      return sign2(key, data);
    },
    length: lengths_default[hashType]
  };
}
__name(create9, "create");

// node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js
var cipherMap = {
  "AES-128": {
    ivSize: 16,
    keySize: 16
  },
  "AES-256": {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    keySize: 32
  }
};
async function keyStretcher(cipherType, hash3, secret) {
  const cipher = cipherMap[cipherType];
  if (cipher == null) {
    const allowed = Object.keys(cipherMap).join(" / ");
    throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, "ERR_INVALID_CIPHER_TYPE");
  }
  if (hash3 == null) {
    throw new CodeError("missing hash type", "ERR_MISSING_HASH_TYPE");
  }
  const cipherKeySize = cipher.keySize;
  const ivSize = cipher.ivSize;
  const hmacKeySize = 20;
  const seed = fromString7("key expansion");
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
  const m2 = await create9(hash3, secret);
  let a = await m2.digest(seed);
  const result = [];
  let j = 0;
  while (j < resultLength) {
    const b = await m2.digest(concat3([a, seed]));
    let todo = b.length;
    if (j + todo > resultLength) {
      todo = resultLength - j;
    }
    result.push(b);
    j += todo;
    a = await m2.digest(a);
  }
  const half = resultLength / 2;
  const resultBuffer = concat3(result);
  const r1 = resultBuffer.subarray(0, half);
  const r2 = resultBuffer.subarray(half, resultLength);
  const createKey = /* @__PURE__ */ __name((res) => ({
    iv: res.subarray(0, ivSize),
    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),
    macKey: res.subarray(ivSize + cipherKeySize)
  }), "createKey");
  return {
    k1: createKey(r1),
    k2: createKey(r2)
  };
}
__name(keyStretcher, "keyStretcher");

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var rsa_class_exports = {};
__export(rsa_class_exports, {
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  fromJwk: () => fromJwk,
  generateKeyPair: () => generateKeyPair2,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey
});
var import_forge4 = __toESM(require_forge(), 1);
var import_sha512 = __toESM(require_sha512(), 1);

// node_modules/@noble/secp256k1/lib/esm/index.js
var nodeCrypto2 = __toESM(require_crypto(), 1);
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _8n2 = BigInt(8);
var CURVE2 = Object.freeze({
  a: _0n2,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n2,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest = /* @__PURE__ */ __name((a, b) => (a + b / _2n2) / b, "divNearest");
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k) {
    const { n } = CURVE2;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod3(k - c1 * a1 - c2 * a2, n);
    let k2 = mod3(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
      k1 = n - k1;
    if (k2neg)
      k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
  const { a, b } = CURVE2;
  const x2 = mod3(x * x);
  const x3 = mod3(x2 * x);
  return mod3(x3 + a * x + b);
}
__name(weierstrass, "weierstrass");
var USE_ENDOMORPHISM = CURVE2.a === _0n2;
var ShaError = class extends Error {
  static {
    __name(this, "ShaError");
  }
  constructor(message2) {
    super(message2);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
__name(assertJacPoint, "assertJacPoint");
var JacobianPoint = class _JacobianPoint {
  static {
    __name(this, "JacobianPoint");
  }
  constructor(x, y2, z) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  static fromAffine(p) {
    if (!(p instanceof Point2)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p.equals(Point2.ZERO))
      return _JacobianPoint.ZERO;
    return new _JacobianPoint(p.x, p.y, _1n2);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch2(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod3(Z1 * Z1);
    const Z2Z2 = mod3(Z2 * Z2);
    const U1 = mod3(X1 * Z2Z2);
    const U2 = mod3(X2 * Z1Z1);
    const S1 = mod3(mod3(Y1 * Z2) * Z2Z2);
    const S2 = mod3(mod3(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new _JacobianPoint(this.x, mod3(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod3(X1 * X1);
    const B = mod3(Y1 * Y1);
    const C = mod3(B * B);
    const x1b = X1 + B;
    const D = mod3(_2n2 * (mod3(x1b * x1b) - A - C));
    const E = mod3(_3n * A);
    const F = mod3(E * E);
    const X3 = mod3(F - _2n2 * D);
    const Y3 = mod3(E * (D - X3) - _8n2 * C);
    const Z3 = mod3(_2n2 * Y1 * Z1);
    return new _JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n2 || Y2 === _0n2)
      return this;
    if (X1 === _0n2 || Y1 === _0n2)
      return other;
    const Z1Z1 = mod3(Z1 * Z1);
    const Z2Z2 = mod3(Z2 * Z2);
    const U1 = mod3(X1 * Z2Z2);
    const U2 = mod3(X2 * Z1Z1);
    const S1 = mod3(mod3(Y1 * Z2) * Z2Z2);
    const S2 = mod3(mod3(Y2 * Z1) * Z1Z1);
    const H = mod3(U2 - U1);
    const r = mod3(S2 - S1);
    if (H === _0n2) {
      if (r === _0n2) {
        return this.double();
      } else {
        return _JacobianPoint.ZERO;
      }
    }
    const HH = mod3(H * H);
    const HHH = mod3(H * HH);
    const V2 = mod3(U1 * HH);
    const X3 = mod3(r * r - HHH - _2n2 * V2);
    const Y3 = mod3(r * (V2 - X3) - S1 * HHH);
    const Z3 = mod3(Z1 * Z2 * H);
    return new _JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = _JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n2)
      return P0;
    let n = normalizeScalar2(scalar);
    if (n === _1n2)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d3 = this;
      while (n > _0n2) {
        if (n & _1n2)
          p = p.add(d3);
        d3 = d3.double();
        n >>= _1n2;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
    let k1p = P0;
    let k2p = P0;
    let d2 = this;
    while (k1 > _0n2 || k2 > _0n2) {
      if (k1 & _1n2)
        k1p = k1p.add(d2);
      if (k2 & _1n2)
        k2p = k2p.add(d2);
      d2 = d2.double();
      k1 >>= _1n2;
      k2 >>= _1n2;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new _JacobianPoint(mod3(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base42 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base42 = p;
      points.push(base42);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base42 = base42.add(p);
        points.push(base42);
      }
      p = base42.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(_JacobianPoint.BASE))
      affinePoint = Point2.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = _JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes2.set(affinePoint, precomputes);
      }
    }
    let p = _JacobianPoint.ZERO;
    let f = _JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n2;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate2(cond2, precomputes[offset2]));
      }
    }
    return { p, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar2(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate2(k1neg, k1p);
      k2p = constTimeNegate2(k2neg, k2p);
      k2p = new _JacobianPoint(mod3(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f } = this.wNAF(n, affinePoint);
      point = p;
      fake = f;
    }
    return _JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x, y: y2, z } = this;
    const is0 = this.equals(_JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n2 : invert2(z);
    const iz1 = invZ;
    const iz2 = mod3(iz1 * iz1);
    const iz3 = mod3(iz2 * iz1);
    const ax = mod3(x * iz2);
    const ay = mod3(y2 * iz3);
    const zz = mod3(z * iz1);
    if (is0)
      return Point2.ZERO;
    if (zz !== _1n2)
      throw new Error("invZ was invalid");
    return new Point2(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE2.Gx, CURVE2.Gy, _1n2);
JacobianPoint.ZERO = new JacobianPoint(_0n2, _1n2, _0n2);
function constTimeNegate2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
__name(constTimeNegate2, "constTimeNegate");
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var Point2 = class _Point {
  static {
    __name(this, "Point");
  }
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes2.delete(this);
  }
  hasEvenY() {
    return this.y % _2n2 === _0n2;
  }
  static fromCompressedHex(bytes3) {
    const isShort = bytes3.length === 32;
    const x = bytesToNumber(isShort ? bytes3 : bytes3.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weierstrass(x);
    let y3 = sqrtMod(y2);
    const isYOdd = (y3 & _1n2) === _1n2;
    if (isShort) {
      if (isYOdd)
        y3 = mod3(-y3);
    } else {
      const isFirstByteOdd = (bytes3[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y3 = mod3(-y3);
    }
    const point = new _Point(x, y3);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes3) {
    const x = bytesToNumber(bytes3.subarray(1, fieldLen + 1));
    const y2 = bytesToNumber(bytes3.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new _Point(x, y2);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes3 = ensureBytes2(hex);
    const len = bytes3.length;
    const header = bytes3[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes3);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes3);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes3);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return _Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r, s: s2 } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h2 = truncateHash(ensureBytes2(msgHash));
    const { n } = CURVE2;
    const radj = recovery === 2 || recovery === 3 ? r + n : r;
    const rinv = invert2(radj, n);
    const u1 = mod3(-h2 * rinv, n);
    const u2 = mod3(s2 * rinv, n);
    const prefix = recovery & 1 ? "03" : "02";
    const R = _Point.fromHex(prefix + numTo32bStr(radj));
    const Q = _Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes2(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y: y2 } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y2))
      throw new Error(msg);
    const left = mod3(y2 * y2);
    const right = weierstrass(x);
    if (mod3(left - right) !== _0n2)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new _Point(this.x, mod3(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n2 || a === _1n2 || this !== _Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
Point2.ZERO = new Point2(_0n2, _0n2);
function sliceDER(s2) {
  return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
}
__name(sliceDER, "sliceDER");
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex2(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
__name(parseDERInt, "parseDERInt");
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex2(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex2(rBytesLeft)}`);
  }
  return { r, s: s2 };
}
__name(parseDERSignature, "parseDERSignature");
var Signature2 = class _Signature {
  static {
    __name(this, "Signature");
  }
  constructor(r, s2) {
    this.r = r;
    this.s = s2;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name14 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name14}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex2(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name14}: Expected 64-byte hex`);
    return new _Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s: s2 } = parseDERSignature(arr ? hex : hexToBytes2(hex));
    return new _Signature(r, s2);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s: s2 } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE2.n >> _1n2;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new _Signature(this.r, mod3(-this.s, CURVE2.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes2(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded(sHexL);
    const rLen = numberToHexUnpadded(rHexL);
    const length21 = numberToHexUnpadded(rHexL + sHexL + 4);
    return `30${length21}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes2(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes2(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length21 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length21);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
__name(concatBytes2, "concatBytes");
var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes2[uint8a[i]];
  }
  return hex;
}
__name(bytesToHex2, "bytesToHex");
var POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n2 <= num && num < POW_2_2562))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
}
__name(numTo32bStr, "numTo32bStr");
function numTo32b(num) {
  const b = hexToBytes2(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
__name(numTo32b, "numTo32b");
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
__name(numberToHexUnpadded, "numberToHexUnpadded");
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
__name(hexToNumber, "hexToNumber");
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
__name(hexToBytes2, "hexToBytes");
function bytesToNumber(bytes3) {
  return hexToNumber(bytesToHex2(bytes3));
}
__name(bytesToNumber, "bytesToNumber");
function ensureBytes2(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
}
__name(ensureBytes2, "ensureBytes");
function normalizeScalar2(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
__name(normalizeScalar2, "normalizeScalar");
function mod3(a, b = CURVE2.P) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
__name(mod3, "mod");
function pow22(x, power) {
  const { P } = CURVE2;
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= P;
  }
  return res;
}
__name(pow22, "pow2");
function sqrtMod(x) {
  const { P } = CURVE2;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow22(b3, _3n) * b3 % P;
  const b9 = pow22(b6, _3n) * b3 % P;
  const b11 = pow22(b9, _2n2) * b2 % P;
  const b22 = pow22(b11, _11n) * b11 % P;
  const b44 = pow22(b22, _22n) * b22 % P;
  const b88 = pow22(b44, _44n) * b44 % P;
  const b176 = pow22(b88, _88n) * b88 % P;
  const b220 = pow22(b176, _44n) * b44 % P;
  const b223 = pow22(b220, _3n) * b3 % P;
  const t1 = pow22(b223, _23n) * b22 % P;
  const t2 = pow22(t1, _6n) * b2 % P;
  const rt = pow22(t2, _2n2);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
}
__name(sqrtMod, "sqrtMod");
function invert2(number3, modulo = CURVE2.P) {
  if (number3 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod3(number3, modulo);
  let b = modulo;
  let x = _0n2, y2 = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m2 = x - u * q;
    const n = y2 - v * q;
    b = a, a = r, x = u, y2 = v, u = m2, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
__name(invert2, "invert");
function invertBatch2(nums, p = CURVE2.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n2)
      return acc;
    scratch[i] = acc;
    return mod3(acc * num, p);
  }, _1n2);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n2)
      return acc;
    scratch[i] = mod3(acc * scratch[i], p);
    return mod3(acc * num, p);
  }, inverted);
  return scratch;
}
__name(invertBatch2, "invertBatch");
function bits2int_2(bytes3) {
  const delta = bytes3.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes3);
  return delta > 0 ? num >> BigInt(delta) : num;
}
__name(bits2int_2, "bits2int_2");
function truncateHash(hash3, truncateOnly = false) {
  const h2 = bits2int_2(hash3);
  if (truncateOnly)
    return h2;
  const { n } = CURVE2;
  return h2 >= n ? h2 - n : h2;
}
__name(truncateHash, "truncateHash");
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  static {
    __name(this, "HmacDrbg");
  }
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils2.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
    this.v = await this.hmac(this.v);
    if (seed.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
};
function isWithinCurveOrder(num) {
  return _0n2 < num && num < CURVE2.n;
}
__name(isWithinCurveOrder, "isWithinCurveOrder");
function isValidFieldElement(num) {
  return _0n2 < num && num < CURVE2.P;
}
__name(isValidFieldElement, "isValidFieldElement");
function kmdToSig(kBytes, m2, d2, lowS = true) {
  const { n } = CURVE2;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert2(k, n);
  const q = Point2.BASE.multiply(k);
  const r = mod3(q.x, n);
  if (r === _0n2)
    return;
  const s2 = mod3(kinv * mod3(m2 + d2 * r, n), n);
  if (s2 === _0n2)
    return;
  let sig = new Signature2(r, s2);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n2);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
__name(kmdToSig, "kmdToSig");
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
__name(normalizePrivateKey, "normalizePrivateKey");
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point2) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point2.fromHex(publicKey);
  }
}
__name(normalizePublicKey, "normalizePublicKey");
function normalizeSignature(signature) {
  if (signature instanceof Signature2) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature2.fromDER(signature);
  } catch (error) {
    return Signature2.fromCompact(signature);
  }
}
__name(normalizeSignature, "normalizeSignature");
function getPublicKey2(privateKey, isCompressed = false) {
  return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
__name(getPublicKey2, "getPublicKey");
function bits2int(bytes3) {
  const slice3 = bytes3.length > fieldLen ? bytes3.slice(0, fieldLen) : bytes3;
  return bytesToNumber(slice3);
}
__name(bits2int, "bits2int");
function bits2octets(bytes3) {
  const z1 = bits2int(bytes3);
  const z2 = mod3(z1, CURVE2.n);
  return int2octets(z2 < _0n2 ? z1 : z2);
}
__name(bits2octets, "bits2octets");
function int2octets(num) {
  return numTo32b(num);
}
__name(int2octets, "int2octets");
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d2 = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d2), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils2.randomBytes(fieldLen);
    const e = ensureBytes2(extraEntropy);
    if (e.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e);
  }
  const seed = concatBytes2(...seedArgs);
  const m2 = bits2int(h1);
  return { seed, m: m2, d: d2 };
}
__name(initSigArgs, "initSigArgs");
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
__name(finalizeSig, "finalizeSig");
async function sign3(msgHash, privKey, opts = {}) {
  const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  await drbg.reseed(seed);
  let sig;
  while (!(sig = kmdToSig(await drbg.generate(), m2, d2, opts.canonical)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
__name(sign3, "sign");
var vopts = { strict: true };
function verify2(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes2(msgHash);
  } catch (error) {
    return false;
  }
  const { r, s: s2 } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h2 = truncateHash(msgHash);
  let P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  const { n } = CURVE2;
  const sinv = invert2(s2, n);
  const u1 = mod3(h2 * sinv, n);
  const u2 = mod3(r * sinv, n);
  const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R)
    return false;
  const v = mod3(R.x, n);
  return v === r;
}
__name(verify2, "verify");
Point2.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto2,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils2 = {
  bytesToHex: bytesToHex2,
  hexToBytes: hexToBytes2,
  concatBytes: concatBytes2,
  mod: mod3,
  invert: invert2,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash3) => {
    hash3 = ensureBytes2(hash3);
    const minLen = groupLen + 8;
    if (hash3.length < minLen || hash3.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num = mod3(bytesToNumber(hash3), CURVE2.n - _1n2) + _1n2;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes: randomBytes4 } = crypto3.node;
      return Uint8Array.from(randomBytes4(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils2.hashToPrivateKey(utils2.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point2.BASE) {
    const cached = point === Point2.BASE ? point : new Point2(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: async (...messages2) => {
    if (crypto3.web) {
      const buffer3 = await crypto3.web.subtle.digest("SHA-256", concatBytes2(...messages2));
      return new Uint8Array(buffer3);
    } else if (crypto3.node) {
      const { createHash } = crypto3.node;
      const hash3 = createHash("sha256");
      messages2.forEach((m2) => hash3.update(m2));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages2) => {
    if (crypto3.web) {
      const ckey = await crypto3.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message2 = concatBytes2(...messages2);
      const buffer3 = await crypto3.web.subtle.sign("HMAC", ckey, message2);
      return new Uint8Array(buffer3);
    } else if (crypto3.node) {
      const { createHmac } = crypto3.node;
      const hash3 = createHmac("sha256", key);
      messages2.forEach((m2) => hash3.update(m2));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages2) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils2.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils2.sha256(tagP, ...messages2);
  },
  taggedHashSync: (tag, ...messages2) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages2);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils2, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes(length21) {
  if (isNaN(length21) || length21 <= 0) {
    throw new CodeError("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  }
  return utils2.randomBytes(length21);
}
__name(randomBytes, "randomBytes");

// node_modules/@libp2p/crypto/dist/src/keys/jwk2pem.js
var import_rsa = __toESM(require_rsa(), 1);
var import_forge2 = __toESM(require_forge(), 1);
function convert(key, types) {
  return types.map((t) => base64urlToBigInteger(key[t]));
}
__name(convert, "convert");
function jwk2priv(key) {
  return import_forge2.default.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
}
__name(jwk2priv, "jwk2priv");
function jwk2pub(key) {
  return import_forge2.default.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
}
__name(jwk2pub, "jwk2pub");

// node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
var rsa_utils_exports = {};
__export(rsa_utils_exports, {
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkixToJwk: () => pkixToJwk
});
var import_asn1 = __toESM(require_asn1(), 1);
var import_rsa2 = __toESM(require_rsa(), 1);
var import_forge3 = __toESM(require_forge(), 1);
function pkcs1ToJwk(bytes3) {
  const asn1 = import_forge3.default.asn1.fromDer(toString5(bytes3, "ascii"));
  const privateKey = import_forge3.default.pki.privateKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: "RS256"
  };
}
__name(pkcs1ToJwk, "pkcs1ToJwk");
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge3.default.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return fromString7(import_forge3.default.asn1.toDer(asn1).getBytes(), "ascii");
}
__name(jwkToPkcs1, "jwkToPkcs1");
function pkixToJwk(bytes3) {
  const asn1 = import_forge3.default.asn1.fromDer(toString5(bytes3, "ascii"));
  const publicKey = import_forge3.default.pki.publicKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e)
  };
}
__name(pkixToJwk, "pkixToJwk");
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge3.default.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return fromString7(import_forge3.default.asn1.toDer(asn1).getBytes(), "ascii");
}
__name(jwkToPkix, "jwkToPkix");

// node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js
async function generateKey2(bits3) {
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits3,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
__name(generateKey2, "generateKey");
async function unmarshalPrivateKey2(key) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
__name(unmarshalPrivateKey2, "unmarshalPrivateKey");
async function hashAndSign2(key, msg) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
  return new Uint8Array(sig, 0, sig.byteLength);
}
__name(hashAndSign2, "hashAndSign");
async function hashAndVerify2(key, sig, msg) {
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
}
__name(hashAndVerify2, "hashAndVerify");
async function exportKey(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new CodeError("Private and public key are required", "ERR_INVALID_PARAMETERS");
  }
  return Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
__name(exportKey, "exportKey");
async function derivePublicFromPrivate(jwKey) {
  return webcrypto_default.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
__name(derivePublicFromPrivate, "derivePublicFromPrivate");
function convertKey(key, pub, msg, handle2) {
  const fkey = pub ? jwk2pub(key) : jwk2priv(key);
  const fmsg = toString5(Uint8Array.from(msg), "ascii");
  const fomsg = handle2(fmsg, fkey);
  return fromString7(fomsg, "ascii");
}
__name(convertKey, "convertKey");
function encrypt(key, msg) {
  return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
}
__name(encrypt, "encrypt");
function decrypt(key, msg) {
  return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
}
__name(decrypt, "decrypt");

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var RsaPublicKey = class {
  static {
    __name(this, "RsaPublicKey");
  }
  _key;
  constructor(key) {
    this._key = key;
  }
  async verify(data, sig) {
    return hashAndVerify2(this._key, sig, data);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(bytes3) {
    return encrypt(this._key, bytes3);
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2565.digest(this.bytes);
    return bytes3;
  }
};
var RsaPrivateKey = class {
  static {
    __name(this, "RsaPrivateKey");
  }
  _key;
  _publicKey;
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes(16);
  }
  async sign(message2) {
    return hashAndSign2(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw new CodeError("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  decrypt(bytes3) {
    return decrypt(this._key, bytes3);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2565.digest(this.bytes);
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash3 = await this.public.hash();
    return toString5(hash3, "base58btc");
  }
  /**
   * Exports the key into a password protected PEM format
   */
  async export(password, format14 = "pkcs-8") {
    if (format14 === "pkcs-8") {
      const buffer3 = new import_forge4.default.util.ByteBuffer(this.marshal());
      const asn1 = import_forge4.default.asn1.fromDer(buffer3);
      const privateKey = import_forge4.default.pki.privateKeyFromAsn1(asn1);
      const options = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return import_forge4.default.pki.encryptRsaPrivateKey(privateKey, password, options);
    } else if (format14 === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format14}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
async function unmarshalRsaPrivateKey(bytes3) {
  const jwk = rsa_utils_exports.pkcs1ToJwk(bytes3);
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
__name(unmarshalRsaPrivateKey, "unmarshalRsaPrivateKey");
function unmarshalRsaPublicKey(bytes3) {
  const jwk = rsa_utils_exports.pkixToJwk(bytes3);
  return new RsaPublicKey(jwk);
}
__name(unmarshalRsaPublicKey, "unmarshalRsaPublicKey");
async function fromJwk(jwk) {
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
__name(fromJwk, "fromJwk");
async function generateKeyPair2(bits3) {
  const keys = await generateKey2(bits3);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
__name(generateKeyPair2, "generateKeyPair");

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var secp256k1_class_exports = {};
__export(secp256k1_class_exports, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateKeyPair: () => generateKeyPair3,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey
});

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1.js
function generateKey3() {
  return utils2.randomPrivateKey();
}
__name(generateKey3, "generateKey");
async function hashAndSign3(key, msg) {
  const { digest: digest13 } = await sha2565.digest(msg);
  try {
    return await sign3(digest13, key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
__name(hashAndSign3, "hashAndSign");
async function hashAndVerify3(key, sig, msg) {
  try {
    const { digest: digest13 } = await sha2565.digest(msg);
    return verify2(sig, digest13, key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
__name(hashAndVerify3, "hashAndVerify");
function compressPublicKey(key) {
  const point = Point2.fromHex(key).toRawBytes(true);
  return point;
}
__name(compressPublicKey, "compressPublicKey");
function validatePrivateKey(key) {
  try {
    getPublicKey2(key, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
__name(validatePrivateKey, "validatePrivateKey");
function validatePublicKey(key) {
  try {
    Point2.fromHex(key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PUBLIC_KEY");
  }
}
__name(validatePublicKey, "validatePublicKey");
function computePublicKey(privateKey) {
  try {
    return getPublicKey2(privateKey, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
__name(computePublicKey, "computePublicKey");

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var Secp256k1PublicKey = class {
  static {
    __name(this, "Secp256k1PublicKey");
  }
  _key;
  constructor(key) {
    validatePublicKey(key);
    this._key = key;
  }
  async verify(data, sig) {
    return hashAndVerify3(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2565.digest(this.bytes);
    return bytes3;
  }
};
var Secp256k1PrivateKey = class {
  static {
    __name(this, "Secp256k1PrivateKey");
  }
  _key;
  _publicKey;
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  async sign(message2) {
    return hashAndSign3(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2565.digest(this.bytes);
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash3 = await this.public.hash();
    return toString5(hash3, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format14 = "libp2p-key") {
    if (format14 === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format14}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalSecp256k1PrivateKey(bytes3) {
  return new Secp256k1PrivateKey(bytes3);
}
__name(unmarshalSecp256k1PrivateKey, "unmarshalSecp256k1PrivateKey");
function unmarshalSecp256k1PublicKey(bytes3) {
  return new Secp256k1PublicKey(bytes3);
}
__name(unmarshalSecp256k1PublicKey, "unmarshalSecp256k1PublicKey");
async function generateKeyPair3() {
  const privateKeyBytes = generateKey3();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
__name(generateKeyPair3, "generateKeyPair");

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var supportedKeys = {
  rsa: rsa_class_exports,
  ed25519: ed25519_class_exports,
  secp256k1: secp256k1_class_exports
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
__name(unsupportedKey, "unsupportedKey");
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
__name(typeToKey, "typeToKey");
async function generateKeyPair4(type, bits3) {
  return typeToKey(type).generateKeyPair(bits3 ?? 2048);
}
__name(generateKeyPair4, "generateKeyPair");
async function generateKeyPairFromSeed2(type, seed, bits3) {
  if (type.toLowerCase() !== "ed25519") {
    throw new CodeError("Seed key derivation is unimplemented for RSA or secp256k1", "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
  }
  return generateKeyPairFromSeed(seed);
}
__name(generateKeyPairFromSeed2, "generateKeyPairFromSeed");
function unmarshalPublicKey2(buf3) {
  const decoded = PublicKey.decode(buf3);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
__name(unmarshalPublicKey2, "unmarshalPublicKey");
function marshalPublicKey2(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
__name(marshalPublicKey2, "marshalPublicKey");
async function unmarshalPrivateKey3(buf3) {
  const decoded = PrivateKey.decode(buf3);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
__name(unmarshalPrivateKey3, "unmarshalPrivateKey");
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
__name(marshalPrivateKey, "marshalPrivateKey");
async function importKey(encryptedKey, password) {
  try {
    const key2 = await importer(encryptedKey, password);
    return await unmarshalPrivateKey3(key2);
  } catch (_) {
  }
  const key = import_forge5.default.pki.decryptRsaPrivateKey(encryptedKey, password);
  if (key === null) {
    throw new CodeError("Cannot read the key, most likely the password is wrong or not a RSA key", "ERR_CANNOT_DECRYPT_PEM");
  }
  let der = import_forge5.default.asn1.toDer(import_forge5.default.pki.privateKeyToAsn1(key));
  der = fromString7(der.getBytes(), "ascii");
  return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
}
__name(importKey, "importKey");

// node_modules/@libp2p/interface-content-routing/dist/src/index.js
var contentRouting = Symbol.for("@libp2p/content-routing");

// node_modules/@libp2p/interface-peer-discovery/dist/src/index.js
var peerDiscovery = Symbol.for("@libp2p/peer-discovery");

// node_modules/@libp2p/interface-peer-routing/dist/src/index.js
var peerRouting = Symbol.for("@libp2p/peer-routing");

// node_modules/@libp2p/interfaces/dist/src/events.js
var EventEmitter6 = class extends EventTarget {
  static {
    __name(this, "EventEmitter");
  }
  #listeners = /* @__PURE__ */ new Map();
  listenerCount(type) {
    const listeners = this.#listeners.get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = this.#listeners.get(type);
    if (list == null) {
      list = [];
      this.#listeners.set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = this.#listeners.get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    this.#listeners.set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = this.#listeners.get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    this.#listeners.set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
var CustomEventPolyfill = class extends Event {
  static {
    __name(this, "CustomEventPolyfill");
  }
  /** Returns any custom data event was created with. Typically used for synthetic events. */
  detail;
  constructor(message2, data) {
    super(message2, data);
    this.detail = data?.detail;
  }
};
var CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;

// node_modules/@libp2p/crypto/dist/src/aes/ciphers-browser.js
var import_aes = __toESM(require_aes(), 1);
var import_forge6 = __toESM(require_forge(), 1);

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var import_pbkdf2 = __toESM(require_pbkdf2(), 1);
var import_util6 = __toESM(require_util(), 1);
var hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(password, salt, iterations, keySize2, hash3) {
  if (hash3 !== "sha1" && hash3 !== "sha2-256" && hash3 !== "sha2-512") {
    const types = Object.keys(hashName).join(" / ");
    throw new CodeError(`Hash '${hash3}' is unknown or not supported. Must be ${types}`, "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash3];
  const dek = (0, import_pbkdf2.default)(password, salt, iterations, keySize2, hasher);
  return import_util6.default.encode64(dek, null);
}
__name(pbkdf2, "pbkdf2");

// node_modules/@libp2p/keychain/node_modules/@libp2p/logger/dist/src/index.js
var import_debug2 = __toESM(require_browser(), 1);

// node_modules/@libp2p/keychain/node_modules/multiformats/vendor/base-x.js
function base11(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base11, "base");
var src9 = base11;
var _brrp__multiformats_scope_baseX9 = src9;
var base_x_default9 = _brrp__multiformats_scope_baseX9;

// node_modules/@libp2p/keychain/node_modules/multiformats/src/bytes.js
var empty9 = new Uint8Array(0);
var coerce9 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base.js
var Encoder9 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder9 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or9(this, decoder);
  }
};
var ComposedDecoder9 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or9(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or9 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder9(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec9 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder9(name14, prefix, baseEncode);
    this.decoder = new Decoder9(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from14 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec9(name14, prefix, encode79, decode97), "from");
var baseX9 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default9(alphabet11, name14);
  return from14({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce9(decode97(text))
  });
}, "baseX");
var decode37 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode29 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc46489 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from14({
    prefix,
    name: name14,
    encode(input) {
      return encode29(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode37(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base58.js
var base58btc9 = baseX9({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr9 = baseX9({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base32.js
var base328 = rfc46489({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper8 = rfc46489({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad8 = rfc46489({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper8 = rfc46489({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex8 = rfc46489({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper8 = rfc46489({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad8 = rfc46489({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper8 = rfc46489({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z8 = rfc46489({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/keychain/node_modules/multiformats/src/bases/base64.js
var base648 = rfc46489({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad8 = rfc46489({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url8 = rfc46489({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad8 = rfc46489({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/keychain/node_modules/@libp2p/logger/dist/src/index.js
import_debug2.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc9.baseEncode(v);
};
import_debug2.default.formatters.t = (v) => {
  return v == null ? "undefined" : base328.baseEncode(v);
};
import_debug2.default.formatters.m = (v) => {
  return v == null ? "undefined" : base648.baseEncode(v);
};
import_debug2.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug2.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug2.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug2.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger4(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger4, "createDisabledLogger");
function logger5(name14) {
  let trace = createDisabledLogger4(`${name14}:trace`);
  if (import_debug2.default.enabled(`${name14}:trace`) && import_debug2.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug2.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug2.default)(name14), {
    error: (0, import_debug2.default)(`${name14}:error`),
    trace
  });
}
__name(logger5, "logger");

// node_modules/@libp2p/interface-peer-id/dist/src/index.js
var symbol2 = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[symbol2]);
}
__name(isPeerId, "isPeerId");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58_exports4 = {};
__export(base58_exports4, {
  base58btc: () => base58btc10,
  base58flickr: () => base58flickr10
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js
function base12(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base12, "base");
var src10 = base12;
var _brrp__multiformats_scope_baseX10 = src10;
var base_x_default10 = _brrp__multiformats_scope_baseX10;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js
var empty10 = new Uint8Array(0);
var equals16 = /* @__PURE__ */ __name((aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}, "equals");
var coerce10 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");
var fromString8 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString");
var toString7 = /* @__PURE__ */ __name((b) => new TextDecoder().decode(b), "toString");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js
var Encoder10 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder10 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or10(this, decoder);
  }
};
var ComposedDecoder10 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or10(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or10 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder10(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec10 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder10(name14, prefix, baseEncode);
    this.decoder = new Decoder10(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from15 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec10(name14, prefix, encode79, decode97), "from");
var baseX10 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default10(alphabet11, name14);
  return from15({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce10(decode97(text))
  });
}, "baseX");
var decode38 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode30 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464810 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from15({
    prefix,
    name: name14,
    encode(input) {
      return encode30(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode38(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58btc10 = baseX10({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr10 = baseX10({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js
var identity_exports7 = {};
__export(identity_exports7, {
  identity: () => identity9
});
var identity9 = from15({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString7(buf3),
  decode: (str) => fromString8(str)
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js
var base2_exports4 = {};
__export(base2_exports4, {
  base2: () => base25
});
var base25 = rfc464810({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js
var base8_exports4 = {};
__export(base8_exports4, {
  base8: () => base84
});
var base84 = rfc464810({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js
var base10_exports4 = {};
__export(base10_exports4, {
  base10: () => base104
});
var base104 = baseX10({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js
var base16_exports4 = {};
__export(base16_exports4, {
  base16: () => base164,
  base16upper: () => base16upper4
});
var base164 = rfc464810({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper4 = rfc464810({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js
var base32_exports4 = {};
__export(base32_exports4, {
  base32: () => base329,
  base32hex: () => base32hex9,
  base32hexpad: () => base32hexpad9,
  base32hexpadupper: () => base32hexpadupper9,
  base32hexupper: () => base32hexupper9,
  base32pad: () => base32pad9,
  base32padupper: () => base32padupper9,
  base32upper: () => base32upper9,
  base32z: () => base32z9
});
var base329 = rfc464810({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper9 = rfc464810({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad9 = rfc464810({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper9 = rfc464810({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex9 = rfc464810({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper9 = rfc464810({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad9 = rfc464810({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper9 = rfc464810({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z9 = rfc464810({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js
var base36_exports4 = {};
__export(base36_exports4, {
  base36: () => base365,
  base36upper: () => base36upper5
});
var base365 = baseX10({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper5 = baseX10({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js
var base64_exports4 = {};
__export(base64_exports4, {
  base64: () => base649,
  base64pad: () => base64pad9,
  base64url: () => base64url9,
  base64urlpad: () => base64urlpad9
});
var base649 = rfc464810({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad9 = rfc464810({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url9 = rfc464810({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad9 = rfc464810({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports4 = {};
__export(base256emoji_exports4, {
  base256emoji: () => base256emoji4
});
var alphabet4 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars4 = (
  /** @type {string[]} */
  alphabet4.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes4 = (
  /** @type {number[]} */
  alphabet4.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode31(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars4[c];
    return p;
  }, "");
}
__name(encode31, "encode");
function decode39(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes4[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode39, "decode");
var base256emoji4 = from15({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode31,
  decode: decode39
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports4 = {};
__export(sha2_browser_exports4, {
  sha256: () => sha2566,
  sha512: () => sha5126
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js
var encode_18 = encode32;
var MSB9 = 128;
var REST9 = 127;
var MSBALL8 = ~REST9;
var INT8 = Math.pow(2, 31);
function encode32(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT8) {
    out[offset++] = num & 255 | MSB9;
    num /= 128;
  }
  while (num & MSBALL8) {
    out[offset++] = num & 255 | MSB9;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode32.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode32, "encode");
var decode40 = read9;
var MSB$18 = 128;
var REST$18 = 127;
function read9(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$18) << shift : (b & REST$18) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$18);
  read9.bytes = counter - offset;
  return res;
}
__name(read9, "read");
var N19 = Math.pow(2, 7);
var N29 = Math.pow(2, 14);
var N39 = Math.pow(2, 21);
var N49 = Math.pow(2, 28);
var N59 = Math.pow(2, 35);
var N69 = Math.pow(2, 42);
var N79 = Math.pow(2, 49);
var N88 = Math.pow(2, 56);
var N98 = Math.pow(2, 63);
var length9 = /* @__PURE__ */ __name(function(value) {
  return value < N19 ? 1 : value < N29 ? 2 : value < N39 ? 3 : value < N49 ? 4 : value < N59 ? 5 : value < N69 ? 6 : value < N79 ? 7 : value < N88 ? 8 : value < N98 ? 9 : 10;
}, "length");
var varint9 = {
  encode: encode_18,
  decode: decode40,
  encodingLength: length9
};
var _brrp_varint8 = varint9;
var varint_default8 = _brrp_varint8;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js
var decode41 = /* @__PURE__ */ __name((data, offset = 0) => {
  const code16 = varint_default8.decode(data, offset);
  return [code16, varint_default8.decode.bytes];
}, "decode");
var encodeTo8 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default8.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength9 = /* @__PURE__ */ __name((int) => {
  return varint_default8.encodingLength(int);
}, "encodingLength");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js
var create10 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength9(code16);
  const digestOffset = sizeOffset + encodingLength9(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo8(code16, bytes3, 0);
  encodeTo8(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest8(code16, size, digest13, bytes3);
}, "create");
var decode42 = /* @__PURE__ */ __name((multihash) => {
  const bytes3 = coerce10(multihash);
  const [code16, sizeOffset] = decode41(bytes3);
  const [size, digestOffset] = decode41(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest8(code16, size, digest13, bytes3);
}, "decode");
var equals17 = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals16(a.bytes, data.bytes);
  }
}, "equals");
var Digest8 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js
var from16 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher6(name14, code16, encode79), "from");
var Hasher6 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create10(this.code, result) : result.then((digest13) => create10(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha6 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha2566 = from16({
  name: "sha2-256",
  code: 18,
  encode: sha6("SHA-256")
});
var sha5126 = from16({
  name: "sha2-512",
  code: 19,
  encode: sha6("SHA-512")
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js
var identity_exports8 = {};
__export(identity_exports8, {
  identity: () => identity10
});
var code9 = 0;
var name6 = "identity";
var encode33 = coerce10;
var digest6 = /* @__PURE__ */ __name((input) => create10(code9, encode33(input)), "digest");
var identity10 = { code: code9, name: name6, encode: encode33, digest: digest6 };

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js
var textEncoder7 = new TextEncoder();
var textDecoder6 = new TextDecoder();

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js
var format7 = /* @__PURE__ */ __name((link, base42) => {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV07(
        bytes3,
        baseCache7(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base42 || base58btc10.encoder
      );
    default:
      return toStringV17(
        bytes3,
        baseCache7(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base42 || base329.encoder
      );
  }
}, "format");
var cache7 = /* @__PURE__ */ new WeakMap();
var baseCache7 = /* @__PURE__ */ __name((cid) => {
  const baseCache14 = cache7.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache7.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}, "baseCache");
var CID7 = class _CID {
  static {
    __name(this, "CID");
  }
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE7) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE7) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create10(code16, digest13);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals17(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base42) {
    return format7(this, base42);
  }
  toJSON() {
    return { "/": format7(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(
        version4,
        code16,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes3 || encodeCID7(version4, code16, multihash.bytes)
      );
    } else if (value[cidSymbol7] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode42(multihash)
      );
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE7) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`
          );
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID7(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE7, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce10(
      bytes3.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest13 = new Digest8(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest13
    ) : _CID.createV1(specs.codec, digest13);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode41(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE7
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes7(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache7(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes7 = /* @__PURE__ */ __name((source, base42) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 || base58btc10;
      return [
        /** @type {Prefix} */
        base58btc10.prefix,
        decoder.decode(`${base58btc10.prefix}${source}`)
      ];
    }
    case base58btc10.prefix: {
      const decoder = base42 || base58btc10;
      return [
        /** @type {Prefix} */
        base58btc10.prefix,
        decoder.decode(source)
      ];
    }
    case base329.prefix: {
      const decoder = base42 || base329;
      return [
        /** @type {Prefix} */
        base329.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base42 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base42.decode(source)
      ];
    }
  }
}, "parseCIDtoBytes");
var toStringV07 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  if (prefix !== base58btc10.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV0");
var toStringV17 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV1");
var DAG_PB_CODE7 = 112;
var SHA_256_CODE7 = 18;
var encodeCID7 = /* @__PURE__ */ __name((version4, code16, multihash) => {
  const codeOffset = encodingLength9(version4);
  const hashOffset = codeOffset + encodingLength9(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo8(version4, bytes3, 0);
  encodeTo8(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}, "encodeCID");
var cidSymbol7 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js
var bases4 = { ...identity_exports7, ...base2_exports4, ...base8_exports4, ...base10_exports4, ...base16_exports4, ...base32_exports4, ...base36_exports4, ...base58_exports4, ...base64_exports4, ...base256emoji_exports4 };
var hashes4 = { ...sha2_browser_exports4, ...identity_exports8 };

// node_modules/@libp2p/peer-id/dist/src/index.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases4).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases4.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  static {
    __name(this, "PeerIdImpl");
  }
  type;
  multihash;
  privateKey;
  publicKey;
  string;
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  [symbol2] = true;
  toString() {
    if (this.string == null) {
      this.string = base58btc10.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID7.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals7(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals7(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  static {
    __name(this, "RSAPeerIdImpl");
  }
  type = "RSA";
  publicKey;
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  static {
    __name(this, "Ed25519PeerIdImpl");
  }
  type = "Ed25519";
  publicKey;
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  static {
    __name(this, "Secp256k1PeerIdImpl");
  }
  type = "secp256k1";
  publicKey;
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromPeerId(other) {
  if (other.type === "RSA") {
    return new RSAPeerIdImpl(other);
  }
  if (other.type === "Ed25519") {
    return new Ed25519PeerIdImpl(other);
  }
  if (other.type === "secp256k1") {
    return new Secp256k1PeerIdImpl(other);
  }
  throw new CodeError("Not a PeerId", "ERR_INVALID_PARAMETERS");
}
__name(peerIdFromPeerId, "peerIdFromPeerId");
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode42(base58btc10.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
__name(peerIdFromString, "peerIdFromString");
function peerIdFromBytes(buf3) {
  try {
    const multihash = decode42(buf3);
    if (multihash.code === identity10.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha2566.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID7.decode(buf3));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
__name(peerIdFromBytes, "peerIdFromBytes");
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2566.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity10.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
__name(peerIdFromCID, "peerIdFromCID");
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create10(identity10.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create10(identity10.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha2566.digest(publicKey), publicKey, privateKey });
}
__name(peerIdFromKeys, "peerIdFromKeys");

// node_modules/merge-options/index.mjs
var import_index7 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index7.default;

// node_modules/@libp2p/keychain/dist/src/index.js
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// node_modules/@libp2p/keychain/dist/src/errors.js
var codes;
(function(codes8) {
  codes8["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes8["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes8["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes8["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes8["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes8["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes8["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes8["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes8["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes8["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes8["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes8["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes8["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes8["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes8["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
})(codes || (codes = {}));

// node_modules/@libp2p/keychain/dist/src/index.js
var log5 = logger5("libp2p:keychain");
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions5 = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name14) {
  if (name14 == null) {
    return false;
  }
  if (typeof name14 !== "string") {
    return false;
  }
  return name14 === (0, import_sanitize_filename.default)(name14.trim()) && name14.length > 0;
}
__name(validateKeyName, "validateKeyName");
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay = Math.random() * (max - min) + min;
  await new Promise((resolve) => setTimeout(resolve, delay));
}
__name(randomDelay, "randomDelay");
function DsName(name14) {
  return new Key(keyPrefix + name14);
}
__name(DsName, "DsName");
function DsInfoName(name14) {
  return new Key(infoPrefix + name14);
}
__name(DsInfoName, "DsInfoName");
var DefaultKeyChain = class {
  static {
    __name(this, "DefaultKeyChain");
  }
  components;
  init;
  /**
   * Creates a new instance of a key chain
   */
  constructor(components, init) {
    this.components = components;
    this.init = merge_options_default(defaultOptions5, init);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek });
  }
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const options = Object.assign({}, defaultOptions5);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString5(randomBytes(saltLength), "base64");
    return options;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions5;
  }
  /**
   * Create a new key.
   *
   * @param {string} name - The local key name; cannot already exist.
   * @param {string} type - One of the key types; 'rsa'.
   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only
   */
  async createKey(name14, type, size = 2048) {
    if (!validateKeyName(name14) || name14 === "self") {
      await randomDelay();
      throw new CodeError("Invalid key name", codes.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw new CodeError("Invalid key type", codes.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name14);
    const exists3 = await this.components.datastore.has(dsname);
    if (exists3) {
      await randomDelay();
      throw new CodeError("Key name already exists", codes.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw new CodeError("Invalid RSA key size", codes.ERR_INVALID_KEY_SIZE);
        }
        break;
      default:
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair4(type, size);
      const kid = await keypair.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name14,
        id: kid
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString7(pem));
      batch.put(DsInfoName(name14), fromString7(JSON.stringify(keyInfo)));
      await batch.commit();
    } catch (err) {
      await randomDelay();
      throw err;
    }
    return keyInfo;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString5(value.value)));
    }
    return info;
  }
  /**
   * Find a key by it's id
   */
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      const key = keys.find((k) => k.id === id);
      if (key == null) {
        throw new CodeError(`Key with id '${id}' does not exist.`, codes.ERR_KEY_NOT_FOUND);
      }
      return key;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Find a key by it's name.
   *
   * @param {string} name - The local key name.
   * @returns {Promise<KeyInfo>}
   */
  async findKeyByName(name14) {
    if (!validateKeyName(name14)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name14}'`, codes.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name14);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString5(res));
    } catch (err) {
      await randomDelay();
      log5.error(err);
      throw new CodeError(`Key '${name14}' does not exist.`, codes.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Remove an existing key.
   *
   * @param {string} name - The local key name; must already exist.
   * @returns {Promise<KeyInfo>}
   */
  async removeKey(name14) {
    if (!validateKeyName(name14) || name14 === "self") {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name14}'`, codes.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name14);
    const keyInfo = await this.findKeyByName(name14);
    const batch = this.components.datastore.batch();
    batch.delete(dsname);
    batch.delete(DsInfoName(name14));
    await batch.commit();
    return keyInfo;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw new CodeError(`Invalid old key name '${oldName}'`, codes.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw new CodeError(`Invalid new key name '${newName}'`, codes.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists3 = await this.components.datastore.has(newDsname);
    if (exists3) {
      await randomDelay();
      throw new CodeError(`Key '${newName}' already exists`, codes.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString5(res));
      keyInfo.name = newName;
      const batch = this.components.datastore.batch();
      batch.put(newDsname, pem);
      batch.put(newInfoName, fromString7(JSON.stringify(keyInfo)));
      batch.delete(oldDsname);
      batch.delete(oldInfoName);
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Export an existing key as a PEM encrypted PKCS #8 string
   */
  async exportKey(name14, password) {
    if (!validateKeyName(name14)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name14}'`, codes.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw new CodeError("Password is required", codes.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name14);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem = toString5(res);
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      return await privateKey.export(password);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Export an existing key as a PeerId
   */
  async exportPeerId(name14) {
    const password = "temporary-password";
    const pem = await this.exportKey(name14, password);
    const privateKey = await importKey(pem, password);
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  }
  /**
   * Import a new key from a PEM encoded PKCS #8 string
   *
   * @param {string} name - The local key name; must not already exist.
   * @param {string} pem - The PEM encoded PKCS #8 string
   * @param {string} password - The password.
   * @returns {Promise<KeyInfo>}
   */
  async importKey(name14, pem, password) {
    if (!validateKeyName(name14) || name14 === "self") {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name14}'`, codes.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw new CodeError("PEM encoded key is required", codes.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name14);
    const exists3 = await this.components.datastore.has(dsname);
    if (exists3) {
      await randomDelay();
      throw new CodeError(`Key '${name14}' already exists`, codes.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err) {
      await randomDelay();
      throw new CodeError("Cannot read the key, most likely the password is wrong", codes.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err) {
      await randomDelay();
      throw err;
    }
    const keyInfo = {
      name: name14,
      id: kid
    };
    const batch = this.components.datastore.batch();
    batch.put(dsname, fromString7(pem));
    batch.put(DsInfoName(name14), fromString7(JSON.stringify(keyInfo)));
    await batch.commit();
    return keyInfo;
  }
  /**
   * Import a peer key
   */
  async importPeer(name14, peer) {
    try {
      if (!validateKeyName(name14)) {
        throw new CodeError(`Invalid key name '${name14}'`, codes.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw new CodeError("PeerId is required", codes.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw new CodeError("PeerId.privKey is required", codes.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey3(peer.privateKey);
      const dsname = DsName(name14);
      const exists3 = await this.components.datastore.has(dsname);
      if (exists3) {
        await randomDelay();
        throw new CodeError(`Key '${name14}' already exists`, codes.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name14,
        id: peer.toString()
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString7(pem));
      batch.put(DsInfoName(name14), fromString7(JSON.stringify(keyInfo)));
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Gets the private key as PEM encoded PKCS #8 string
   */
  async getPrivateKey(name14) {
    if (!validateKeyName(name14)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name14}'`, codes.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name14);
      const res = await this.components.datastore.get(dsname);
      return toString5(res);
    } catch (err) {
      await randomDelay();
      log5.error(err);
      throw new CodeError(`Key '${name14}' does not exist.`, codes.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw new CodeError(`Invalid old pass type '${typeof oldPass}'`, codes.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw new CodeError(`Invalid new pass type '${typeof newPass}'`, codes.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw new CodeError(`Invalid pass length ${newPass.length}`, codes.ERR_INVALID_PASS_LENGTH);
    }
    log5("recreating keychain");
    const cached = privates.get(this);
    if (cached == null) {
      throw new CodeError("dek missing", codes.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString5(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch.put(DsName(key.name), fromString7(keyAsPEM));
      batch.put(DsInfoName(key.name), fromString7(JSON.stringify(keyInfo)));
      await batch.commit();
    }
    log5("keychain reconstructed");
  }
};

// node_modules/libp2p/node_modules/@libp2p/logger/dist/src/index.js
var import_debug3 = __toESM(require_browser(), 1);

// node_modules/libp2p/node_modules/multiformats/vendor/base-x.js
function base13(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base13, "base");
var src11 = base13;
var _brrp__multiformats_scope_baseX11 = src11;
var base_x_default11 = _brrp__multiformats_scope_baseX11;

// node_modules/libp2p/node_modules/multiformats/src/bytes.js
var empty11 = new Uint8Array(0);
var equals18 = /* @__PURE__ */ __name((aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}, "equals");
var coerce11 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/libp2p/node_modules/multiformats/src/bases/base.js
var Encoder11 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder11 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or11(this, decoder);
  }
};
var ComposedDecoder11 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or11(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or11 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder11(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec11 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder11(name14, prefix, baseEncode);
    this.decoder = new Decoder11(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from17 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec11(name14, prefix, encode79, decode97), "from");
var baseX11 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default11(alphabet11, name14);
  return from17({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce11(decode97(text))
  });
}, "baseX");
var decode43 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode34 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464811 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from17({
    prefix,
    name: name14,
    encode(input) {
      return encode34(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode43(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/libp2p/node_modules/multiformats/src/bases/base58.js
var base58btc11 = baseX11({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr11 = baseX11({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/libp2p/node_modules/multiformats/src/bases/base32.js
var base3210 = rfc464811({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper10 = rfc464811({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad10 = rfc464811({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper10 = rfc464811({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex10 = rfc464811({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper10 = rfc464811({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad10 = rfc464811({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper10 = rfc464811({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z10 = rfc464811({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/libp2p/node_modules/multiformats/src/bases/base64.js
var base6410 = rfc464811({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad10 = rfc464811({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url10 = rfc464811({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad10 = rfc464811({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/libp2p/node_modules/@libp2p/logger/dist/src/index.js
import_debug3.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc11.baseEncode(v);
};
import_debug3.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3210.baseEncode(v);
};
import_debug3.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6410.baseEncode(v);
};
import_debug3.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug3.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug3.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug3.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger5(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger5, "createDisabledLogger");
function logger6(name14) {
  let trace = createDisabledLogger5(`${name14}:trace`);
  if (import_debug3.default.enabled(`${name14}:trace`) && import_debug3.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug3.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug3.default)(name14), {
    error: (0, import_debug3.default)(`${name14}:error`),
    trace
  });
}
__name(logger6, "logger");

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map3) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map3(val)
      };
    }
  };
  return iterator;
}
__name(mapIterable, "mapIterable");

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  static {
    __name(this, "PeerMap");
  }
  map;
  constructor(map3) {
    this.map = /* @__PURE__ */ new Map();
    if (map3 != null) {
      for (const [key, value] of map3.entries()) {
        this.map.set(key.toString(), value);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), value);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  static {
    __name(this, "PeerSet");
  }
  set;
  constructor(set) {
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output3 = new _PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output3.add(peerId);
      }
    }
    return output3;
  }
  difference(other) {
    const output3 = new _PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output3.add(peerId);
      }
    }
    return output3;
  }
  union(other) {
    const output3 = new _PeerSet();
    for (const peerId of other) {
      output3.add(peerId);
    }
    for (const peerId of this) {
      output3.add(peerId);
    }
    return output3;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/list.js
var PeerList = class _PeerList {
  static {
    __name(this, "PeerList");
  }
  list;
  constructor(list) {
    this.list = [];
    if (list != null) {
      for (const value of list) {
        this.list.push(value.toString());
      }
    }
  }
  [Symbol.iterator]() {
    return mapIterable(this.list.entries(), (val) => {
      return peerIdFromString(val[1]);
    });
  }
  concat(list) {
    const output3 = new _PeerList(this);
    for (const value of list) {
      output3.push(value);
    }
    return output3;
  }
  entries() {
    return mapIterable(this.list.entries(), (val) => {
      return [val[0], peerIdFromString(val[1])];
    });
  }
  every(predicate) {
    return this.list.every((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  filter(predicate) {
    const output3 = new _PeerList();
    this.list.forEach((str, index) => {
      const peerId = peerIdFromString(str);
      if (predicate(peerId, index, this)) {
        output3.push(peerId);
      }
    });
    return output3;
  }
  find(predicate) {
    const str = this.list.find((str2, index) => {
      return predicate(peerIdFromString(str2), index, this);
    });
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  findIndex(predicate) {
    return this.list.findIndex((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  forEach(predicate) {
    this.list.forEach((str, index) => {
      predicate(peerIdFromString(str), index, this);
    });
  }
  includes(peerId) {
    return this.list.includes(peerId.toString());
  }
  indexOf(peerId) {
    return this.list.indexOf(peerId.toString());
  }
  pop() {
    const str = this.list.pop();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  push(...peerIds) {
    for (const peerId of peerIds) {
      this.list.push(peerId.toString());
    }
  }
  shift() {
    const str = this.list.shift();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  unshift(...peerIds) {
    let len = this.list.length;
    for (let i = peerIds.length - 1; i > -1; i--) {
      len = this.list.unshift(peerIds[i].toString());
    }
    return len;
  }
  get length() {
    return this.list.length;
  }
};

// node_modules/@libp2p/peer-id-factory/dist/src/proto.js
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.id != null) {
          w2.uint32(10);
          w2.bytes(obj.id);
        }
        if (obj.pubKey != null) {
          w2.uint32(18);
          w2.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          w2.uint32(26);
          w2.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader2.bytes();
              break;
            case 2:
              obj.pubKey = reader2.bytes();
              break;
            case 3:
              obj.privKey = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf3) => {
    return decodeMessage(buf3, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));

// node_modules/@libp2p/peer-id-factory/dist/src/index.js
var createEd25519PeerId = /* @__PURE__ */ __name(async () => {
  const key = await generateKeyPair4("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
}, "createEd25519PeerId");
async function createFromPrivKey(privateKey) {
  return peerIdFromKeys(marshalPublicKey2(privateKey.public), marshalPrivateKey(privateKey));
}
__name(createFromPrivKey, "createFromPrivKey");

// node_modules/@libp2p/peer-store/node_modules/@libp2p/logger/dist/src/index.js
var import_debug4 = __toESM(require_browser(), 1);

// node_modules/@libp2p/peer-store/node_modules/multiformats/vendor/base-x.js
function base14(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base14, "base");
var src12 = base14;
var _brrp__multiformats_scope_baseX12 = src12;
var base_x_default12 = _brrp__multiformats_scope_baseX12;

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bytes.js
var empty12 = new Uint8Array(0);
var coerce12 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base.js
var Encoder12 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder12 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or12(this, decoder);
  }
};
var ComposedDecoder12 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or12(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or12 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder12(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec12 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder12(name14, prefix, baseEncode);
    this.decoder = new Decoder12(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from18 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec12(name14, prefix, encode79, decode97), "from");
var baseX12 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default12(alphabet11, name14);
  return from18({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce12(decode97(text))
  });
}, "baseX");
var decode44 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode35 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464812 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from18({
    prefix,
    name: name14,
    encode(input) {
      return encode35(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode44(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base58.js
var base58btc12 = baseX12({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr12 = baseX12({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base32.js
var base3211 = rfc464812({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper11 = rfc464812({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad11 = rfc464812({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper11 = rfc464812({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex11 = rfc464812({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper11 = rfc464812({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad11 = rfc464812({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper11 = rfc464812({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z11 = rfc464812({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base64.js
var base6411 = rfc464812({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad11 = rfc464812({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url11 = rfc464812({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad11 = rfc464812({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-store/node_modules/@libp2p/logger/dist/src/index.js
import_debug4.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc12.baseEncode(v);
};
import_debug4.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3211.baseEncode(v);
};
import_debug4.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6411.baseEncode(v);
};
import_debug4.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug4.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug4.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug4.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger6(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger6, "createDisabledLogger");
function logger7(name14) {
  let trace = createDisabledLogger6(`${name14}:trace`);
  if (import_debug4.default.enabled(`${name14}:trace`) && import_debug4.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug4.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug4.default)(name14), {
    error: (0, import_debug4.default)(`${name14}:error`),
    trace
  });
}
__name(logger7, "logger");

// node_modules/byte-access/dist/src/index.js
function accessor(buf3) {
  if (buf3 instanceof Uint8Array) {
    return {
      get(index) {
        return buf3[index];
      },
      set(index, value) {
        buf3[index] = value;
      }
    };
  }
  return {
    get(index) {
      return buf3.get(index);
    },
    set(index, value) {
      buf3.set(index, value);
    }
  };
}
__name(accessor, "accessor");

// node_modules/longbits/dist/src/index.js
var TWO_322 = 4294967296;
var LongBits2 = class _LongBits {
  static {
    __name(this, "LongBits");
  }
  constructor(hi = 0, lo = 0) {
    this.hi = hi;
    this.lo = lo;
  }
  /**
   * Returns these hi/lo bits as a BigInt
   */
  toBigInt(unsigned3) {
    if (unsigned3 === true) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Returns these hi/lo bits as a Number - this may overflow, toBigInt
   * should be preferred
   */
  toNumber(unsigned3) {
    return Number(this.toBigInt(unsigned3));
  }
  /**
   * ZigZag decode a LongBits object
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    const hi = (this.hi >>> 1 ^ mask) >>> 0;
    return new _LongBits(hi, lo);
  }
  /**
   * ZigZag encode a LongBits object
   */
  zzEncode() {
    const mask = this.hi >> 31;
    const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    const lo = (this.lo << 1 ^ mask) >>> 0;
    return new _LongBits(hi, lo);
  }
  /**
   * Encode a LongBits object as a varint byte array
   */
  toBytes(buf3, offset = 0) {
    const access = accessor(buf3);
    while (this.hi > 0) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
      this.hi >>>= 7;
    }
    while (this.lo > 127) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = this.lo >>> 7;
    }
    access.set(offset++, this.lo);
  }
  /**
   * Parse a LongBits object from a BigInt
   */
  static fromBigInt(value) {
    if (value === 0n) {
      return new _LongBits();
    }
    const negative = value < 0;
    if (negative) {
      value = -value;
    }
    let hi = Number(value >> 32n) | 0;
    let lo = Number(value - (BigInt(hi) << 32n)) | 0;
    if (negative) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > TWO_322) {
        lo = 0;
        if (++hi > TWO_322) {
          hi = 0;
        }
      }
    }
    return new _LongBits(hi, lo);
  }
  /**
   * Parse a LongBits object from a Number
   */
  static fromNumber(value) {
    if (value === 0) {
      return new _LongBits();
    }
    const sign4 = value < 0;
    if (sign4) {
      value = -value;
    }
    let lo = value >>> 0;
    let hi = (value - lo) / 4294967296 >>> 0;
    if (sign4) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new _LongBits(hi, lo);
  }
  /**
   * Parse a LongBits object from a varint byte array
   */
  static fromBytes(buf3, offset = 0) {
    const access = accessor(buf3);
    const bits3 = new _LongBits();
    let i = 0;
    if (buf3.length - offset > 4) {
      for (; i < 4; ++i) {
        bits3.lo = (bits3.lo | (access.get(offset) & 127) << i * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits3;
        }
      }
      bits3.lo = (bits3.lo | (access.get(offset) & 127) << 28) >>> 0;
      bits3.hi = (bits3.hi | (access.get(offset) & 127) >> 4) >>> 0;
      if (access.get(offset++) < 128) {
        return bits3;
      }
      i = 0;
    } else {
      for (; i < 4; ++i) {
        if (offset >= buf3.length) {
          throw RangeError(`index out of range: ${offset} > ${buf3.length}`);
        }
        bits3.lo = (bits3.lo | (access.get(offset) & 127) << i * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits3;
        }
      }
    }
    if (buf3.length - offset > 4) {
      for (; i < 5; ++i) {
        bits3.hi = (bits3.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits3;
        }
      }
    } else if (offset < buf3.byteLength) {
      for (; i < 5; ++i) {
        if (offset >= buf3.length) {
          throw RangeError(`index out of range: ${offset} > ${buf3.length}`);
        }
        bits3.hi = (bits3.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits3;
        }
      }
    }
    throw RangeError("invalid varint encoding");
  }
};

// node_modules/@libp2p/peer-record/node_modules/uint8-varint/dist/src/index.js
var N110 = Math.pow(2, 7);
var N210 = Math.pow(2, 14);
var N310 = Math.pow(2, 21);
var N410 = Math.pow(2, 28);
var N510 = Math.pow(2, 35);
var N610 = Math.pow(2, 42);
var N710 = Math.pow(2, 49);
var N89 = Math.pow(2, 56);
var N99 = Math.pow(2, 63);
var unsigned = {
  encodingLength(value) {
    if (value < N110) {
      return 1;
    }
    if (value < N210) {
      return 2;
    }
    if (value < N310) {
      return 3;
    }
    if (value < N410) {
      return 4;
    }
    if (value < N510) {
      return 5;
    }
    if (value < N610) {
      return 6;
    }
    if (value < N710) {
      return 7;
    }
    if (value < N89) {
      return 8;
    }
    if (value < N99) {
      return 9;
    }
    return 10;
  },
  encode(value, buf3, offset = 0) {
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    if (buf3 == null) {
      buf3 = allocUnsafe6(unsigned.encodingLength(value));
    }
    LongBits2.fromNumber(value).toBytes(buf3, offset);
    return buf3;
  },
  decode(buf3, offset = 0) {
    return LongBits2.fromBytes(buf3, offset).toNumber(true);
  }
};

// node_modules/@libp2p/peer-record/dist/src/errors.js
var codes2 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w2.uint32(26);
          w2.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w2.uint32(42);
          w2.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.payloadType = reader2.bytes();
              break;
            case 3:
              obj.payload = reader2.bytes();
              break;
            case 5:
              obj.signature = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf3) => {
    return decodeMessage(buf3, Envelope2.codec());
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var RecordEnvelope = class _RecordEnvelope {
  static {
    __name(this, "RecordEnvelope");
  }
  /**
   * Unmarshal a serialized Envelope protobuf message
   */
  static createFromProtobuf = async (data) => {
    const envelopeData = Envelope.decode(data);
    const peerId = await peerIdFromKeys(envelopeData.publicKey);
    return new _RecordEnvelope({
      peerId,
      payloadType: envelopeData.payloadType,
      payload: envelopeData.payload,
      signature: envelopeData.signature
    });
  };
  /**
   * Seal marshals the given Record, places the marshaled bytes inside an Envelope
   * and signs it with the given peerId's private key
   */
  static seal = async (record, peerId) => {
    if (peerId.privateKey == null) {
      throw new Error("Missing private key");
    }
    const domain = record.domain;
    const payloadType = record.codec;
    const payload = record.marshal();
    const signData = formatSignaturePayload(domain, payloadType, payload);
    const key = await unmarshalPrivateKey3(peerId.privateKey);
    const signature = await key.sign(signData.subarray());
    return new _RecordEnvelope({
      peerId,
      payloadType,
      payload,
      signature
    });
  };
  /**
   * Open and certify a given marshalled envelope.
   * Data is unmarshalled and the signature validated for the given domain.
   */
  static openAndCertify = async (data, domain) => {
    const envelope = await _RecordEnvelope.createFromProtobuf(data);
    const valid = await envelope.validate(domain);
    if (!valid) {
      throw new CodeError("envelope signature is not valid for the given domain", codes2.ERR_SIGNATURE_NOT_VALID);
    }
    return envelope;
  };
  peerId;
  payloadType;
  payload;
  signature;
  marshaled;
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    const { peerId, payloadType, payload, signature } = init;
    this.peerId = peerId;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    return equals7(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey2(this.peerId.publicKey);
    return key.verify(signData.subarray(), this.signature);
  }
};
var formatSignaturePayload = /* @__PURE__ */ __name((domain, payloadType, payload) => {
  const domainUint8Array = fromString7(domain);
  const domainLength = unsigned.encode(domainUint8Array.byteLength);
  const payloadTypeLength = unsigned.encode(payloadType.length);
  const payloadLength = unsigned.encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
}, "formatSignaturePayload");

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort2 = /* @__PURE__ */ __name((a2, b2) => a2.toString().localeCompare(b2.toString()), "sort");
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index) => b[index].equals(item));
}
__name(arrayEquals, "arrayEquals");

// node_modules/@multiformats/multiaddr/node_modules/@libp2p/interface/dist/src/errors.js
var CodeError2 = class extends Error {
  static {
    __name(this, "CodeError");
  }
  code;
  props;
  constructor(message2, code16, props) {
    super(message2);
    this.code = code16;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports5 = {};
__export(base58_exports5, {
  base58btc: () => base58btc13,
  base58flickr: () => base58flickr13
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js
var empty13 = new Uint8Array(0);
function equals19(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals19, "equals");
function coerce13(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce13, "coerce");
function fromString9(str) {
  return new TextEncoder().encode(str);
}
__name(fromString9, "fromString");
function toString8(b) {
  return new TextDecoder().decode(b);
}
__name(toString8, "toString");

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js
function base15(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base15, "base");
var src13 = base15;
var _brrp__multiformats_scope_baseX13 = src13;
var base_x_default13 = _brrp__multiformats_scope_baseX13;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js
var Encoder13 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder13 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or13(this, decoder);
  }
};
var ComposedDecoder13 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or13(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or13(left, right) {
  return new ComposedDecoder13({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or13, "or");
var Codec13 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder13(name14, prefix, baseEncode);
    this.decoder = new Decoder13(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from19({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec13(name14, prefix, encode79, decode97);
}
__name(from19, "from");
function baseX13({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default13(alphabet11, name14);
  return from19({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce13(decode97(text))
  });
}
__name(baseX13, "baseX");
function decode45(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode45, "decode");
function encode36(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode36, "encode");
function rfc464813({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from19({
    prefix,
    name: name14,
    encode(input) {
      return encode36(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode45(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc464813, "rfc4648");

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js
var base58btc13 = baseX13({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr13 = baseX13({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports5 = {};
__export(base32_exports5, {
  base32: () => base3212,
  base32hex: () => base32hex12,
  base32hexpad: () => base32hexpad12,
  base32hexpadupper: () => base32hexpadupper12,
  base32hexupper: () => base32hexupper12,
  base32pad: () => base32pad12,
  base32padupper: () => base32padupper12,
  base32upper: () => base32upper12,
  base32z: () => base32z12
});
var base3212 = rfc464813({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper12 = rfc464813({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad12 = rfc464813({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper12 = rfc464813({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex12 = rfc464813({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper12 = rfc464813({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad12 = rfc464813({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper12 = rfc464813({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z12 = rfc464813({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js
var encode_19 = encode37;
var MSB10 = 128;
var REST10 = 127;
var MSBALL9 = ~REST10;
var INT9 = Math.pow(2, 31);
function encode37(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT9) {
    out[offset++] = num & 255 | MSB10;
    num /= 128;
  }
  while (num & MSBALL9) {
    out[offset++] = num & 255 | MSB10;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode37.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode37, "encode");
var decode46 = read10;
var MSB$19 = 128;
var REST$19 = 127;
function read10(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read10.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$19) << shift : (b & REST$19) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$19);
  read10.bytes = counter - offset;
  return res;
}
__name(read10, "read");
var N111 = Math.pow(2, 7);
var N211 = Math.pow(2, 14);
var N311 = Math.pow(2, 21);
var N411 = Math.pow(2, 28);
var N511 = Math.pow(2, 35);
var N611 = Math.pow(2, 42);
var N711 = Math.pow(2, 49);
var N810 = Math.pow(2, 56);
var N910 = Math.pow(2, 63);
var length10 = /* @__PURE__ */ __name(function(value) {
  return value < N111 ? 1 : value < N211 ? 2 : value < N311 ? 3 : value < N411 ? 4 : value < N511 ? 5 : value < N611 ? 6 : value < N711 ? 7 : value < N810 ? 8 : value < N910 ? 9 : 10;
}, "length");
var varint10 = {
  encode: encode_19,
  decode: decode46,
  encodingLength: length10
};
var _brrp_varint9 = varint10;
var varint_default9 = _brrp_varint9;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js
function decode47(data, offset = 0) {
  const code16 = varint_default9.decode(data, offset);
  return [code16, varint_default9.decode.bytes];
}
__name(decode47, "decode");
function encodeTo9(int, target, offset = 0) {
  varint_default9.encode(int, target, offset);
  return target;
}
__name(encodeTo9, "encodeTo");
function encodingLength10(int) {
  return varint_default9.encodingLength(int);
}
__name(encodingLength10, "encodingLength");

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js
function create11(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength10(code16);
  const digestOffset = sizeOffset + encodingLength10(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo9(code16, bytes3, 0);
  encodeTo9(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest9(code16, size, digest13, bytes3);
}
__name(create11, "create");
function decode48(multihash) {
  const bytes3 = coerce13(multihash);
  const [code16, sizeOffset] = decode47(bytes3);
  const [size, digestOffset] = decode47(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest9(code16, size, digest13, bytes3);
}
__name(decode48, "decode");
function equals20(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals19(a.bytes, data.bytes);
  }
}
__name(equals20, "equals");
var Digest9 = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js
function format8(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV08(bytes3, baseCache8(link), base42 ?? base58btc13.encoder);
    default:
      return toStringV18(bytes3, baseCache8(link), base42 ?? base3212.encoder);
  }
}
__name(format8, "format");
var cache8 = /* @__PURE__ */ new WeakMap();
function baseCache8(cid) {
  const baseCache14 = cache8.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache8.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache8, "baseCache");
var CID8 = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE8) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE8) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create11(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals20(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format8(this, base42);
  }
  toJSON() {
    return { "/": format8(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID8(version4, code16, multihash.bytes));
    } else if (value[cidSymbol8] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode48(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE8) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE8}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID8(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE8, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce13(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest9(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode47(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE8;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes8(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache8(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes8(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc13;
      return [
        base58btc13.prefix,
        decoder.decode(`${base58btc13.prefix}${source}`)
      ];
    }
    case base58btc13.prefix: {
      const decoder = base42 ?? base58btc13;
      return [base58btc13.prefix, decoder.decode(source)];
    }
    case base3212.prefix: {
      const decoder = base42 ?? base3212;
      return [base3212.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes8, "parseCIDtoBytes");
function toStringV08(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc13.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV08, "toStringV0");
function toStringV18(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV18, "toStringV1");
var DAG_PB_CODE8 = 112;
var SHA_256_CODE8 = 18;
function encodeCID8(version4, code16, multihash) {
  const codeOffset = encodingLength10(version4);
  const hashOffset = codeOffset + encodingLength10(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo9(version4, bytes3, 0);
  encodeTo9(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID8, "encodeCID");
var cidSymbol8 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js
function equals21(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
__name(equals21, "equals");

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports5 = {};
__export(base10_exports5, {
  base10: () => base105
});
var base105 = baseX13({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports5 = {};
__export(base16_exports5, {
  base16: () => base165,
  base16upper: () => base16upper5
});
var base165 = rfc464813({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper5 = rfc464813({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports5 = {};
__export(base2_exports5, {
  base2: () => base26
});
var base26 = rfc464813({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports5 = {};
__export(base256emoji_exports5, {
  base256emoji: () => base256emoji5
});
var alphabet5 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars5 = alphabet5.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes5 = alphabet5.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode38(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars5[c];
    return p;
  }, "");
}
__name(encode38, "encode");
function decode49(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes5[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode49, "decode");
var base256emoji5 = from19({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode38,
  decode: decode49
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports5 = {};
__export(base36_exports5, {
  base36: () => base366,
  base36upper: () => base36upper6
});
var base366 = baseX13({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper6 = baseX13({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports5 = {};
__export(base64_exports5, {
  base64: () => base6412,
  base64pad: () => base64pad12,
  base64url: () => base64url12,
  base64urlpad: () => base64urlpad12
});
var base6412 = rfc464813({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad12 = rfc464813({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url12 = rfc464813({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad12 = rfc464813({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports5 = {};
__export(base8_exports5, {
  base8: () => base85
});
var base85 = rfc464813({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports9 = {};
__export(identity_exports9, {
  identity: () => identity11
});
var identity11 = from19({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString8(buf3),
  decode: (str) => fromString9(str)
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder8 = new TextEncoder();
var textDecoder7 = new TextDecoder();

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports10 = {};
__export(identity_exports10, {
  identity: () => identity12
});
var code10 = 0;
var name7 = "identity";
var encode39 = coerce13;
function digest7(input) {
  return create11(code10, encode39(input));
}
__name(digest7, "digest");
var identity12 = { code: code10, name: name7, encode: encode39, digest: digest7 };

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports5 = {};
__export(sha2_browser_exports5, {
  sha256: () => sha2567,
  sha512: () => sha5127
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js
function from20({ name: name14, code: code16, encode: encode79 }) {
  return new Hasher7(name14, code16, encode79);
}
__name(from20, "from");
var Hasher7 = class {
  static {
    __name(this, "Hasher");
  }
  name;
  code;
  encode;
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create11(this.code, result) : result.then((digest13) => create11(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha7(name14) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name14, data));
}
__name(sha7, "sha");
var sha2567 = from20({
  name: "sha2-256",
  code: 18,
  encode: sha7("SHA-256")
});
var sha5127 = from20({
  name: "sha2-512",
  code: 19,
  encode: sha7("SHA-512")
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js
var bases5 = { ...identity_exports9, ...base2_exports5, ...base8_exports5, ...base10_exports5, ...base16_exports5, ...base32_exports5, ...base36_exports5, ...base58_exports5, ...base64_exports5, ...base256emoji_exports5 };
var hashes5 = { ...sha2_browser_exports5, ...identity_exports10 };

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe7(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe7, "allocUnsafe");

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec5(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: {
      decode: decode97
    }
  };
}
__name(createCodec5, "createCodec");
var string4 = createCodec5("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii4 = createCodec5("ascii", "a", (buf3) => {
  let string8 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string8 += String.fromCharCode(buf3[i]);
  }
  return string8;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe7(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES4 = {
  utf8: string4,
  "utf-8": string4,
  hex: bases5.base16,
  latin1: ascii4,
  ascii: ascii4,
  binary: ascii4,
  ...bases5
};
var bases_default4 = BASES4;

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js
function toString9(array, encoding = "utf8") {
  const base42 = bases_default4[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.encoder.encode(array).substring(1);
}
__name(toString9, "toString");

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array3(buf3) {
  return buf3;
}
__name(asUint8Array3, "asUint8Array");

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js
function concat4(arrays, length21) {
  if (length21 == null) {
    length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe7(length21);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array3(output3);
}
__name(concat4, "concat");

// node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  static {
    __name(this, "Parser");
  }
  index = 0;
  input = "";
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i = 0; i < out.length; i++) {
        const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = /* @__PURE__ */ __name((groups) => {
      for (let i = 0; i < groups.length / 2; i++) {
        const ix = i * 2;
        if (i < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    }, "readGroups");
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
__name(parseIPv4, "parseIPv4");
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
__name(parseIPv6, "parseIPv6");
function parseIP(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}
__name(parseIP, "parseIP");

// node_modules/@chainsafe/netmask/dist/src/ip.js
var maxIPv6Octet = parseInt("0xFFFF", 16);
var ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js
function fromString10(string8, encoding = "utf8") {
  const base42 = bases_default4[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.decoder.decode(`${base42.prefix}${string8}`);
}
__name(fromString10, "fromString");

// node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
__name(isIPv4, "isIPv4");
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
__name(isIPv6, "isIPv6");
function isIP(input) {
  return Boolean(parseIP(input));
}
__name(isIP, "isIP");

// node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes = /* @__PURE__ */ __name(function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes3 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes3[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes3;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes(sections[i]);
        sections[i] = toString9(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString9(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++)
        ;
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes3 = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      const word2 = parseInt(sections[i], 16);
      bytes3[offset++] = word2 >> 8 & 255;
      bytes3[offset++] = word2 & 255;
    }
    return bytes3;
  }
  throw new Error("invalid ip address");
}, "toBytes");
var toString10 = /* @__PURE__ */ __name(function(buf3, offset = 0, length21) {
  offset = ~~offset;
  length21 = length21 ?? buf3.length - offset;
  const view = new DataView(buf3.buffer);
  if (length21 === 4) {
    const result = [];
    for (let i = 0; i < length21; i++) {
      result.push(buf3[offset + i]);
    }
    return result.join(".");
  }
  if (length21 === 16) {
    const result = [];
    for (let i = 0; i < length21; i += 2) {
      result.push(view.getUint16(offset + i).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
}, "toString");

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
var V = -1;
var names2 = {};
var codes3 = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc-direct"],
  [281, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [449, V, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [481, V, "http-path"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes3[proto.code] = proto;
  names2[proto.name] = proto;
});
function createProtocol(code16, size, name14, resolvable, path) {
  return {
    code: code16,
    size,
    name: name14,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
__name(createProtocol, "createProtocol");
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes3[proto] != null) {
      return codes3[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names2[proto] != null) {
      return names2[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}
__name(getProtocol, "getProtocol");

// node_modules/@multiformats/multiaddr/dist/src/convert.js
var ip4Protocol = getProtocol("ip4");
var ip6Protocol = getProtocol("ip6");
var ipcidrProtocol = getProtocol("ipcidr");
function convertToString(proto, buf3) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    case 41:
      return bytes2ip(buf3);
    case 42:
      return bytes2str(buf3);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf3).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return bytes2str(buf3);
    case 421:
      return bytes2mh(buf3);
    case 444:
      return bytes2onion(buf3);
    case 445:
      return bytes2onion(buf3);
    case 466:
      return bytes2mb(buf3);
    case 481:
      return globalThis.encodeURIComponent(bytes2str(buf3));
    default:
      return toString9(buf3, "base16");
  }
}
__name(convertToString, "convertToString");
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    case 481:
      return str2bytes(globalThis.decodeURIComponent(str));
    default:
      return fromString10(str, "base16");
  }
}
__name(convertToBytes, "convertToBytes");
var decoders = Object.values(bases5).map((c) => c.decoder);
var anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes(ipString);
}
__name(ip2bytes, "ip2bytes");
function bytes2ip(ipBuff) {
  const ipString = toString10(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
__name(bytes2ip, "bytes2ip");
function port2bytes(port) {
  const buf3 = new ArrayBuffer(2);
  const view = new DataView(buf3);
  view.setUint16(0, port);
  return new Uint8Array(buf3);
}
__name(port2bytes, "port2bytes");
function bytes2port(buf3) {
  const view = new DataView(buf3.buffer);
  return view.getUint16(buf3.byteOffset);
}
__name(bytes2port, "bytes2port");
function str2bytes(str) {
  const buf3 = fromString10(str);
  const size = Uint8Array.from(encode11(buf3.length));
  return concat4([size, buf3], size.length + buf3.length);
}
__name(str2bytes, "str2bytes");
function bytes2str(buf3) {
  const size = decode15(buf3);
  buf3 = buf3.slice(encodingLength4(size));
  if (buf3.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString9(buf3);
}
__name(bytes2str, "bytes2str");
function mh2bytes(hash3) {
  let mh;
  if (hash3[0] === "Q" || hash3[0] === "1") {
    mh = decode48(base58btc13.decode(`z${hash3}`)).bytes;
  } else {
    mh = CID8.parse(hash3).multihash.bytes;
  }
  const size = Uint8Array.from(encode11(mh.length));
  return concat4([size, mh], size.length + mh.length);
}
__name(mh2bytes, "mh2bytes");
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(encode11(mb.length));
  return concat4([size, mb], size.length + mb.length);
}
__name(mb2bytes, "mb2bytes");
function bytes2mb(buf3) {
  const size = decode15(buf3);
  const hash3 = buf3.slice(encodingLength4(size));
  if (hash3.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString9(hash3, "base64url");
}
__name(bytes2mb, "bytes2mb");
function bytes2mh(buf3) {
  const size = decode15(buf3);
  const address = buf3.slice(encodingLength4(size));
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString9(address, "base58btc");
}
__name(bytes2mh, "bytes2mh");
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf3 = base3212.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat4([buf3, portBuf], buf3.length + portBuf.length);
}
__name(onion2bytes, "onion2bytes");
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf3 = base3212.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat4([buf3, portBuf], buf3.length + portBuf.length);
}
__name(onion32bytes, "onion32bytes");
function bytes2onion(buf3) {
  const addrBytes = buf3.slice(0, buf3.length - 2);
  const portBytes = buf3.slice(buf3.length - 2);
  const addr = toString9(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
__name(bytes2onion, "bytes2onion");

// node_modules/@multiformats/multiaddr/dist/src/codec.js
function stringToMultiaddrParts(str) {
  str = cleanPath(str);
  const tuples = [];
  const stringTuples = [];
  let path = null;
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return {
      bytes: new Uint8Array(),
      string: "/",
      tuples: [],
      stringTuples: [],
      path: null
    };
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([proto.code]);
      stringTuples.push([proto.code]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      path = cleanPath(parts.slice(p).join("/"));
      tuples.push([proto.code, convertToBytes(proto.code, path)]);
      stringTuples.push([proto.code, path]);
      break;
    }
    const bytes3 = convertToBytes(proto.code, parts[p]);
    tuples.push([proto.code, bytes3]);
    stringTuples.push([proto.code, convertToString(proto.code, bytes3)]);
  }
  return {
    string: stringTuplesToString(stringTuples),
    bytes: tuplesToBytes(tuples),
    tuples,
    stringTuples,
    path
  };
}
__name(stringToMultiaddrParts, "stringToMultiaddrParts");
function bytesToMultiaddrParts(bytes3) {
  const tuples = [];
  const stringTuples = [];
  let path = null;
  let i = 0;
  while (i < bytes3.length) {
    const code16 = decode15(bytes3, i);
    const n = encodingLength4(code16);
    const p = getProtocol(code16);
    const size = sizeForAddr(p, bytes3.slice(i + n));
    if (size === 0) {
      tuples.push([code16]);
      stringTuples.push([code16]);
      i += n;
      continue;
    }
    const addr = bytes3.slice(i + n, i + n + size);
    i += size + n;
    if (i > bytes3.length) {
      throw ParseError("Invalid address Uint8Array: " + toString9(bytes3, "base16"));
    }
    tuples.push([code16, addr]);
    const stringAddr = convertToString(code16, addr);
    stringTuples.push([code16, stringAddr]);
    if (p.path === true) {
      path = stringAddr;
      break;
    }
  }
  return {
    bytes: Uint8Array.from(bytes3),
    string: stringTuplesToString(stringTuples),
    tuples,
    stringTuples,
    path
  };
}
__name(bytesToMultiaddrParts, "bytesToMultiaddrParts");
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = getProtocol(tup[0]);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
__name(stringTuplesToString, "stringTuplesToString");
function tuplesToBytes(tuples) {
  return concat4(tuples.map((tup) => {
    const proto = getProtocol(tup[0]);
    let buf3 = Uint8Array.from(encode11(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf3 = concat4([buf3, tup[1]]);
    }
    return buf3;
  }));
}
__name(tuplesToBytes, "tuplesToBytes");
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = decode15(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
    return size + encodingLength4(size);
  }
}
__name(sizeForAddr, "sizeForAddr");
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
__name(cleanPath, "cleanPath");
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
__name(ParseError, "ParseError");

// node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var symbol3 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var Multiaddr = class _Multiaddr {
  static {
    __name(this, "Multiaddr");
  }
  bytes;
  #string;
  #tuples;
  #stringTuples;
  #path;
  [symbol3] = true;
  constructor(addr) {
    if (addr == null) {
      addr = "";
    }
    let parts;
    if (addr instanceof Uint8Array) {
      parts = bytesToMultiaddrParts(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      parts = stringToMultiaddrParts(addr);
    } else if (isMultiaddr(addr)) {
      parts = bytesToMultiaddrParts(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
    this.bytes = parts.bytes;
    this.#string = parts.string;
    this.#tuples = parts.tuples;
    this.#stringTuples = parts.stringTuples;
    this.#path = parts.path;
  }
  toString() {
    return this.#string;
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code16, value] of this.stringTuples()) {
      if (code16 === ip6zone.code) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES.includes(code16)) {
        transport = tcp.name;
        port = 443;
        host = `${value ?? ""}${zone}`;
        family = code16 === dns6.code ? 6 : 4;
      }
      if (code16 === tcp.code || code16 === udp.code) {
        transport = getProtocol(code16).name;
        port = parseInt(value ?? "");
      }
      if (code16 === ip4.code || code16 === ip6.code) {
        transport = getProtocol(code16).name;
        host = `${value ?? ""}${zone}`;
        family = code16 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.#tuples.map(([code16]) => Object.assign({}, getProtocol(code16)));
  }
  protoCodes() {
    return this.#tuples.map(([code16]) => code16);
  }
  protoNames() {
    return this.#tuples.map(([code16]) => getProtocol(code16).name);
  }
  tuples() {
    return this.#tuples;
  }
  stringTuples() {
    return this.#stringTuples;
  }
  encapsulate(addr) {
    addr = new _Multiaddr(addr);
    return new _Multiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i = s2.lastIndexOf(addrString);
    if (i < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _Multiaddr(s2.slice(0, i));
  }
  decapsulateCode(code16) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code16) {
        return new _Multiaddr(tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      let tuples = [];
      this.stringTuples().forEach(([code16, name14]) => {
        if (code16 === names2.p2p.code) {
          tuples.push([code16, name14]);
        }
        if (code16 === names2["p2p-circuit"].code) {
          tuples = [];
        }
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString9(base58btc13.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString9(CID8.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    return this.#path;
  }
  equals(addr) {
    return equals21(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw new CodeError2(`no available resolver for ${resolvableProto.name}`, "ERR_NO_AVAILABLE_RESOLVER");
    }
    const result = await resolver(this, options);
    return result.map((str) => multiaddr(str));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [inspect2]() {
    return `Multiaddr(${this.#string})`;
  }
};

// node_modules/@multiformats/multiaddr/dist/src/index.js
var resolvers = /* @__PURE__ */ new Map();
function isMultiaddr(value) {
  return Boolean(value?.[symbol3]);
}
__name(isMultiaddr, "isMultiaddr");
function multiaddr(addr) {
  return new Multiaddr(addr);
}
__name(multiaddr, "multiaddr");

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf3) => {
      return decodeMessage(buf3, AddressInfo2.codec());
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w2.uint32(16);
          w2.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w2.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader2.bytes();
              break;
            case 2:
              obj.seq = reader2.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf3) => {
    return decodeMessage(buf3, PeerRecord3.codec());
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var PeerRecord2 = class _PeerRecord {
  static {
    __name(this, "PeerRecord");
  }
  /**
   * Unmarshal Peer Record Protobuf
   */
  static createFromProtobuf = (buf3) => {
    const peerRecord = PeerRecord.decode(buf3);
    const peerId = peerIdFromBytes(peerRecord.peerId);
    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
    const seqNumber = peerRecord.seq;
    return new _PeerRecord({ peerId, multiaddrs, seqNumber });
  };
  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
  peerId;
  multiaddrs;
  seqNumber;
  domain = _PeerRecord.DOMAIN;
  codec = _PeerRecord.CODEC;
  marshaled;
  constructor(init) {
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m2) => ({
          multiaddr: m2.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};

// node_modules/@libp2p/peer-store/dist/src/errors.js
var codes4 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS"
};

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer3) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w2.uint32(10);
            w2.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            key: "",
            value: new Uint8Array(0)
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.key = reader2.string();
                break;
              case 2:
                obj.value = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf3) => {
      return decodeMessage(buf3, Peer$metadataEntry2.codec());
    };
  })(Peer$metadataEntry = Peer3.Peer$metadataEntry || (Peer3.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w2.uint32(10);
            w2.string(obj.key);
          }
          if (obj.value != null) {
            w2.uint32(18);
            Tag.codec().encode(obj.value, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            key: ""
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.key = reader2.string();
                break;
              case 2:
                obj.value = Tag.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf3) => {
      return decodeMessage(buf3, Peer$tagsEntry2.codec());
    };
  })(Peer$tagsEntry = Peer3.Peer$tagsEntry || (Peer3.Peer$tagsEntry = {}));
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w2.uint32(10);
            Address.codec().encode(value, w2);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w2.uint32(18);
            w2.string(value);
          }
        }
        if (obj.publicKey != null) {
          w2.uint32(34);
          w2.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w2.uint32(42);
          w2.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w2.uint32(50);
            Peer3.Peer$metadataEntry.codec().encode({ key, value }, w2);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w2.uint32(58);
            Peer3.Peer$tagsEntry.codec().encode({ key, value }, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address.codec().decode(reader2, reader2.uint32()));
              break;
            case 2:
              obj.protocols.push(reader2.string());
              break;
            case 4:
              obj.publicKey = reader2.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader2.bytes();
              break;
            case 6: {
              const entry = Peer3.Peer$metadataEntry.codec().decode(reader2, reader2.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              const entry = Peer3.Peer$tagsEntry.codec().decode(reader2, reader2.uint32());
              obj.tags.set(entry.key, entry.value);
              break;
            }
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf3) => {
    return decodeMessage(buf3, Peer3.codec());
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w2.uint32(16);
          w2.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader2.bytes();
              break;
            case 2:
              obj.isCertified = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf3) => {
    return decodeMessage(buf3, Address2.codec());
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w2.uint32(8);
          w2.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w2.uint32(16);
          w2.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          value: 0
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader2.uint32();
              break;
            case 2:
              obj.expiry = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf3) => {
    return decodeMessage(buf3, Tag2.codec());
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function bytesToPeer(peerId, buf3) {
  const peer = Peer.decode(buf3);
  if (peer.publicKey != null && peerId.publicKey == null) {
    peerId = peerIdFromPeerId({
      ...peerId,
      publicKey: peerId.publicKey
    });
  }
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: peerId,
    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}
__name(bytesToPeer, "bytesToPeer");

// node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
  if (!isPeerId(peerId) || peerId.type == null) {
    throw new CodeError("Invalid PeerId", codes4.ERR_INVALID_PARAMETERS);
  }
  const b32key = peerId.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}
__name(peerIdToDatastoreKey, "peerIdToDatastoreKey");

// node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId, filter2, addresses) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new CodeError("Multiaddr was invalid", codes4.ERR_INVALID_PARAMETERS);
    }
    if (!await filter2(peerId, addr.multiaddr)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: multiaddr2 }) => ({
    isCertified,
    multiaddr: multiaddr2.bytes
  }));
}
__name(dedupeFilterAndSortAddresses, "dedupeFilterAndSortAddresses");

// node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId, data, strategy, options) {
  if (data == null) {
    throw new CodeError("Invalid PeerData", codes4.ERR_INVALID_PARAMETERS);
  }
  if (data.publicKey != null && peerId.publicKey != null && !equals7(data.publicKey, peerId.publicKey)) {
    throw new CodeError("publicKey bytes do not match peer id publicKey bytes", codes4.ERR_INVALID_PARAMETERS);
  }
  const existingPeer = options.existingPeer;
  if (existingPeer != null && !peerId.equals(existingPeer.id)) {
    throw new CodeError("peer id did not match existing peer id", codes4.ERR_INVALID_PARAMETERS);
  }
  let addresses = existingPeer?.addresses ?? [];
  let protocols = new Set(existingPeer?.protocols ?? []);
  let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
  let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope = existingPeer?.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  const output3 = {
    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),
    protocols: [...protocols.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId.publicKey,
    peerRecordEnvelope
  };
  if (peerId.type !== "RSA") {
    delete output3.publicKey;
  }
  return output3;
}
__name(toPeerPB, "toPeerPB");
function createSortedMap(entries, options) {
  const output3 = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value != null) {
      output3.set(key, options.map?.(key, value) ?? value);
    }
  }
  return output3;
}
__name(createSortedMap, "createSortedMap");
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new CodeError("Metadata key must be a string", codes4.ERR_INVALID_PARAMETERS);
  }
  if (!(value instanceof Uint8Array)) {
    throw new CodeError("Metadata value must be a Uint8Array", codes4.ERR_INVALID_PARAMETERS);
  }
}
__name(validateMetadata, "validateMetadata");
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new CodeError("Tag name must be a string", codes4.ERR_INVALID_PARAMETERS);
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new CodeError("Tag value must be an integer", codes4.ERR_INVALID_PARAMETERS);
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new CodeError("Tag value must be between 0-100", codes4.ERR_INVALID_PARAMETERS);
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new CodeError("Tag ttl must be an integer", codes4.ERR_INVALID_PARAMETERS);
    }
    if (tag.ttl < 0) {
      throw new CodeError("Tag ttl must be between greater than 0", codes4.ERR_INVALID_PARAMETERS);
    }
  }
}
__name(validateTag, "validateTag");
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  return {
    value: tag.value ?? 0,
    expiry
  };
}
__name(mapTag, "mapTag");

// node_modules/@libp2p/peer-store/dist/src/store.js
function decodePeer(key, value, cache16) {
  const base32Str = key.toString().split("/")[2];
  const buf3 = base3211.decode(base32Str);
  const peerId = peerIdFromBytes(buf3);
  const cached = cache16.get(peerId);
  if (cached != null) {
    return cached;
  }
  const peer = bytesToPeer(peerId, value);
  cache16.set(peerId, peer);
  return peer;
}
__name(decodePeer, "decodePeer");
function mapQuery(query, cache16) {
  if (query == null) {
    return {};
  }
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value, cache16));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value, cache16), decodePeer(b.key, b.value, cache16));
    })
  };
}
__name(mapQuery, "mapQuery");
var PersistentStore = class {
  static {
    __name(this, "PersistentStore");
  }
  peerId;
  datastore;
  lock;
  addressFilter;
  constructor(components, init = {}) {
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  async has(peerId) {
    return this.datastore.has(peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    if (this.peerId.equals(peerId)) {
      throw new CodeError("Cannot delete self peer", codes4.ERR_INVALID_PARAMETERS);
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf3 = await this.datastore.get(peerIdToDatastoreKey(peerId));
    return bytesToPeer(peerId, buf3);
  }
  async save(peerId, data) {
    const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      addressFilter: this.addressFilter
    });
    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);
  }
  async patch(peerId, data) {
    const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);
  }
  async merge(peerId, data) {
    const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);
    const peerPb = await toPeerPB(peerId, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);
  }
  async *all(query) {
    const peerCache = new PeerMap();
    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))) {
      const peer = decodePeer(key, value, peerCache);
      if (peer.id.equals(this.peerId)) {
        continue;
      }
      yield peer;
    }
  }
  async #findExistingPeer(peerId) {
    try {
      const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId));
      const existingPeer = bytesToPeer(peerId, existingBuf);
      return {
        existingBuf,
        existingPeer
      };
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    return {};
  }
  async #saveIfDifferent(peerId, peer, existingBuf, existingPeer) {
    const buf3 = Peer.encode(peer);
    if (existingBuf != null && equals7(buf3, existingBuf)) {
      return {
        peer: bytesToPeer(peerId, buf3),
        previous: existingPeer,
        updated: false
      };
    }
    await this.datastore.put(peerIdToDatastoreKey(peerId), buf3);
    return {
      peer: bytesToPeer(peerId, buf3),
      previous: existingPeer,
      updated: true
    };
  }
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var log6 = logger7("libp2p:peer-store");
var PersistentPeerStore = class {
  static {
    __name(this, "PersistentPeerStore");
  }
  store;
  events;
  peerId;
  constructor(components, init = {}) {
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    log6.trace("forEach await read lock");
    const release = await this.store.lock.readLock();
    log6.trace("forEach got read lock");
    try {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    } finally {
      log6.trace("forEach release read lock");
      release();
    }
  }
  async all(query) {
    log6.trace("all await read lock");
    const release = await this.store.lock.readLock();
    log6.trace("all got read lock");
    try {
      return await src_default6(this.store.all(query));
    } finally {
      log6.trace("all release read lock");
      release();
    }
  }
  async delete(peerId) {
    log6.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log6.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      log6.trace("delete release write lock");
      release();
    }
  }
  async has(peerId) {
    log6.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log6.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      log6.trace("has release read lock");
      release();
    }
  }
  async get(peerId) {
    log6.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log6.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      log6.trace("get release read lock");
      release();
    }
  }
  async save(id, data) {
    log6.trace("save await write lock");
    const release = await this.store.lock.writeLock();
    log6.trace("save got write lock");
    try {
      const result = await this.store.save(id, data);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      log6.trace("save release write lock");
      release();
    }
  }
  async patch(id, data) {
    log6.trace("patch await write lock");
    const release = await this.store.lock.writeLock();
    log6.trace("patch got write lock");
    try {
      const result = await this.store.patch(id, data);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      log6.trace("patch release write lock");
      release();
    }
  }
  async merge(id, data) {
    log6.trace("merge await write lock");
    const release = await this.store.lock.writeLock();
    log6.trace("merge got write lock");
    try {
      const result = await this.store.merge(id, data);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      log6.trace("merge release write lock");
      release();
    }
  }
  async consumePeerRecord(buf3, expectedPeer) {
    const envelope = await RecordEnvelope.openAndCertify(buf3, PeerRecord2.DOMAIN);
    if (expectedPeer?.equals(envelope.peerId) === false) {
      log6("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, envelope.peerId);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(envelope.peerId);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if (peer?.peerRecordEnvelope != null) {
      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        log6("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf3,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    });
    return true;
  }
  #emitIfUpdated(id, result) {
    if (!result.updated) {
      return;
    }
    if (this.peerId.equals(id)) {
      this.events.safeDispatchEvent("self:peer:update", { detail: result });
    } else {
      this.events.safeDispatchEvent("peer:update", { detail: result });
    }
  }
};

// node_modules/libp2p/dist/src/address-manager/utils.js
function debounce2(func, wait) {
  let timeout;
  return function() {
    const later = /* @__PURE__ */ __name(function() {
      timeout = void 0;
      func();
    }, "later");
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
__name(debounce2, "debounce");

// node_modules/libp2p/dist/src/address-manager/index.js
var log7 = logger6("libp2p:address-manager");
var defaultAddressFilter = /* @__PURE__ */ __name((addrs) => addrs, "defaultAddressFilter");
function stripPeerId(ma, peerId) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
    }
  }
  return ma;
}
__name(stripPeerId, "stripPeerId");
var DefaultAddressManager = class {
  static {
    __name(this, "DefaultAddressManager");
  }
  components;
  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
  listen;
  announce;
  observed;
  announceFilter;
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Map();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this._updatePeerStoreAddresses = debounce2(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([_, metadata]) => metadata.confident).map(([str]) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      log7.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return Array.from(this.observed).map(([a]) => multiaddr(a));
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.set(addrString, {
      confident: false
    });
  }
  confirmObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    const metadata = this.observed.get(addrString) ?? {
      confident: false
    };
    const startingConfidence = metadata.confident;
    this.observed.set(addrString, {
      confident: true
    });
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    this.observed.delete(addrString);
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(Array.from(this.observed).filter(([ma, metadata]) => metadata.confident).map(([ma]) => ma));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.protos().pop()?.path === true) {
        return ma;
      }
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
};

// node_modules/@libp2p/interfaces/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
__name(isStartable, "isStartable");

// node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  static {
    __name(this, "DefaultComponents");
  }
  components = {};
  _started = false;
  constructor(init = {}) {
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable[methodName]?.();
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new CodeError(`${prop} not set`, "ERR_SERVICE_MISSING");
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}
__name(defaultComponents, "defaultComponents");

// node_modules/private-ip/lib/index.js
var import_netmask2 = __toESM(require_netmask(), 1);

// node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = /* @__PURE__ */ __name((options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "", "boundry");
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = /* @__PURE__ */ __name((options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g"), "ipRegex");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/private-ip/lib/index.js
var import_ipaddr = __toESM(require_ipaddr(), 1);
var { isValid: is_valid, parse: parse2 } = import_ipaddr.default;
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new import_netmask2.Netmask(ip_range));
function ipv4_check(ip_addr) {
  for (let r of NETMASK_RANGES) {
    if (r.contains(ip_addr))
      return true;
  }
  return false;
}
__name(ipv4_check, "ipv4_check");
function ipv6_check(ip_addr) {
  return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
}
__name(ipv6_check, "ipv6_check");
var lib_default = /* @__PURE__ */ __name((ip) => {
  if (is_valid(ip)) {
    const parsed = parse2(ip);
    if (parsed.kind() === "ipv4")
      return ipv4_check(parsed.toNormalizedString());
    else if (parsed.kind() === "ipv6")
      return ipv6_check(ip);
  } else if (isIP(ip) && ip_regex_default.v6().test(ip))
    return ipv6_check(ip);
  return void 0;
}, "default");

// node_modules/private-ip/index.js
var private_ip_default = lib_default;

// node_modules/libp2p/dist/src/config/connection-gater.browser.js
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === 4 || tuples[0][0] === 41) {
        return Boolean(private_ip_default(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}
__name(connectionGater, "connectionGater");

// node_modules/@libp2p/interface-transport/dist/src/index.js
var symbol4 = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    const { address } = ma.nodeAddress();
    return Boolean(private_ip_default(address));
  } catch {
    return true;
  }
}
__name(isPrivate, "isPrivate");

// node_modules/@libp2p/utils/dist/src/address-sort.js
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
__name(publicAddressesFirst, "publicAddressesFirst");

// node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}
__name(getTypes, "getTypes");

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports6 = {};
__export(base10_exports6, {
  base10: () => base106
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bytes.js
var empty14 = new Uint8Array(0);
function equals22(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals22, "equals");
function coerce14(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce14, "coerce");
function fromString11(str) {
  return new TextEncoder().encode(str);
}
__name(fromString11, "fromString");
function toString11(b) {
  return new TextDecoder().decode(b);
}
__name(toString11, "toString");

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/vendor/base-x.js
function base17(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base17, "base");
var src14 = base17;
var _brrp__multiformats_scope_baseX14 = src14;
var base_x_default14 = _brrp__multiformats_scope_baseX14;

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base.js
var Encoder14 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder14 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or14(this, decoder);
  }
};
var ComposedDecoder14 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or14(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or14(left, right) {
  return new ComposedDecoder14({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or14, "or");
var Codec14 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder14(name14, prefix, baseEncode);
    this.decoder = new Decoder14(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from21({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec14(name14, prefix, encode79, decode97);
}
__name(from21, "from");
function baseX14({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default14(alphabet11, name14);
  return from21({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce14(decode97(text))
  });
}
__name(baseX14, "baseX");
function decode50(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode50, "decode");
function encode40(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode40, "encode");
function rfc464814({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from21({
    prefix,
    name: name14,
    encode(input) {
      return encode40(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode50(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc464814, "rfc4648");

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base10.js
var base106 = baseX14({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports6 = {};
__export(base16_exports6, {
  base16: () => base166,
  base16upper: () => base16upper6
});
var base166 = rfc464814({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper6 = rfc464814({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports6 = {};
__export(base2_exports6, {
  base2: () => base27
});
var base27 = rfc464814({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports6 = {};
__export(base256emoji_exports6, {
  base256emoji: () => base256emoji6
});
var alphabet6 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars6 = alphabet6.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes6 = alphabet6.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode41(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars6[c];
    return p;
  }, "");
}
__name(encode41, "encode");
function decode51(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes6[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode51, "decode");
var base256emoji6 = from21({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode41,
  decode: decode51
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports6 = {};
__export(base32_exports6, {
  base32: () => base3213,
  base32hex: () => base32hex13,
  base32hexpad: () => base32hexpad13,
  base32hexpadupper: () => base32hexpadupper13,
  base32hexupper: () => base32hexupper13,
  base32pad: () => base32pad13,
  base32padupper: () => base32padupper13,
  base32upper: () => base32upper13,
  base32z: () => base32z13
});
var base3213 = rfc464814({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper13 = rfc464814({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad13 = rfc464814({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper13 = rfc464814({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex13 = rfc464814({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper13 = rfc464814({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad13 = rfc464814({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper13 = rfc464814({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z13 = rfc464814({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports6 = {};
__export(base36_exports6, {
  base36: () => base367,
  base36upper: () => base36upper7
});
var base367 = baseX14({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper7 = baseX14({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports6 = {};
__export(base58_exports6, {
  base58btc: () => base58btc14,
  base58flickr: () => base58flickr14
});
var base58btc14 = baseX14({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr14 = baseX14({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports6 = {};
__export(base64_exports6, {
  base64: () => base6413,
  base64pad: () => base64pad13,
  base64url: () => base64url13,
  base64urlpad: () => base64urlpad13
});
var base6413 = rfc464814({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad13 = rfc464814({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url13 = rfc464814({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad13 = rfc464814({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports6 = {};
__export(base8_exports6, {
  base8: () => base86
});
var base86 = rfc464814({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports11 = {};
__export(identity_exports11, {
  identity: () => identity13
});
var identity13 = from21({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString11(buf3),
  decode: (str) => fromString11(str)
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder9 = new TextEncoder();
var textDecoder8 = new TextDecoder();

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports12 = {};
__export(identity_exports12, {
  identity: () => identity14
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/vendor/varint.js
var encode_110 = encode42;
var MSB11 = 128;
var REST11 = 127;
var MSBALL10 = ~REST11;
var INT10 = Math.pow(2, 31);
function encode42(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT10) {
    out[offset++] = num & 255 | MSB11;
    num /= 128;
  }
  while (num & MSBALL10) {
    out[offset++] = num & 255 | MSB11;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode42.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode42, "encode");
var decode52 = read11;
var MSB$110 = 128;
var REST$110 = 127;
function read11(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read11.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$110) << shift : (b & REST$110) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$110);
  read11.bytes = counter - offset;
  return res;
}
__name(read11, "read");
var N112 = Math.pow(2, 7);
var N212 = Math.pow(2, 14);
var N312 = Math.pow(2, 21);
var N412 = Math.pow(2, 28);
var N512 = Math.pow(2, 35);
var N612 = Math.pow(2, 42);
var N712 = Math.pow(2, 49);
var N811 = Math.pow(2, 56);
var N911 = Math.pow(2, 63);
var length11 = /* @__PURE__ */ __name(function(value) {
  return value < N112 ? 1 : value < N212 ? 2 : value < N312 ? 3 : value < N412 ? 4 : value < N512 ? 5 : value < N612 ? 6 : value < N712 ? 7 : value < N811 ? 8 : value < N911 ? 9 : 10;
}, "length");
var varint11 = {
  encode: encode_110,
  decode: decode52,
  encodingLength: length11
};
var _brrp_varint10 = varint11;
var varint_default10 = _brrp_varint10;

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/varint.js
function decode53(data, offset = 0) {
  const code16 = varint_default10.decode(data, offset);
  return [code16, varint_default10.decode.bytes];
}
__name(decode53, "decode");
function encodeTo10(int, target, offset = 0) {
  varint_default10.encode(int, target, offset);
  return target;
}
__name(encodeTo10, "encodeTo");
function encodingLength11(int) {
  return varint_default10.encodingLength(int);
}
__name(encodingLength11, "encodingLength");

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/digest.js
function create12(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength11(code16);
  const digestOffset = sizeOffset + encodingLength11(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo10(code16, bytes3, 0);
  encodeTo10(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest10(code16, size, digest13, bytes3);
}
__name(create12, "create");
function decode54(multihash) {
  const bytes3 = coerce14(multihash);
  const [code16, sizeOffset] = decode53(bytes3);
  const [size, digestOffset] = decode53(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest10(code16, size, digest13, bytes3);
}
__name(decode54, "decode");
function equals23(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals22(a.bytes, data.bytes);
  }
}
__name(equals23, "equals");
var Digest10 = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/identity.js
var code11 = 0;
var name8 = "identity";
var encode43 = coerce14;
function digest8(input) {
  return create12(code11, encode43(input));
}
__name(digest8, "digest");
var identity14 = { code: code11, name: name8, encode: encode43, digest: digest8 };

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports6 = {};
__export(sha2_browser_exports6, {
  sha256: () => sha2568,
  sha512: () => sha5128
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/hasher.js
function from22({ name: name14, code: code16, encode: encode79 }) {
  return new Hasher8(name14, code16, encode79);
}
__name(from22, "from");
var Hasher8 = class {
  static {
    __name(this, "Hasher");
  }
  name;
  code;
  encode;
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create12(this.code, result) : result.then((digest13) => create12(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha8(name14) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name14, data));
}
__name(sha8, "sha");
var sha2568 = from22({
  name: "sha2-256",
  code: 18,
  encode: sha8("SHA-256")
});
var sha5128 = from22({
  name: "sha2-512",
  code: 19,
  encode: sha8("SHA-512")
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/cid.js
function format9(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV09(bytes3, baseCache9(link), base42 ?? base58btc14.encoder);
    default:
      return toStringV19(bytes3, baseCache9(link), base42 ?? base3213.encoder);
  }
}
__name(format9, "format");
var cache9 = /* @__PURE__ */ new WeakMap();
function baseCache9(cid) {
  const baseCache14 = cache9.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache9.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache9, "baseCache");
var CID9 = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE9) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE9) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create12(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals23(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format9(this, base42);
  }
  toJSON() {
    return { "/": format9(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID9(version4, code16, multihash.bytes));
    } else if (value[cidSymbol9] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode54(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE9) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE9}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID9(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE9, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce14(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest10(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode53(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE9;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes9(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache9(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes9(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc14;
      return [
        base58btc14.prefix,
        decoder.decode(`${base58btc14.prefix}${source}`)
      ];
    }
    case base58btc14.prefix: {
      const decoder = base42 ?? base58btc14;
      return [base58btc14.prefix, decoder.decode(source)];
    }
    case base3213.prefix: {
      const decoder = base42 ?? base3213;
      return [base3213.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes9, "parseCIDtoBytes");
function toStringV09(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc14.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV09, "toStringV0");
function toStringV19(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV19, "toStringV1");
var DAG_PB_CODE9 = 112;
var SHA_256_CODE9 = 18;
function encodeCID9(version4, code16, multihash) {
  const codeOffset = encodingLength11(version4);
  const hashOffset = codeOffset + encodingLength11(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo10(version4, bytes3, 0);
  encodeTo10(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID9, "encodeCID");
var cidSymbol9 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/basics.js
var bases6 = { ...identity_exports11, ...base2_exports6, ...base8_exports6, ...base10_exports6, ...base16_exports6, ...base32_exports6, ...base36_exports6, ...base58_exports6, ...base64_exports6, ...base256emoji_exports6 };
var hashes6 = { ...sha2_browser_exports6, ...identity_exports12 };

// node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe8(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe8, "allocUnsafe");

// node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec6(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: {
      decode: decode97
    }
  };
}
__name(createCodec6, "createCodec");
var string5 = createCodec6("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii5 = createCodec6("ascii", "a", (buf3) => {
  let string8 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string8 += String.fromCharCode(buf3[i]);
  }
  return string8;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe8(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES5 = {
  utf8: string5,
  "utf-8": string5,
  hex: bases6.base16,
  latin1: ascii5,
  ascii: ascii5,
  binary: ascii5,
  ...bases6
};
var bases_default5 = BASES5;

// node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/to-string.js
function toString12(array, encoding = "utf8") {
  const base42 = bases_default5[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.encoder.encode(array).substring(1);
}
__name(toString12, "toString");

// node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString12(answer.data) : answer.data
      };
    })
  };
}
__name(toDNSResponse, "toDNSResponse");

// node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue2({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options = {}) => {
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    options.onProgress?.(new CustomProgressEvent("dns:query", { detail: fqdn }));
    const response = await httpQueue.add(async () => {
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options?.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      options.onProgress?.(new CustomProgressEvent("dns:response", { detail: response2 }));
      return response2;
    }, {
      signal: options.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}
__name(dnsJsonOverHttps, "dnsJsonOverHttps");

// node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}
__name(defaultResolver, "defaultResolver");

// node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  static {
    __name(this, "CachedAnswers");
  }
  lru;
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache10(size) {
  return new CachedAnswers(size);
}
__name(cache10, "cache");

// node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS = class {
  static {
    __name(this, "DNS");
  }
  resolvers;
  cache;
  constructor(init) {
    this.resolvers = {};
    this.cache = cache10(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options = {}) {
    const types = getTypes(options.types);
    const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      options.onProgress?.(new CustomProgressEvent("dns:cache", { detail: cached }));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers2) {
      if (options.signal?.aborted === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        options.onProgress?.(new CustomProgressEvent("dns:error", { detail: err }));
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS(init);
}
__name(dns, "dns");

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
var MAX_RECURSIVE_DEPTH = 32;
var { code: dnsaddrCode } = getProtocol("dnsaddr");
var dnsaddrResolver = /* @__PURE__ */ __name(async function dnsaddrResolver2(ma, options = {}) {
  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
  if (recursionLimit === 0) {
    throw new CodeError2("Max recursive depth reached", "ERR_MAX_RECURSIVE_DEPTH_REACHED");
  }
  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  const resolver = options?.dns ?? dns();
  const result = await resolver.query(`_dnsaddr.${hostname}`, {
    signal: options?.signal,
    types: [
      RecordType.TXT
    ]
  });
  const peerId = ma.getPeerId();
  const output3 = [];
  for (const answer of result.Answer) {
    const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
    if (addr == null) {
      continue;
    }
    if (peerId != null && !addr.includes(peerId)) {
      continue;
    }
    const ma2 = multiaddr(addr);
    if (addr.startsWith("/dnsaddr")) {
      const resolved = await ma2.resolve({
        ...options,
        maxRecursiveDepth: recursionLimit - 1
      });
      output3.push(...resolved.map((ma3) => ma3.toString()));
    } else {
      output3.push(ma2.toString());
    }
  }
  return output3;
}, "dnsaddrResolver");

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["DHT_DISABLED"] = "DHT is not available";
  messages2["PUBSUB_DISABLED"] = "PubSub is not available";
  messages2["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages2["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var codes5;
(function(codes8) {
  codes8["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes8["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes8["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes8["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes8["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes8["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes8["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes8["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes8["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes8["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes8["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes8["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes8["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes8["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes8["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes8["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes8["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes8["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes8["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes8["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes8["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes8["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes8["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes8["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes8["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes8["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes8["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes8["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes8["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes8["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes8["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes8["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes8["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes8["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes8["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes8["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes8["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes8["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes8["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes8["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes8["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes8["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes8["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes8["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes8["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes8["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes8["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes8["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes8["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes8["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes8["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes8["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes8["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes8["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes8["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes8["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes8["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes8["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes8["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes8["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes8["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes8["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes8["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes8["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes8["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes8["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
  codes8["ERR_TRANSFER_LIMIT_EXCEEDED"] = "ERR_TRANSFER_LIMIT_EXCEEDED";
})(codes5 || (codes5 = {}));

// node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
function validateConfig(opts) {
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw new CodeError(messages.ERR_TRANSPORTS_REQUIRED, codes5.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes5.ERR_PROTECTOR_REQUIRED);
  }
  return resultingOptions;
}
__name(validateConfig, "validateConfig");

// node_modules/@libp2p/interface-peer-store/dist/src/tags.js
var KEEP_ALIVE = "keep-alive";

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);

// node_modules/libp2p/dist/src/get-peer.js
var log8 = logger6("libp2p:get-peer");
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  if (!Array.isArray(peer)) {
    peer = [peer];
  }
  let peerId;
  if (peer.length > 0) {
    const peerIdStr = peer[0].getPeerId();
    peerId = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    peer.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        log8.error("multiaddr %s was invalid", ma);
        throw new CodeError("Invalid Multiaddr", codes5.ERR_INVALID_MULTIADDR);
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId != null) {
          throw new CodeError("Multiaddrs must all have the same peer id or have no peer id", codes5.ERR_INVALID_PARAMETERS);
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if (peerId == null || !peerId.equals(maPeerId)) {
          throw new CodeError("Multiaddrs must all have the same peer id or have no peer id", codes5.ERR_INVALID_PARAMETERS);
        }
      }
    });
  }
  return {
    peerId,
    multiaddrs: peer
  };
}
__name(getPeerAddress, "getPeerAddress");

// node_modules/libp2p/node_modules/eventemitter3/index.mjs
var import_index11 = __toESM(require_eventemitter33(), 1);

// node_modules/libp2p/node_modules/p-timeout/index.js
var TimeoutError3 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError7 = class extends Error {
  static {
    __name(this, "AbortError");
  }
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException3 = /* @__PURE__ */ __name((errorMessage) => globalThis.DOMException === void 0 ? new AbortError7(errorMessage) : new DOMException(errorMessage), "getDOMException");
var getAbortedReason3 = /* @__PURE__ */ __name((signal) => {
  const reason = signal.reason === void 0 ? getDOMException3("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException3(reason);
}, "getAbortedReason");
function pTimeout3(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason3(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason3(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError3(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
__name(pTimeout3, "pTimeout");

// node_modules/libp2p/node_modules/p-queue/dist/lower-bound.js
function lowerBound3(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
__name(lowerBound3, "lowerBound");

// node_modules/libp2p/node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue2;
var PriorityQueue3 = class {
  static {
    __name(this, "PriorityQueue");
  }
  constructor() {
    _PriorityQueue_queue2.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet3(this, _PriorityQueue_queue2, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet3(this, _PriorityQueue_queue2, "f").push(element);
      return;
    }
    const index = lowerBound3(__classPrivateFieldGet3(this, _PriorityQueue_queue2, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet3(this, _PriorityQueue_queue2, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet3(this, _PriorityQueue_queue2, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet3(this, _PriorityQueue_queue2, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet3(this, _PriorityQueue_queue2, "f").length;
  }
};
_PriorityQueue_queue2 = /* @__PURE__ */ new WeakMap();
var priority_queue_default2 = PriorityQueue3;

// node_modules/libp2p/node_modules/p-queue/dist/index.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances2;
var _PQueue_carryoverConcurrencyCount2;
var _PQueue_isIntervalIgnored2;
var _PQueue_intervalCount2;
var _PQueue_intervalCap2;
var _PQueue_interval2;
var _PQueue_intervalEnd2;
var _PQueue_intervalId2;
var _PQueue_timeoutId2;
var _PQueue_queue2;
var _PQueue_queueClass2;
var _PQueue_pending2;
var _PQueue_concurrency2;
var _PQueue_isPaused2;
var _PQueue_throwOnTimeout2;
var _PQueue_doesIntervalAllowAnother_get3;
var _PQueue_doesConcurrentAllowAnother_get3;
var _PQueue_next3;
var _PQueue_onResumeInterval3;
var _PQueue_isIntervalPaused_get3;
var _PQueue_tryToStartAnother3;
var _PQueue_initializeIntervalIfNeeded3;
var _PQueue_onInterval3;
var _PQueue_processQueue3;
var _PQueue_throwOnAbort3;
var _PQueue_onEvent3;
var AbortError8 = class extends Error {
  static {
    __name(this, "AbortError");
  }
};
var PQueue3 = class extends import_index11.default {
  static {
    __name(this, "PQueue");
  }
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    _PQueue_instances2.add(this);
    _PQueue_carryoverConcurrencyCount2.set(this, void 0);
    _PQueue_isIntervalIgnored2.set(this, void 0);
    _PQueue_intervalCount2.set(this, 0);
    _PQueue_intervalCap2.set(this, void 0);
    _PQueue_interval2.set(this, void 0);
    _PQueue_intervalEnd2.set(this, 0);
    _PQueue_intervalId2.set(this, void 0);
    _PQueue_timeoutId2.set(this, void 0);
    _PQueue_queue2.set(this, void 0);
    _PQueue_queueClass2.set(this, void 0);
    _PQueue_pending2.set(this, 0);
    _PQueue_concurrency2.set(this, void 0);
    _PQueue_isPaused2.set(this, void 0);
    _PQueue_throwOnTimeout2.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: priority_queue_default2,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet2(this, _PQueue_carryoverConcurrencyCount2, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet2(this, _PQueue_isIntervalIgnored2, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet2(this, _PQueue_intervalCap2, options.intervalCap, "f");
    __classPrivateFieldSet2(this, _PQueue_interval2, options.interval, "f");
    __classPrivateFieldSet2(this, _PQueue_queue2, new options.queueClass(), "f");
    __classPrivateFieldSet2(this, _PQueue_queueClass2, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet2(this, _PQueue_throwOnTimeout2, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet2(this, _PQueue_isPaused2, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet4(this, _PQueue_concurrency2, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet2(this, _PQueue_concurrency2, newConcurrency, "f");
    __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_processQueue3).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet4(this, _PQueue_throwOnTimeout2, "f"),
      ...options
    };
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet4(this, _PQueue_queue2, "f").enqueue(async () => {
        var _a;
        var _b, _c;
        __classPrivateFieldSet2(this, _PQueue_pending2, (_b = __classPrivateFieldGet4(this, _PQueue_pending2, "f"), _b++, _b), "f");
        __classPrivateFieldSet2(this, _PQueue_intervalCount2, (_c = __classPrivateFieldGet4(this, _PQueue_intervalCount2, "f"), _c++, _c), "f");
        try {
          if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
            throw new AbortError8("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout3(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_throwOnAbort3).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError3 && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_next3).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_tryToStartAnother3).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet4(this, _PQueue_isPaused2, "f")) {
      return this;
    }
    __classPrivateFieldSet2(this, _PQueue_isPaused2, false, "f");
    __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_processQueue3).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet2(this, _PQueue_isPaused2, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet2(this, _PQueue_queue2, new (__classPrivateFieldGet4(this, _PQueue_queueClass2, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet4(this, _PQueue_queue2, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_onEvent3).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet4(this, _PQueue_queue2, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_onEvent3).call(this, "next", () => __classPrivateFieldGet4(this, _PQueue_queue2, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet4(this, _PQueue_pending2, "f") === 0 && __classPrivateFieldGet4(this, _PQueue_queue2, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_onEvent3).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet4(this, _PQueue_queue2, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet4(this, _PQueue_queue2, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet4(this, _PQueue_pending2, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet4(this, _PQueue_isPaused2, "f");
  }
};
_PQueue_carryoverConcurrencyCount2 = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored2 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount2 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap2 = /* @__PURE__ */ new WeakMap(), _PQueue_interval2 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd2 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId2 = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId2 = /* @__PURE__ */ new WeakMap(), _PQueue_queue2 = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass2 = /* @__PURE__ */ new WeakMap(), _PQueue_pending2 = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency2 = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused2 = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout2 = /* @__PURE__ */ new WeakMap(), _PQueue_instances2 = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get3 = /* @__PURE__ */ __name(function _PQueue_doesIntervalAllowAnother_get4() {
  return __classPrivateFieldGet4(this, _PQueue_isIntervalIgnored2, "f") || __classPrivateFieldGet4(this, _PQueue_intervalCount2, "f") < __classPrivateFieldGet4(this, _PQueue_intervalCap2, "f");
}, "_PQueue_doesIntervalAllowAnother_get"), _PQueue_doesConcurrentAllowAnother_get3 = /* @__PURE__ */ __name(function _PQueue_doesConcurrentAllowAnother_get4() {
  return __classPrivateFieldGet4(this, _PQueue_pending2, "f") < __classPrivateFieldGet4(this, _PQueue_concurrency2, "f");
}, "_PQueue_doesConcurrentAllowAnother_get"), _PQueue_next3 = /* @__PURE__ */ __name(function _PQueue_next4() {
  var _a;
  __classPrivateFieldSet2(this, _PQueue_pending2, (_a = __classPrivateFieldGet4(this, _PQueue_pending2, "f"), _a--, _a), "f");
  __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_tryToStartAnother3).call(this);
  this.emit("next");
}, "_PQueue_next"), _PQueue_onResumeInterval3 = /* @__PURE__ */ __name(function _PQueue_onResumeInterval4() {
  __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_onInterval3).call(this);
  __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_initializeIntervalIfNeeded3).call(this);
  __classPrivateFieldSet2(this, _PQueue_timeoutId2, void 0, "f");
}, "_PQueue_onResumeInterval"), _PQueue_isIntervalPaused_get3 = /* @__PURE__ */ __name(function _PQueue_isIntervalPaused_get4() {
  const now = Date.now();
  if (__classPrivateFieldGet4(this, _PQueue_intervalId2, "f") === void 0) {
    const delay = __classPrivateFieldGet4(this, _PQueue_intervalEnd2, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet2(this, _PQueue_intervalCount2, __classPrivateFieldGet4(this, _PQueue_carryoverConcurrencyCount2, "f") ? __classPrivateFieldGet4(this, _PQueue_pending2, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet4(this, _PQueue_timeoutId2, "f") === void 0) {
        __classPrivateFieldSet2(this, _PQueue_timeoutId2, setTimeout(() => {
          __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_onResumeInterval3).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, "_PQueue_isIntervalPaused_get"), _PQueue_tryToStartAnother3 = /* @__PURE__ */ __name(function _PQueue_tryToStartAnother4() {
  if (__classPrivateFieldGet4(this, _PQueue_queue2, "f").size === 0) {
    if (__classPrivateFieldGet4(this, _PQueue_intervalId2, "f")) {
      clearInterval(__classPrivateFieldGet4(this, _PQueue_intervalId2, "f"));
    }
    __classPrivateFieldSet2(this, _PQueue_intervalId2, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet4(this, _PQueue_pending2, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet4(this, _PQueue_isPaused2, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet4(this, _PQueue_instances2, "a", _PQueue_isIntervalPaused_get3);
    if (__classPrivateFieldGet4(this, _PQueue_instances2, "a", _PQueue_doesIntervalAllowAnother_get3) && __classPrivateFieldGet4(this, _PQueue_instances2, "a", _PQueue_doesConcurrentAllowAnother_get3)) {
      const job = __classPrivateFieldGet4(this, _PQueue_queue2, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_initializeIntervalIfNeeded3).call(this);
      }
      return true;
    }
  }
  return false;
}, "_PQueue_tryToStartAnother"), _PQueue_initializeIntervalIfNeeded3 = /* @__PURE__ */ __name(function _PQueue_initializeIntervalIfNeeded4() {
  if (__classPrivateFieldGet4(this, _PQueue_isIntervalIgnored2, "f") || __classPrivateFieldGet4(this, _PQueue_intervalId2, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet2(this, _PQueue_intervalId2, setInterval(() => {
    __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_onInterval3).call(this);
  }, __classPrivateFieldGet4(this, _PQueue_interval2, "f")), "f");
  __classPrivateFieldSet2(this, _PQueue_intervalEnd2, Date.now() + __classPrivateFieldGet4(this, _PQueue_interval2, "f"), "f");
}, "_PQueue_initializeIntervalIfNeeded"), _PQueue_onInterval3 = /* @__PURE__ */ __name(function _PQueue_onInterval4() {
  if (__classPrivateFieldGet4(this, _PQueue_intervalCount2, "f") === 0 && __classPrivateFieldGet4(this, _PQueue_pending2, "f") === 0 && __classPrivateFieldGet4(this, _PQueue_intervalId2, "f")) {
    clearInterval(__classPrivateFieldGet4(this, _PQueue_intervalId2, "f"));
    __classPrivateFieldSet2(this, _PQueue_intervalId2, void 0, "f");
  }
  __classPrivateFieldSet2(this, _PQueue_intervalCount2, __classPrivateFieldGet4(this, _PQueue_carryoverConcurrencyCount2, "f") ? __classPrivateFieldGet4(this, _PQueue_pending2, "f") : 0, "f");
  __classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_processQueue3).call(this);
}, "_PQueue_onInterval"), _PQueue_processQueue3 = /* @__PURE__ */ __name(function _PQueue_processQueue4() {
  while (__classPrivateFieldGet4(this, _PQueue_instances2, "m", _PQueue_tryToStartAnother3).call(this)) {
  }
}, "_PQueue_processQueue"), _PQueue_throwOnAbort3 = /* @__PURE__ */ __name(async function _PQueue_throwOnAbort4(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError8("The task was aborted."));
    }, { once: true });
  });
}, "_PQueue_throwOnAbort"), _PQueue_onEvent3 = /* @__PURE__ */ __name(async function _PQueue_onEvent4(event, filter2) {
  return new Promise((resolve) => {
    const listener = /* @__PURE__ */ __name(() => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    }, "listener");
    this.on(event, listener);
  });
}, "_PQueue_onEvent");
var dist_default3 = PQueue3;

// node_modules/libp2p/dist/src/utils/peer-job-queue.js
function lowerBound4(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
__name(lowerBound4, "lowerBound");
var PeerPriorityQueue = class {
  static {
    __name(this, "PeerPriorityQueue");
  }
  #queue = [];
  enqueue(run, options) {
    const peerId = options?.peerId;
    const priority = options?.priority ?? 0;
    if (peerId == null) {
      throw new CodeError("missing peer id", codes5.ERR_INVALID_PARAMETERS);
    }
    const element = {
      priority,
      peerId,
      run
    };
    if (this.size > 0 && this.#queue[this.size - 1].priority >= priority) {
      this.#queue.push(element);
      return;
    }
    const index = lowerBound4(this.#queue, element, (a, b) => b.priority - a.priority);
    this.#queue.splice(index, 0, element);
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options) {
    if (options.peerId != null) {
      const peerId = options.peerId;
      return this.#queue.filter((element) => peerId.equals(element.peerId)).map((element) => element.run);
    }
    return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
};
var PeerJobQueue = class extends dist_default3 {
  static {
    __name(this, "PeerJobQueue");
  }
  constructor(options = {}) {
    super({
      ...options,
      queueClass: PeerPriorityQueue
    });
  }
  /**
   * Returns true if this queue has a job for the passed peer id that has not yet
   * started to run
   */
  hasJob(peerId) {
    return this.sizeBy({
      peerId
    }) > 0;
  }
};

// node_modules/libp2p/dist/src/connection-manager/constants.js
var DIAL_TIMEOUT = 3e4;
var INBOUND_UPGRADE_TIMEOUT = 3e4;
var MAX_PARALLEL_DIALS = 100;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var MAX_PARALLEL_DIALS_PER_PEER = 10;
var MIN_CONNECTIONS = 50;
var MAX_CONNECTIONS = 300;
var AUTO_DIAL_INTERVAL = 5e3;
var AUTO_DIAL_CONCURRENCY = 25;
var AUTO_DIAL_PRIORITY = 0;
var AUTO_DIAL_MAX_QUEUE_LENGTH = 100;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;

// node_modules/libp2p/dist/src/connection-manager/auto-dial.js
var log9 = logger6("libp2p:connection-manager:auto-dial");
var defaultOptions6 = {
  minConnections: MIN_CONNECTIONS,
  maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialInterval: AUTO_DIAL_INTERVAL
};
var AutoDial = class {
  static {
    __name(this, "AutoDial");
  }
  connectionManager;
  peerStore;
  queue;
  minConnections;
  autoDialPriority;
  autoDialIntervalMs;
  autoDialMaxQueueLength;
  autoDialInterval;
  started;
  running;
  /**
   * Proactively tries to connect to known peers stored in the PeerStore.
   * It will keep the number of connections below the upper limit and sort
   * the peers to connect based on whether we know their keys and protocols.
   */
  constructor(components, init) {
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.minConnections = init.minConnections ?? defaultOptions6.minConnections;
    this.autoDialPriority = init.autoDialPriority ?? defaultOptions6.autoDialPriority;
    this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions6.autoDialInterval;
    this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions6.maxQueueLength;
    this.started = false;
    this.running = false;
    this.queue = new PeerJobQueue({
      concurrency: init.autoDialConcurrency ?? defaultOptions6.autoDialConcurrency
    });
    this.queue.addListener("error", (err) => {
      log9.error("error during auto-dial", err);
    });
    components.events.addEventListener("connection:close", () => {
      this.autoDial().catch((err) => {
        log9.error(err);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.autoDialInterval = setTimeout(() => {
      this.autoDial().catch((err) => {
        log9.error("error while autodialing", err);
      });
    }, this.autoDialIntervalMs);
    this.started = true;
  }
  afterStart() {
    this.autoDial().catch((err) => {
      log9.error("error while autodialing", err);
    });
  }
  stop() {
    this.queue.clear();
    clearTimeout(this.autoDialInterval);
    this.started = false;
    this.running = false;
  }
  async autoDial() {
    if (!this.started) {
      return;
    }
    const connections = this.connectionManager.getConnectionsMap();
    const numConnections = connections.size;
    if (numConnections >= this.minConnections) {
      log9.trace("have enough connections %d/%d", numConnections, this.minConnections);
      return;
    }
    if (this.queue.size > this.autoDialMaxQueueLength) {
      log9("not enough connections %d/%d but auto dial queue is full", numConnections, this.minConnections);
      return;
    }
    if (this.running) {
      log9("not enough connections %d/%d - but skipping autodial as it is already running", numConnections, this.minConnections);
      return;
    }
    this.running = true;
    log9("not enough connections %d/%d - will dial peers to increase the number of connections", numConnections, this.minConnections);
    const dialQueue = new PeerSet(
      // @ts-expect-error boolean filter removes falsy peer IDs
      this.connectionManager.getDialQueue().map((queue) => queue.peerId).filter(Boolean)
    );
    const peers = await this.peerStore.all({
      filters: [
        // Remove some peers
        (peer) => {
          if (peer.addresses.length === 0) {
            log9.trace("not autodialing %p because they have no addresses");
            return false;
          }
          if (connections.has(peer.id)) {
            log9.trace("not autodialing %p because they are already connected");
            return false;
          }
          if (dialQueue.has(peer.id)) {
            log9.trace("not autodialing %p because they are already being dialed");
            return false;
          }
          if (this.queue.hasJob(peer.id)) {
            log9.trace("not autodialing %p because they are already being autodialed");
            return false;
          }
          return true;
        }
      ]
    });
    const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);
    const peerValues = new PeerMap();
    for (const peer of shuffledPeers) {
      if (peerValues.has(peer.id)) {
        continue;
      }
      peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedPeers = shuffledPeers.sort((a, b) => {
      const peerAValue = peerValues.get(a.id) ?? 0;
      const peerBValue = peerValues.get(b.id) ?? 0;
      if (peerAValue > peerBValue) {
        return -1;
      }
      if (peerAValue < peerBValue) {
        return 1;
      }
      return 0;
    });
    log9("selected %d/%d peers to dial", sortedPeers.length, peers.length);
    for (const peer of sortedPeers) {
      this.queue.add(async () => {
        const numConnections2 = this.connectionManager.getConnectionsMap().size;
        if (numConnections2 >= this.minConnections) {
          log9("got enough connections now %d/%d", numConnections2, this.minConnections);
          this.queue.clear();
          return;
        }
        log9("connecting to a peerStore stored peer %p", peer.id);
        await this.connectionManager.openConnection(peer.id, {
          // @ts-expect-error needs adding to the ConnectionManager interface
          priority: this.autoDialPriority
        });
      }, {
        peerId: peer.id
      }).catch((err) => {
        log9.error("could not connect to peerStore stored peer", err);
      });
    }
    this.running = false;
    if (this.started) {
      this.autoDialInterval = setTimeout(() => {
        this.autoDial().catch((err) => {
          log9.error("error while autodialing", err);
        });
      }, this.autoDialIntervalMs);
    }
  }
};

// node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var log10 = logger6("libp2p:connection-manager:connection-pruner");
var defaultOptions7 = {
  maxConnections: MAX_CONNECTIONS,
  allow: []
};
var ConnectionPruner = class {
  static {
    __name(this, "ConnectionPruner");
  }
  maxConnections;
  connectionManager;
  peerStore;
  allow;
  events;
  constructor(components, init = {}) {
    this.maxConnections = init.maxConnections ?? defaultOptions7.maxConnections;
    this.allow = init.allow ?? defaultOptions7.allow;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    components.events.addEventListener("connection:open", () => {
      this.maybePruneConnections().catch((err) => {
        log10.error(err);
      });
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const toPrune = Math.max(numConnections - this.maxConnections, 0);
    log10("checking max connections limit %d/%d", numConnections, this.maxConnections);
    if (numConnections <= this.maxConnections) {
      return;
    }
    log10("max connections limit exceeded %d/%d, pruning %d connection(s)", numConnections, this.maxConnections, toPrune);
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          log10.error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = connections.sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      const connectionALifespan = a.stat.timeline.open;
      const connectionBLifespan = b.stat.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      log10("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ma) => {
        return connection.remoteAddr.toString().startsWith(ma.toString());
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err) {
        log10.error(err);
      }
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
};

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var import_events5 = __toESM(require_events(), 1);

// node_modules/libp2p/dist/src/connection-manager/utils.js
var import_events4 = __toESM(require_events(), 1);
var log11 = logger6("libp2p:connection-manager:utils");
async function resolveMultiaddrs(ma, options) {
  const resolvableProto = ma.protoNames().includes("dnsaddr");
  if (!resolvableProto) {
    return [ma];
  }
  const resolvedMultiaddrs = await resolveRecord(ma, options);
  const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
    return resolveMultiaddrs(nm, options);
  }));
  const addrs = recursiveMultiaddrs.flat();
  const output3 = addrs.reduce((array, newM) => {
    if (array.find((m2) => m2.equals(newM)) == null) {
      array.push(newM);
    }
    return array;
  }, []);
  log11("resolved %s to", ma, output3.map((ma2) => ma2.toString()));
  return output3;
}
__name(resolveMultiaddrs, "resolveMultiaddrs");
async function resolveRecord(ma, options) {
  try {
    ma = multiaddr(ma.toString());
    const multiaddrs = await ma.resolve(options);
    return multiaddrs;
  } catch (err) {
    log11.error(`multiaddr ${ma.toString()} could not be resolved`, err);
    return [];
  }
}
__name(resolveRecord, "resolveRecord");
function combineSignals(...signals) {
  const sigs = [];
  for (const sig of signals) {
    if (sig != null) {
      try {
        (0, import_events4.setMaxListeners)?.(Infinity, sig);
      } catch {
      }
      sigs.push(sig);
    }
  }
  const signal = anySignal(sigs);
  try {
    (0, import_events4.setMaxListeners)?.(Infinity, signal);
  } catch {
  }
  return signal;
}
__name(combineSignals, "combineSignals");

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var log12 = logger6("libp2p:connection-manager:dial-queue");
var defaultOptions8 = {
  addressSorter: publicAddressesFirst,
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  maxParallelDialsPerPeer: MAX_PARALLEL_DIALS_PER_PEER,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  static {
    __name(this, "DialQueue");
  }
  pendingDials;
  queue;
  peerId;
  peerStore;
  connectionGater;
  transportManager;
  addressSorter;
  maxPeerAddrsToDial;
  maxParallelDialsPerPeer;
  dialTimeout;
  inProgressDialCount;
  pendingDialCount;
  shutDownController;
  constructor(components, init = {}) {
    this.addressSorter = init.addressSorter ?? defaultOptions8.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions8.maxPeerAddrsToDial;
    this.maxParallelDialsPerPeer = init.maxParallelDialsPerPeer ?? defaultOptions8.maxParallelDialsPerPeer;
    this.dialTimeout = init.dialTimeout ?? defaultOptions8.dialTimeout;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.connectionGater = components.connectionGater;
    this.transportManager = components.transportManager;
    this.shutDownController = new AbortController();
    try {
      (0, import_events5.setMaxListeners)?.(Infinity, this.shutDownController.signal);
    } catch {
    }
    this.pendingDialCount = components.metrics?.registerMetric("libp2p_dialler_pending_dials");
    this.inProgressDialCount = components.metrics?.registerMetric("libp2p_dialler_in_progress_dials");
    this.pendingDials = [];
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
    this.queue = new dist_default3({
      concurrency: init.maxParallelDials ?? defaultOptions8.maxParallelDials
    });
    this.queue.on("add", () => {
      this.pendingDialCount?.update(this.queue.size);
      this.inProgressDialCount?.update(this.queue.pending);
    });
    this.queue.on("active", () => {
      this.pendingDialCount?.update(this.queue.size);
      this.inProgressDialCount?.update(this.queue.pending);
    });
    this.queue.on("completed", () => {
      this.pendingDialCount?.update(this.queue.size);
      this.inProgressDialCount?.update(this.queue.pending);
    });
    this.queue.on("error", (err) => {
      log12.error("error in dial queue", err);
      this.pendingDialCount?.update(this.queue.size);
      this.inProgressDialCount?.update(this.queue.pending);
    });
    this.queue.on("empty", () => {
      this.pendingDialCount?.update(this.queue.size);
      this.inProgressDialCount?.update(this.queue.pending);
    });
    this.queue.on("idle", () => {
      this.pendingDialCount?.update(this.queue.size);
      this.inProgressDialCount?.update(this.queue.pending);
    });
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a connection
   * will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const addrs = multiaddrs.map((multiaddr2) => ({
      multiaddr: multiaddr2,
      isCertified: false
    }));
    const signal = this.createDialAbortControllers(options.signal);
    let addrsToDial;
    try {
      addrsToDial = await this.calculateMultiaddrs(peerId, addrs, {
        ...options,
        signal
      });
    } catch (err) {
      signal.clear();
      throw err;
    }
    const existingDial = this.pendingDials.find((dial) => {
      if (dial.peerId != null && peerId != null && dial.peerId.equals(peerId)) {
        return true;
      }
      if (addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()).join() === dial.multiaddrs.map((multiaddr2) => multiaddr2.toString()).join()) {
        return true;
      }
      return false;
    });
    if (existingDial != null) {
      log12("joining existing dial target for %p", peerId);
      signal.clear();
      return existingDial.promise;
    }
    log12("creating dial target for", addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    const pendingDial = {
      id: randomId(),
      status: "queued",
      peerId,
      multiaddrs: addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
    pendingDial.promise = this.performDial(pendingDial, {
      ...options,
      signal
    }).finally(() => {
      this.pendingDials = this.pendingDials.filter((p) => p.id !== pendingDial.id);
      signal.clear();
    }).catch((err) => {
      log12.error("dial failed to %s", pendingDial.multiaddrs.map((ma) => ma.toString()).join(", "), err);
      if (signal.aborted) {
        const error = new CodeError(err.message, codes5.ERR_TIMEOUT);
        throw error;
      }
      throw err;
    });
    this.pendingDials.push(pendingDial);
    return pendingDial.promise;
  }
  createDialAbortControllers(userSignal) {
    const signal = anySignal([
      AbortSignal.timeout(this.dialTimeout),
      this.shutDownController.signal,
      userSignal
    ]);
    try {
      (0, import_events5.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    return signal;
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId, addrs = [], options = {}) {
    if (peerId != null) {
      if (this.peerId.equals(peerId)) {
        throw new CodeError("Tried to dial self", codes5.ERR_DIALED_SELF);
      }
      if (await this.connectionGater.denyDialPeer?.(peerId) === true) {
        throw new CodeError("The dial request is blocked by gater.allowDialPeer", codes5.ERR_PEER_DIAL_INTERCEPTED);
      }
      if (addrs.length === 0) {
        log12("loading multiaddrs for %p", peerId);
        try {
          const peer = await this.peerStore.get(peerId);
          addrs.push(...peer.addresses);
          log12("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.code !== codes5.ERR_NOT_FOUND) {
            throw err;
          }
        }
      }
    }
    const resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddrs(addr.multiaddr, options);
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    const filteredAddrs = resolvedAddresses.filter((addr) => Boolean(this.transportManager.transportForMultiaddr(addr.multiaddr)));
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    let dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0 || dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {
      log12("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      log12("addresses for %p after filtering", peerId ?? "unknown peer", dedupedMultiaddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    }
    if (dedupedMultiaddrs.length === 0) {
      throw new CodeError("The dial request has no valid addresses", codes5.ERR_NO_VALID_ADDRESSES);
    }
    if (dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {
      throw new CodeError("dial with more addresses than allowed", codes5.ERR_TOO_MANY_ADDRESSES);
    }
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      dedupedMultiaddrs = dedupedMultiaddrs.map((addr) => {
        const addressPeerId = addr.multiaddr.getPeerId();
        const lastProto = addr.multiaddr.protos().pop();
        if (lastProto?.path === true) {
          return addr;
        }
        if (addressPeerId !== peerId.toString()) {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const gatedAdrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.connectionGater.denyDialMultiaddr != null && await this.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAdrs.push(addr);
    }
    const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new CodeError("The connection gater denied all addresses in the dial request", codes5.ERR_NO_VALID_ADDRESSES);
    }
    return sortedGatedAddrs;
  }
  async performDial(pendingDial, options = {}) {
    const dialAbortControllers = pendingDial.multiaddrs.map(() => new AbortController());
    try {
      const peerDialQueue = new dist_default3({
        concurrency: this.maxParallelDialsPerPeer
      });
      peerDialQueue.on("error", (err) => {
        log12.error("error dialling", err);
      });
      const conn = await Promise.any(pendingDial.multiaddrs.map(async (addr, i) => {
        const controller = dialAbortControllers[i];
        if (controller == null) {
          throw new CodeError("dialAction did not come with an AbortController", codes5.ERR_INVALID_PARAMETERS);
        }
        const signal = combineSignals(controller.signal, options.signal);
        signal.addEventListener("abort", () => {
          log12("dial to %s aborted", addr);
        });
        const deferred = pDefer();
        await peerDialQueue.add(async () => {
          if (signal.aborted) {
            log12("dial to %s was aborted before reaching the head of the peer dial queue", addr);
            deferred.reject(new AbortError2());
            return;
          }
          await this.queue.add(async () => {
            try {
              if (signal.aborted) {
                log12("dial to %s was aborted before reaching the head of the dial queue", addr);
                deferred.reject(new AbortError2());
                return;
              }
              pendingDial.status = "active";
              const conn2 = await this.transportManager.dial(addr, {
                ...options,
                signal
              });
              if (controller.signal.aborted) {
                log12("multiple dials succeeded, closing superfluous connection");
                conn2.close().catch((err) => {
                  log12.error("error closing superfluous connection", err);
                });
                deferred.reject(new AbortError2());
                return;
              }
              dialAbortControllers[i] = void 0;
              dialAbortControllers.forEach((c) => {
                if (c !== void 0) {
                  c.abort();
                }
              });
              log12("dial to %s succeeded", addr);
              deferred.resolve(conn2);
            } catch (err) {
              log12.error("error during dial of %s", addr, err);
              deferred.reject(err);
            }
          }, {
            ...options,
            signal
          }).catch((err) => {
            deferred.reject(err);
          });
        }, {
          signal
        }).catch((err) => {
          deferred.reject(err);
        }).finally(() => {
          signal.clear();
        });
        return deferred.promise;
      }));
      if (conn == null) {
        throw new CodeError("successful dial led to empty object returned from peer dial queue", codes5.ERR_TRANSPORT_DIAL_FAILED);
      }
      pendingDial.status = "success";
      return conn;
    } catch (err) {
      pendingDial.status = "error";
      if (pendingDial.multiaddrs.length === 1 && err.name === "AggregateError") {
        throw err.errors[0];
      }
      throw err;
    }
  }
};
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
__name(randomId, "randomId");

// node_modules/libp2p/dist/src/connection-manager/index.js
var log13 = logger6("libp2p:connection-manager");
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions9 = {
  minConnections: MIN_CONNECTIONS,
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH
};
var DefaultConnectionManager = class {
  static {
    __name(this, "DefaultConnectionManager");
  }
  started;
  connections;
  allow;
  deny;
  maxIncomingPendingConnections;
  incomingPendingConnections;
  maxConnections;
  dialQueue;
  autoDial;
  connectionPruner;
  inboundConnectionRateLimiter;
  peerStore;
  metrics;
  events;
  constructor(components, init = {}) {
    this.maxConnections = init.maxConnections ?? defaultOptions9.maxConnections;
    const minConnections = init.minConnections ?? defaultOptions9.minConnections;
    if (this.maxConnections < minConnections) {
      throw new CodeError("Connection Manager maxConnections must be greater than minConnections", codes5.ERR_INVALID_PARAMETERS);
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    this.allow = (init.allow ?? []).map((ma) => multiaddr(ma));
    this.deny = (init.deny ?? []).map((ma) => multiaddr(ma));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions9.maxIncomingPendingConnections;
    this.inboundConnectionRateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: init.inboundConnectionThreshold ?? defaultOptions9.inboundConnectionThreshold,
      duration: 1
    });
    this.autoDial = new AutoDial({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events
    }, {
      minConnections,
      autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions9.autoDialConcurrency,
      autoDialPriority: init.autoDialPriority ?? defaultOptions9.autoDialPriority,
      maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions9.autoDialMaxQueueLength
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events
    }, {
      maxConnections: this.maxConnections,
      allow: this.allow
    });
    this.dialQueue = new DialQueue({
      peerId: components.peerId,
      metrics: components.metrics,
      peerStore: components.peerStore,
      transportManager: components.transportManager,
      connectionGater: components.connectionGater
    }, {
      addressSorter: init.addressSorter ?? publicAddressesFirst,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      }
    });
  }
  isStarted() {
    return this.started;
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.stat.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.autoDial.start();
    this.started = true;
    log13("started");
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE);
        }]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer.id).catch((err) => {
          log13.error(err);
        });
      }));
    }).catch((err) => {
      log13.error(err);
    });
    this.autoDial.afterStart();
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.dialQueue.stop();
    this.autoDial.stop();
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            log13.error(err);
          }
        })());
      }
    }
    log13("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    log13("stopped");
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      log13.error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId = connection.remotePeer;
    const storedConns = this.connections.get(peerId);
    let isNewPeer = false;
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      isNewPeer = true;
      this.connections.set(peerId, [connection]);
    }
    if (peerId.publicKey != null && peerId.type === "RSA") {
      await this.peerStore.patch(peerId, {
        publicKey: peerId.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId = connection.remotePeer;
    let storedConn = this.connections.get(peerId);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    if (!this.isStarted()) {
      throw new CodeError("Not started", codes5.ERR_NODE_NOT_STARTED);
    }
    const { peerId } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId != null) {
      log13("dial %p", peerId);
      const existingConnections = this.getConnections(peerId);
      if (existingConnections.length > 0) {
        log13("had an existing connection to %p", peerId);
        return existingConnections[0];
      }
    }
    const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
      ...options,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY
    });
    let peerConnections = this.connections.get(connection.remotePeer);
    if (peerConnections == null) {
      peerConnections = [];
      this.connections.set(connection.remotePeer, peerConnections);
    }
    let trackedConnection = false;
    for (const conn of peerConnections) {
      if (conn.id === connection.id) {
        trackedConnection = true;
      }
    }
    if (!trackedConnection) {
      peerConnections.push(connection);
    }
    return connection;
  }
  async closeConnections(peerId) {
    const connections = this.connections.get(peerId) ?? [];
    await Promise.all(connections.map(async (connection) => {
      await connection.close();
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (denyConnection) {
      log13("connection from %s refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      log13("connection from %s refused - incomingPendingConnections exceeded by peer %s", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        log13("connection from %s refused - inboundConnectionThreshold exceeded by host %s", host, maConn.remoteAddr);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    log13("connection from %s refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    return this.dialQueue.pendingDials;
  }
};

// node_modules/libp2p/dist/src/content-routing/utils.js
async function* storeAddresses(source, peerStore) {
  yield* src_default9(source, async (peer) => {
    await peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs
    });
    return peer;
  });
}
__name(storeAddresses, "storeAddresses");
function uniquePeers(source) {
  const seen = /* @__PURE__ */ new Set();
  return src_default4(source, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
__name(uniquePeers, "uniquePeers");
async function* requirePeers(source, min = 1) {
  let seen = 0;
  for await (const peer of source) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw new CodeError(`more peers required, seen: ${seen}  min: ${min}`, "NOT_FOUND");
  }
}
__name(requirePeers, "requirePeers");

// node_modules/libp2p/dist/src/content-routing/index.js
var CompoundContentRouting = class {
  static {
    __name(this, "CompoundContentRouting");
  }
  routers;
  started;
  components;
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(src_default5(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.provide(key, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw new CodeError(messages.NOT_STARTED_YET, codes5.DHT_NOT_STARTED);
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.put(key, value, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw new CodeError(messages.NOT_STARTED_YET, codes5.DHT_NOT_STARTED);
    }
    return Promise.any(this.routers.map(async (router) => {
      return router.get(key, options);
    }));
  }
};

// node_modules/it-first/dist/src/index.js
function isAsyncIterable11(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable11, "isAsyncIterable");
function first(source) {
  if (isAsyncIterable11(source)) {
    return (async () => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    })();
  }
  for (const entry of source) {
    return entry;
  }
  return void 0;
}
__name(first, "first");
var src_default12 = first;

// node_modules/libp2p/dist/src/peer-routing.js
var log14 = logger6("libp2p:peer-routing");
var DefaultPeerRouting = class {
  static {
    __name(this, "DefaultPeerRouting");
  }
  components;
  routers;
  constructor(components, init) {
    this.components = components;
    this.routers = init.routers ?? [];
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.peerId.toString()) {
      throw new CodeError("Should not try to find self", codes5.ERR_FIND_SELF);
    }
    const output3 = await pipe(src_default5(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        log14.error(err);
      }
    }())), (source) => src_default4(source, Boolean), (source) => storeAddresses(source, this.components.peerStore), async (source) => src_default12(source));
    if (output3 != null) {
      return output3;
    }
    throw new CodeError(messages.NOT_FOUND, codes5.ERR_NOT_FOUND);
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(src_default5(...this.routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
};

// node_modules/libp2p/dist/src/registrar.js
var log15 = logger6("libp2p:registrar");
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var DefaultRegistrar = class {
  static {
    __name(this, "DefaultRegistrar");
  }
  topologies;
  handlers;
  components;
  constructor(components) {
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:connect", this._onConnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new CodeError(`No handler registered for protocol ${protocol}`, codes5.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol)) {
      throw new CodeError(`Handler already registered for protocol ${protocol}`, codes5.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS2,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS2
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    });
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: protocolList
    });
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (!isTopology(topology)) {
      log15.error("topology must be an instance of interfaces/topology");
      throw new CodeError("topology must be an instance of interfaces/topology", codes5.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    await topology.setRegistrar(this);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    void this.components.peerStore.get(remotePeer).then((peer) => {
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect(remotePeer);
        }
      }
    }).catch((err) => {
      if (err.code === codes5.ERR_NOT_FOUND) {
        return;
      }
      log15.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * On peer connected if we already have their protocols. Usually used for reconnects
   * as change:protocols event won't be emitted due to identical protocols.
   */
  _onConnect(evt) {
    const remotePeer = evt.detail;
    void this.components.peerStore.get(remotePeer).then((peer) => {
      const connection = this.components.connectionManager.getConnections(peer.id)[0];
      if (connection == null) {
        log15("peer %p connected but the connection manager did not have a connection", peer);
        return;
      }
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onConnect(remotePeer, connection);
        }
      }
    }).catch((err) => {
      if (err.code === codes5.ERR_NOT_FOUND) {
        return;
      }
      log15.error("could not inform topologies of connecting peer %p", remotePeer, err);
    });
  }
  /**
   * Check if a new peer support the multicodecs for this topology
   */
  _onPeerUpdate(evt) {
    const { peer, previous } = evt.detail;
    const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    const added = peer.protocols.filter((protocol) => !(previous?.protocols ?? []).includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        topology.onDisconnect(peer.id);
      }
    }
    for (const protocol of added) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        const connection = this.components.connectionManager.getConnections(peer.id)[0];
        if (connection == null) {
          continue;
        }
        topology.onConnect(peer.id, connection);
      }
    }
  }
};

// node_modules/libp2p/dist/src/transport-manager.js
var log16 = logger6("libp2p:transports");
var DefaultTransportManager = class {
  static {
    __name(this, "DefaultTransportManager");
  }
  components;
  transports;
  listeners;
  faultTolerance;
  started;
  constructor(components, init = {}) {
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new CodeError("Transport must have a valid tag", codes5.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw new CodeError(`There is already a transport with the tag ${tag}`, codes5.ERR_DUPLICATE_TRANSPORT);
    }
    log16("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      log16("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log16("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw new CodeError(`No transport available for address ${String(ma)}`, codes5.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    } catch (err) {
      if (err.code == null) {
        err.code = codes5.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err;
    }
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (addrs == null || addrs.length === 0) {
      log16("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log16("creating listener for %s on %s", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await Promise.allSettled(tasks);
      const isListening = results.find((r) => r.status === "fulfilled");
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw new CodeError(`Transport (${key}) could not listen on any available address`, codes5.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw new CodeError(message2, codes5.ERR_NO_VALID_ADDRESSES);
      }
      log16(`libp2p in dial mode only: ${message2}`);
    }
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    log16("removing %s", key);
    for (const listener of this.listeners.get(key) ?? []) {
      await listener.close();
    }
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};

// node_modules/libp2p/dist/src/upgrader.js
var import_events6 = __toESM(require_events(), 1);

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/@libp2p/multistream-select/node_modules/@libp2p/logger/dist/src/index.js
var import_debug5 = __toESM(require_browser(), 1);

// node_modules/@libp2p/multistream-select/node_modules/multiformats/vendor/base-x.js
function base18(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base18, "base");
var src15 = base18;
var _brrp__multiformats_scope_baseX15 = src15;
var base_x_default15 = _brrp__multiformats_scope_baseX15;

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bytes.js
var empty15 = new Uint8Array(0);
var coerce15 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base.js
var Encoder15 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder15 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or15(this, decoder);
  }
};
var ComposedDecoder15 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or15(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or15 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder15(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec15 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder15(name14, prefix, baseEncode);
    this.decoder = new Decoder15(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from23 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec15(name14, prefix, encode79, decode97), "from");
var baseX15 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default15(alphabet11, name14);
  return from23({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce15(decode97(text))
  });
}, "baseX");
var decode55 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode44 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464815 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from23({
    prefix,
    name: name14,
    encode(input) {
      return encode44(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode55(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base58.js
var base58btc15 = baseX15({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr15 = baseX15({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base32.js
var base3214 = rfc464815({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper14 = rfc464815({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad14 = rfc464815({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper14 = rfc464815({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex14 = rfc464815({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper14 = rfc464815({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad14 = rfc464815({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper14 = rfc464815({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z14 = rfc464815({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/src/bases/base64.js
var base6414 = rfc464815({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad14 = rfc464815({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url14 = rfc464815({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad14 = rfc464815({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/multistream-select/node_modules/@libp2p/logger/dist/src/index.js
import_debug5.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc15.baseEncode(v);
};
import_debug5.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3214.baseEncode(v);
};
import_debug5.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6414.baseEncode(v);
};
import_debug5.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug5.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug5.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug5.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger7(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger7, "createDisabledLogger");
function logger8(name14) {
  let trace = createDisabledLogger7(`${name14}:trace`);
  if (import_debug5.default.enabled(`${name14}:trace`) && import_debug5.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug5.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug5.default)(name14), {
    error: (0, import_debug5.default)(`${name14}:error`),
    trace
  });
}
__name(logger8, "logger");

// node_modules/it-reader/dist/src/index.js
function reader(source) {
  const reader2 = async function* () {
    let bytes3 = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source) {
      if (bytes3 == null) {
        bl.append(chunk);
        bytes3 = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes3) {
        const data = bl.sublist(0, bytes3);
        bl.consume(bytes3);
        bytes3 = yield data;
        if (bytes3 == null) {
          if (bl.length > 0) {
            bytes3 = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes3 != null) {
      throw Object.assign(new Error(`stream ended before ${bytes3} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader2.next();
  return reader2;
}
__name(reader, "reader");

// node_modules/it-handshake/dist/src/index.js
function handshake(stream) {
  const writer = pushable();
  const source = reader(stream.source);
  const sourcePromise = pDefer();
  let sinkErr;
  const sinkPromise = stream.sink(async function* () {
    yield* writer;
    const source2 = await sourcePromise.promise;
    yield* source2;
  }());
  sinkPromise.catch((err) => {
    sinkErr = err;
  });
  const rest = {
    sink: async (source2) => {
      if (sinkErr != null) {
        await Promise.reject(sinkErr);
        return;
      }
      sourcePromise.resolve(source2);
      await sinkPromise;
    },
    source
  };
  return {
    reader: source,
    writer,
    stream: rest,
    rest: () => writer.end(),
    write: writer.push,
    read: async () => {
      const res = await source.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}
__name(handshake, "handshake");

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var log17 = logger8("libp2p:mss");
var NewLine = fromString7("\n");
function encode45(buffer3) {
  const list = new Uint8ArrayList(buffer3, NewLine);
  return encode16.single(list);
}
__name(encode45, "encode");
function write2(writer, buffer3, options = {}) {
  const encoded = encode45(buffer3);
  if (options.writeBytes === true) {
    writer.push(encoded.subarray());
  } else {
    writer.push(encoded);
  }
}
__name(write2, "write");
function writeAll(writer, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf3 of buffers) {
    list.append(encode45(buf3));
  }
  if (options.writeBytes === true) {
    writer.push(list.subarray());
  } else {
    writer.push(list);
  }
}
__name(writeAll, "writeAll");
async function read12(reader2, options) {
  let byteLength = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => reader2.next(byteLength)
  };
  let input = varByteSource;
  if (options?.signal != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = /* @__PURE__ */ __name((l) => {
    byteLength = l;
  }, "onLength");
  const buf3 = await pipe(input, (source) => decode21(source, { onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source) => src_default12(source));
  if (buf3 == null || buf3.length === 0) {
    throw new CodeError("no buffer returned", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf3.get(buf3.byteLength - 1) !== NewLine[0]) {
    log17.error("Invalid mss message - missing newline - %s", buf3.subarray());
    throw new CodeError("missing newline", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf3.sublist(0, -1);
}
__name(read12, "read");
async function readString(reader2, options) {
  const buf3 = await read12(reader2, options);
  return toString5(buf3.subarray());
}
__name(readString, "readString");

// node_modules/@libp2p/multistream-select/dist/src/select.js
var log18 = logger8("libp2p:mss:select");
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader2, writer, rest, stream: shakeStream } = handshake(stream);
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  log18.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString7(PROTOCOL_ID);
  const p2 = fromString7(protocol);
  writeAll(writer, [p1, p2], options);
  let response = await readString(reader2, options);
  log18.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader2, options);
    log18.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    rest();
    return { stream: shakeStream, protocol };
  }
  for (const protocol2 of protocols) {
    log18.trace('select: write "%s"', protocol2);
    write2(writer, fromString7(protocol2), options);
    const response2 = await readString(reader2, options);
    log18.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      rest();
      return { stream: shakeStream, protocol: protocol2 };
    }
  }
  rest();
  throw new CodeError("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
}
__name(select, "select");

// node_modules/@libp2p/multistream-select/dist/src/handle.js
var log19 = logger8("libp2p:mss:handle");
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer, reader: reader2, rest, stream: shakeStream } = handshake(stream);
  while (true) {
    const protocol = await readString(reader2, options);
    log19.trace('read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      log19.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      write2(writer, fromString7(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol)) {
      write2(writer, fromString7(protocol), options);
      log19.trace('respond with "%s" for "%s"', protocol, protocol);
      rest();
      return { stream: shakeStream, protocol };
    }
    if (protocol === "ls") {
      write2(writer, new Uint8ArrayList(...protocols.map((p) => encode45(fromString7(p)))), options);
      log19.trace('respond with "%s" for %s', protocols, protocol);
      continue;
    }
    write2(writer, fromString7("na"), options);
    log19('respond with "na" for "%s"', protocol);
  }
}
__name(handle, "handle");

// node_modules/@libp2p/interface-connection/dist/src/index.js
var symbol5 = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/interface-connection/dist/src/status.js
var OPEN = "OPEN";
var CLOSING = "CLOSING";
var CLOSED = "CLOSED";

// node_modules/libp2p/dist/src/connection/index.js
var log20 = logger6("libp2p:connection");
var ConnectionImpl = class {
  static {
    __name(this, "ConnectionImpl");
  }
  /**
   * Connection identifier.
   */
  id;
  /**
   * Observed multiaddr of the remote peer
   */
  remoteAddr;
  /**
   * Remote peer id
   */
  remotePeer;
  /**
   * Connection metadata
   */
  stat;
  /**
   * User provided tags
   *
   */
  tags;
  /**
   * Reference to the new stream function of the multiplexer
   */
  _newStream;
  /**
   * Reference to the close function of the raw connection
   */
  _close;
  /**
   * Reference to the getStreams function of the muxer
   */
  _getStreams;
  _closing;
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.stat = {
      ...stat,
      status: OPEN
    };
    this._newStream = newStream;
    this._close = close;
    this._getStreams = getStreams;
    this.tags = [];
    this._closing = false;
  }
  [Symbol.toStringTag] = "Connection";
  [symbol5] = true;
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols, options) {
    if (this.stat.status === CLOSING) {
      throw new CodeError("the connection is being closed", "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.stat.status === CLOSED) {
      throw new CodeError("the connection is closed", "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    const stream = await this._newStream(protocols, options);
    stream.stat.direction = "outbound";
    return stream;
  }
  /**
   * Add a stream when it is opened to the registry
   */
  addStream(stream) {
    stream.stat.direction = "inbound";
  }
  /**
   * Remove stream registry after it is closed
   */
  removeStream(id) {
  }
  /**
   * Close the connection
   */
  async close() {
    if (this.stat.status === CLOSED || this._closing) {
      return;
    }
    this.stat.status = CLOSING;
    try {
      this.streams.forEach((s2) => {
        s2.close();
      });
    } catch (err) {
      log20.error(err);
    }
    this._closing = true;
    await this._close();
    this._closing = false;
    this.stat.timeline.close = Date.now();
    this.stat.status = CLOSED;
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}
__name(createConnection, "createConnection");

// node_modules/libp2p/dist/src/upgrader.js
var log21 = logger6("libp2p:upgrader");
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err) {
    if (err.code !== codes5.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS2;
}
__name(findIncomingStreamLimit, "findIncomingStreamLimit");
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.code !== codes5.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
}
__name(findOutgoingStreamLimit, "findOutgoingStreamLimit");
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
__name(countStreams, "countStreams");
var DefaultUpgrader = class {
  static {
    __name(this, "DefaultUpgrader");
  }
  components;
  connectionEncryption;
  muxers;
  inboundUpgradeTimeout;
  events;
  constructor(components, init) {
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.events = components.events;
  }
  async shouldBlockConnection(remotePeer, maConn, connectionType) {
    const connectionGater2 = this.components.connectionGater[connectionType];
    if (connectionGater2 !== void 0) {
      if (await connectionGater2(remotePeer, maConn)) {
        throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes5.ERR_CONNECTION_INTERCEPTED);
      }
    }
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
    if (!accept) {
      throw new CodeError("connection denied", codes5.ERR_CONNECTION_DENIED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    const signal = anySignal([AbortSignal.timeout(this.inboundUpgradeTimeout)]);
    try {
      (0, import_events6.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    try {
      const abortableStream = abortableDuplex(maConn, signal);
      maConn.source = abortableStream.source;
      maConn.sink = abortableStream.sink;
      if (await this.components.connectionGater.denyInboundConnection?.(maConn) === true) {
        throw new CodeError("The multiaddr connection is blocked by gater.acceptConnection", codes5.ERR_CONNECTION_INTERCEPTED);
      }
      this.components.metrics?.trackMultiaddrConnection(maConn);
      log21("starting the inbound connection upgrade");
      let protectedConn = maConn;
      if (opts?.skipProtection !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          log21("protecting the inbound connection");
          protectedConn = await protector.protect(maConn);
        }
      }
      try {
        encryptedConn = protectedConn;
        if (opts?.skipEncryption !== true) {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptInbound(protectedConn));
          const maConn2 = {
            ...protectedConn,
            ...encryptedConn
          };
          await this.shouldBlockConnection(remotePeer, maConn2, "denyInboundEncryptedConnection");
        } else {
          const idStr = maConn.remoteAddr.getPeerId();
          if (idStr == null) {
            throw new CodeError("inbound connection that skipped encryption must have a peer id", codes5.ERR_INVALID_MULTIADDR);
          }
          const remotePeerId = peerIdFromString(idStr);
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        upgradedConn = encryptedConn;
        if (opts?.muxerFactory != null) {
          muxerFactory = opts.muxerFactory;
        } else if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err) {
        log21.error("Failed to upgrade inbound connection", err);
        throw err;
      }
      await this.shouldBlockConnection(remotePeer, maConn, "denyInboundUpgradedConnection");
      log21("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer
      });
    } finally {
      this.components.connectionManager.afterUpgradeInbound();
      signal.clear();
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    const idStr = maConn.remoteAddr.getPeerId();
    let remotePeerId;
    if (idStr != null) {
      remotePeerId = peerIdFromString(idStr);
      await this.shouldBlockConnection(remotePeerId, maConn, "denyOutboundConnection");
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    this.components.metrics?.trackMultiaddrConnection(maConn);
    log21("Starting the outbound connection upgrade");
    let protectedConn = maConn;
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        protectedConn = await protector.protect(maConn);
      }
    }
    try {
      encryptedConn = protectedConn;
      if (opts?.skipEncryption !== true) {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(protectedConn, remotePeerId));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(remotePeer, maConn2, "denyOutboundEncryptedConnection");
      } else {
        if (remotePeerId == null) {
          throw new CodeError("Encryption was skipped but no peer id was passed", codes5.ERR_INVALID_PEER);
        }
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      upgradedConn = encryptedConn;
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      log21.error("Failed to upgrade outbound connection", err);
      await maConn.close(err);
      throw err;
    }
    await this.shouldBlockConnection(remotePeer, maConn, "denyOutboundUpgradedConnection");
    log21("Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.registrar.getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols);
            log21("%s: incoming stream opened on %s", direction, protocol);
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new CodeError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`, codes5.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.stat.protocol = protocol;
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            connection.addStream(muxedStream);
            this.components.metrics?.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch((err) => {
            log21.error(err);
            if (muxedStream.stat.timeline.close == null) {
              muxedStream.close();
            }
          });
        },
        // Run anytime a stream closes
        onStreamEnd: (muxedStream) => {
          connection?.removeStream(muxedStream.id);
        }
      });
      newStream = /* @__PURE__ */ __name(async (protocols, options = {}) => {
        if (muxer == null) {
          throw new CodeError("Stream is not multiplexed", codes5.ERR_MUXER_UNAVAILABLE);
        }
        log21("%s: starting new stream on %s", direction, protocols);
        const muxedStream = await muxer.newStream();
        try {
          if (options.signal == null) {
            log21("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            options.signal = AbortSignal.timeout(3e4);
            try {
              (0, import_events6.setMaxListeners)?.(Infinity, options.signal);
            } catch {
            }
          }
          const { stream, protocol } = await select(muxedStream, protocols, options);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new CodeError(`Too many outbound protocol streams for protocol "${protocol}" - limit ${outgoingLimit}`, codes5.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.stat.protocol = protocol;
          this.components.metrics?.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          log21.error("could not create new stream", err);
          if (muxedStream.stat.timeline.close == null) {
            muxedStream.close();
          }
          if (err.code != null) {
            throw err;
          }
          throw new CodeError(String(err), codes5.ERR_UNSUPPORTED_PROTOCOL);
        }
      }, "newStream");
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        log21.error(err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.stat.status === "OPEN") {
                await connection.close();
              }
            } catch (err) {
              log21.error(err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            log21.error(err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = /* @__PURE__ */ __name(() => {
      throw new CodeError("connection is not multiplexed", codes5.ERR_CONNECTION_NOT_MULTIPLEXED);
    }, "errConnectionNotMultiplexed");
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      stat: {
        status: "OPEN",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol
      },
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        if (muxer != null) {
          return muxer.streams;
        } else {
          return errConnectionNotMultiplexed();
        }
      },
      close: async () => {
        await maConn.close();
        if (muxer != null) {
          muxer.close();
        }
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler } = this.components.registrar.getHandler(protocol);
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log21("handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      log21("encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.peerId, stream),
        protocol
      };
    } catch (err) {
      throw new CodeError(String(err), codes5.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log21("selecting outbound crypto protocol", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      log21("encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
        protocol
      };
    } catch (err) {
      throw new CodeError(String(err), codes5.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log21("outbound selecting muxer %s", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      log21("%s selected as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      log21.error("error multiplexing outbound stream", err);
      throw new CodeError(String(err), codes5.ERR_MUXER_UNAVAILABLE);
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log21("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      log21.error("error multiplexing inbound stream", err);
      throw new CodeError(String(err), codes5.ERR_MUXER_UNAVAILABLE);
    }
  }
};

// node_modules/libp2p/dist/src/libp2p.js
var log22 = logger6("libp2p");
var Libp2pNode = class extends EventEmitter6 {
  static {
    __name(this, "Libp2pNode");
  }
  peerId;
  peerStore;
  contentRouting;
  peerRouting;
  keychain;
  metrics;
  services;
  components;
  #started;
  constructor(init) {
    super();
    const events2 = new EventEmitter6();
    const originalDispatch = events2.dispatchEvent.bind(events2);
    events2.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    try {
      (0, import_events7.setMaxListeners)?.(Infinity, events2);
    } catch {
    }
    this.#started = false;
    this.peerId = init.peerId;
    this.services = {};
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      events: events2,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater)
    });
    this.peerStore = this.configureComponent("peerStore", new PersistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        this.safeDispatchEvent("peer:discovery", { detail: evt.detail.peer });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    this.configureComponent("registrar", new DefaultRegistrar(this.components));
    this.configureComponent("addressManager", new DefaultAddressManager(this.components, init.addresses));
    const keychainOpts = DefaultKeyChain.generateOptions();
    this.keychain = this.configureComponent("keyChain", new DefaultKeyChain(this.components, {
      ...keychainOpts,
      ...init.keychain
    }));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        this.#onDiscoveryPeer(evt);
      });
    });
    init.transports.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name14 of Object.keys(init.services)) {
        const createService = init.services[name14];
        const service = createService(this.components);
        if (service == null) {
          log22.error("service factory %s returned null or undefined instance", name14);
          continue;
        }
        this.services[name14] = service;
        this.configureComponent(name14, service);
        if (service[contentRouting] != null) {
          log22("registering service %s for content routing", name14);
          contentRouters.push(service[contentRouting]);
        }
        if (service[peerRouting] != null) {
          log22("registering service %s for peer routing", name14);
          peerRouters.push(service[peerRouting]);
        }
        if (service[peerDiscovery] != null) {
          log22("registering service %s for peer discovery", name14);
          service[peerDiscovery].addEventListener("peer", (evt) => {
            this.#onDiscoveryPeer(evt);
          });
        }
      }
    }
  }
  configureComponent(name14, component) {
    if (component == null) {
      log22.error("component %s was null or undefined", name14);
    }
    this.components[name14] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    if (this.#started) {
      return;
    }
    this.#started = true;
    log22("libp2p is starting");
    const keys = await this.keychain.listKeys();
    if (keys.find((key) => key.name === "self") == null) {
      log22("importing self key into keychain");
      await this.keychain.importPeer("self", this.components.peerId);
    }
    try {
      await this.components.beforeStart?.();
      await this.components.start();
      await this.components.afterStart?.();
      this.safeDispatchEvent("start", { detail: this });
      log22("libp2p has started");
    } catch (err) {
      log22.error("An error occurred starting libp2p", err);
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    if (!this.#started) {
      return;
    }
    log22("libp2p is stopping");
    this.#started = false;
    await this.components.beforeStop?.();
    await this.components.stop();
    await this.components.afterStop?.();
    this.safeDispatchEvent("stop", { detail: this });
    log22("libp2p has stopped");
  }
  isStarted() {
    return this.#started;
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw new CodeError("no protocols were provided to open a stream", codes5.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new CodeError("no protocols were provided to open a stream", codes5.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer);
  }
  /**
   * Get the public key for the given peer id
   */
  async getPublicKey(peer, options = {}) {
    log22("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.id.publicKey != null) {
      return peerInfo.id.publicKey;
    }
    const peerKey = concat3([
      fromString7("/pk/"),
      peer.multihash.digest
    ]);
    const bytes3 = await this.contentRouting.get(peerKey, options);
    unmarshalPublicKey2(bytes3);
    await this.peerStore.patch(peer, {
      publicKey: bytes3
    });
    return bytes3;
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol);
    }));
  }
  async register(protocol, topology) {
    return this.components.registrar.register(protocol, topology);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  /**
   * Called whenever peer discovery services emit `peer` events and adds peers
   * to the peer store.
   */
  #onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log22.error(new Error(codes5.ERR_DISCOVERED_SELF));
      return;
    }
    void this.components.peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs,
      protocols: peer.protocols
    }).catch((err) => {
      log22.error(err);
    });
  }
};
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    const datastore = options.datastore;
    if (datastore != null) {
      try {
        const keyChain = new DefaultKeyChain({
          datastore
        }, merge_options_default(DefaultKeyChain.generateOptions(), options.keychain));
        options.peerId = await keyChain.exportPeerId("self");
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
  }
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}
__name(createLibp2pNode, "createLibp2pNode");

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options) {
  const node = await createLibp2pNode(options);
  if (options.start !== false) {
    await node.start();
  }
  return node;
}
__name(createLibp2p, "createLibp2p");

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/logger/dist/src/index.js
var import_debug6 = __toESM(require_browser(), 1);

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/vendor/base-x.js
function base19(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base19, "base");
var src16 = base19;
var _brrp__multiformats_scope_baseX16 = src16;
var base_x_default16 = _brrp__multiformats_scope_baseX16;

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bytes.js
var empty16 = new Uint8Array(0);
var coerce16 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bases/base.js
var Encoder16 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder16 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or16(this, decoder);
  }
};
var ComposedDecoder16 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or16(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or16 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder16(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec16 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder16(name14, prefix, baseEncode);
    this.decoder = new Decoder16(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from24 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec16(name14, prefix, encode79, decode97), "from");
var baseX16 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default16(alphabet11, name14);
  return from24({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce16(decode97(text))
  });
}, "baseX");
var decode56 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode46 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464816 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from24({
    prefix,
    name: name14,
    encode(input) {
      return encode46(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode56(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bases/base58.js
var base58btc16 = baseX16({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr16 = baseX16({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bases/base32.js
var base3215 = rfc464816({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper15 = rfc464816({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad15 = rfc464816({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper15 = rfc464816({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex15 = rfc464816({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper15 = rfc464816({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad15 = rfc464816({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper15 = rfc464816({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z15 = rfc464816({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bases/base64.js
var base6415 = rfc464816({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad15 = rfc464816({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url15 = rfc464816({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad15 = rfc464816({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/logger/dist/src/index.js
import_debug6.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc16.baseEncode(v);
};
import_debug6.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3215.baseEncode(v);
};
import_debug6.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6415.baseEncode(v);
};
import_debug6.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug6.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug6.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug6.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger8(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger8, "createDisabledLogger");
function logger9(name14) {
  let trace = createDisabledLogger8(`${name14}:trace`);
  if (import_debug6.default.enabled(`${name14}:trace`) && import_debug6.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug6.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug6.default)(name14), {
    error: (0, import_debug6.default)(`${name14}:error`),
    trace
  });
}
__name(logger9, "logger");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js
var MessageCache = class {
  static {
    __name(this, "MessageCache");
  }
  /**
   * Holds history of messages in timebounded history arrays
   */
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    this.gossip = gossip;
    this.msgs = /* @__PURE__ */ new Map();
    this.history = [];
    this.notValidatedCount = 0;
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i = 0; i < historyCapacity; i++) {
      this.history[i] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  /**
   * Adds a message to the current window and the cache
   * Returns true if the message is not known and is inserted in the cache
   */
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    if (!validated) {
      this.notValidatedCount++;
    }
    return true;
  }
  observeDuplicate(msgId2, fromPeerIdStr) {
    const entry = this.msgs.get(msgId2);
    if (entry && // if the message is already validated, we don't need to store extra peers sending us
    // duplicates as the message has already been forwarded
    !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  /**
   * Retrieves a message from the cache by its ID, if it is still present
   */
  get(msgId2) {
    return this.msgs.get(this.msgIdToStrFn(msgId2))?.message;
  }
  /**
   * Increases the iwant count for the given message by one and returns the message together
   * with the iwant if the message exists.
   */
  getWithIWantCount(msgIdStr, p) {
    const msg = this.msgs.get(msgIdStr);
    if (!msg) {
      return null;
    }
    const count = (msg.iwantCounts.get(p) ?? 0) + 1;
    msg.iwantCounts.set(p, count);
    return { msg: msg.message, count };
  }
  /**
   * Retrieves a list of message IDs for a set of topics
   */
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.gossip; i++) {
      this.history[i].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if (msg && msg.validated && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (!msgIds) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  /**
   * Gets a message with msgId and tags it as validated.
   * This function also returns the known peers that have sent us this message. This is used to
   * prevent us sending redundant messages to peers who have already propagated it.
   */
  validate(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    if (!entry.validated) {
      this.notValidatedCount--;
    }
    const { message: message2, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message2, originatingPeers };
  }
  /**
   * Shifts the current window, discarding messages older than this.history.length of the cache
   */
  shift() {
    const lastCacheEntries = this.history[this.history.length - 1];
    lastCacheEntries.forEach((cacheEntry) => {
      const entry = this.msgs.get(cacheEntry.msgIdStr);
      if (entry) {
        this.msgs.delete(cacheEntry.msgIdStr);
        if (!entry.validated) {
          this.notValidatedCount--;
        }
      }
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    this.msgs.delete(msgId2);
    return entry;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js
var import_rpc = __toESM(require_rpc2(), 1);
var { RPC } = import_rpc.default;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var FloodsubID = "/floodsub/1.0.0";
var GossipsubIDv10 = "/meshsub/1.0.0";
var GossipsubIDv11 = "/meshsub/1.1.0";
var GossipsubD = 6;
var GossipsubDlo = 4;
var GossipsubDhi = 12;
var GossipsubDscore = 4;
var GossipsubDout = 2;
var GossipsubHistoryLength = 5;
var GossipsubHistoryGossip = 3;
var GossipsubDlazy = 6;
var GossipsubGossipFactor = 0.25;
var GossipsubGossipRetransmission = 3;
var GossipsubHeartbeatInitialDelay = 100;
var GossipsubHeartbeatInterval = second;
var GossipsubFanoutTTL = minute;
var GossipsubPrunePeers = 16;
var GossipsubPruneBackoff = minute;
var GossipsubPruneBackoffTicks = 15;
var GossipsubConnectionTimeout = 30 * second;
var GossipsubDirectConnectTicks = 300;
var GossipsubDirectConnectInitialDelay = second;
var GossipsubOpportunisticGraftTicks = 60;
var GossipsubOpportunisticGraftPeers = 2;
var GossipsubGraftFloodThreshold = 10 * second;
var GossipsubMaxIHaveLength = 5e3;
var GossipsubMaxIHaveMessages = 10;
var GossipsubIWantFollowupTime = 3 * second;
var GossipsubSeenTTL = 2 * minute;
var TimeCacheDuration = 120 * 1e3;
var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
var ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = /* @__PURE__ */ __name(() => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  }, "randInt");
  for (let i = 0; i < arr.length; i++) {
    const j = randInt();
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}
__name(shuffle, "shuffle");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js
function messageIdToString(msgId2) {
  return toString5(msgId2, "base64");
}
__name(messageIdToString, "messageIdToString");

// node_modules/@libp2p/interface-pubsub/dist/src/index.js
var StrictSign = "StrictSign";
var StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case TopicValidatorResult.Ignore:
      return RejectReason.Ignore;
    case TopicValidatorResult.Reject:
      return RejectReason.Reject;
  }
}
__name(rejectReasonFromAcceptance, "rejectReasonFromAcceptance");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js
async function getPublishConfigFromPeerId(signaturePolicy, peerId) {
  switch (signaturePolicy) {
    case StrictSign: {
      if (!peerId) {
        throw Error("Must provide PeerId");
      }
      if (peerId.privateKey == null) {
        throw Error("Cannot sign message, no private key present");
      }
      if (peerId.publicKey == null) {
        throw Error("Cannot sign message, no public key present");
      }
      const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: peerId.publicKey,
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}
__name(getPublishConfigFromPeerId, "getPublishConfigFromPeerId");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/constants.js
var ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
var defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
var defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p,
    topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
__name(createPeerScoreParams, "createPeerScoreParams");
function createTopicScoreParams(p = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p
  };
}
__name(createTopicScoreParams, "createTopicScoreParams");
function validatePeerScoreParams(p) {
  for (const [topic, params] of Object.entries(p.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e) {
      throw new CodeError(`invalid score parameters for topic ${topic}: ${e.message}`, ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  if (p.topicScoreCap < 0) {
    throw new CodeError("invalid topic score cap; must be positive (or 0 for no cap)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
    throw new CodeError("missing application specific score function", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight > 0) {
    throw new CodeError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
    throw new CodeError("invalid IPColocationFactorThreshold; must be at least 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight > 0) {
    throw new CodeError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
    throw new CodeError("invalid BehaviourPenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayInterval < 1e3) {
    throw new CodeError("invalid DecayInterval; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayToZero <= 0 || p.decayToZero >= 1) {
    throw new CodeError("invalid DecayToZero; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
__name(validatePeerScoreParams, "validatePeerScoreParams");
function validateTopicScoreParams(p) {
  if (p.topicWeight < 0) {
    throw new CodeError("invalid topic weight; must be >= 0", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshQuantum === 0) {
    throw new CodeError("invalid TimeInMeshQuantum; must be non zero", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight < 0) {
    throw new CodeError("invalid TimeInMeshWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
    throw new CodeError("invalid TimeInMeshQuantum; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
    throw new CodeError("invalid TimeInMeshCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight < 0) {
    throw new CodeError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
    throw new CodeError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
    throw new CodeError("invalid FirstMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight > 0) {
    throw new CodeError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
    throw new CodeError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
    throw new CodeError("invalid MeshMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
    throw new CodeError("invalid MeshMessageDeliveriesThreshold; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWindow < 0) {
    throw new CodeError("invalid MeshMessageDeliveriesWindow; must be non-negative", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
    throw new CodeError("invalid MeshMessageDeliveriesActivation; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight > 0) {
    throw new CodeError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
    throw new CodeError("invalid MeshFailurePenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesWeight > 0) {
    throw new CodeError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
    throw new CodeError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
__name(validateTopicScoreParams, "validateTopicScoreParams");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js
var defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p
  };
}
__name(createPeerScoreThresholds, "createPeerScoreThresholds");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}
__name(computeScore, "computeScore");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js
var import_denque = __toESM(require_denque(), 1);
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
var MessageDeliveries = class {
  static {
    __name(this, "MessageDeliveries");
  }
  constructor() {
    this.records = /* @__PURE__ */ new Map();
    this.queue = new import_denque.default();
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeen: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
__name(removeItemsFromSet, "removeItemsFromSet");
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
__name(removeFirstNItemsFromSet, "removeFirstNItemsFromSet");
var MapDef = class extends Map {
  static {
    __name(this, "MapDef");
  }
  constructor(getDefault) {
    super();
    this.getDefault = getDefault;
  }
  getOrDefault(key) {
    let value = super.get(key);
    if (value === void 0) {
      value = this.getDefault();
      this.set(key, value);
    }
    return value;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
var log23 = logger9("libp2p:gossipsub:score");
var PeerScore = class {
  static {
    __name(this, "PeerScore");
  }
  constructor(params, metrics, opts) {
    this.params = params;
    this.metrics = metrics;
    this.peerStats = /* @__PURE__ */ new Map();
    this.peerIPs = new MapDef(() => /* @__PURE__ */ new Set());
    this.scoreCache = /* @__PURE__ */ new Map();
    this.deliveryRecords = new MessageDeliveries();
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
  }
  get size() {
    return this.peerStats.size;
  }
  /**
   * Start PeerScore instance
   */
  start() {
    if (this._backgroundInterval) {
      log23("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
    log23("started");
  }
  /**
   * Stop PeerScore instance
   */
  stop() {
    if (!this._backgroundInterval) {
      log23("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    log23("stopped");
  }
  /**
   * Periodic maintenance
   */
  background() {
    this.refreshScores();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  /**
   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
   */
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPsForPeer(id, pstats.knownIPs);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  /**
   * Return the score for a peer
   */
  score(id) {
    this.metrics?.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    this.metrics?.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry) {
      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  /**
   * Apply a behavioural penalty to a peer
   */
  addPenalty(id, penalty, penaltyLabel) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.behaviourPenalty += penalty;
      this.metrics?.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      knownIPs: /* @__PURE__ */ new Set(),
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
  }
  /** Adds a new IP to a peer, if the peer is not known the update is ignored */
  addIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.knownIPs.add(ip);
    }
    this.peerIPs.getOrDefault(ip).add(id);
  }
  /** Remove peer association with IP */
  removeIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.knownIPs.delete(ip);
    }
    const peersWithIP = this.peerIPs.get(ip);
    if (peersWithIP) {
      peersWithIP.delete(id);
      if (peersWithIP.size === 0) {
        this.peerIPs.delete(ip);
      }
    }
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPsForPeer(id, pstats.knownIPs);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  /** Handles scoring functionality as a peer GRAFTs to a topic. */
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  /** Handles scoring functionality as a peer PRUNEs from a topic. */
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from46, msgIdStr, topic) {
    this.markFirstMessageDelivery(from46, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log23("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from46, now - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p) => {
      if (p !== from46.toString()) {
        this.markDuplicateMessageDelivery(p, topic);
      }
    });
  }
  /**
   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.
   */
  rejectInvalidMessage(from46, topic) {
    this.markInvalidMessageDelivery(from46, topic);
  }
  rejectMessage(from46, msgIdStr, topic, reason) {
    switch (reason) {
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from46, topic);
        return;
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log23("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from46, Date.now() - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from46, topic);
    drec.peers.forEach((p) => {
      this.markInvalidMessageDelivery(p, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from46, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from46)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from46);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from46);
        this.markDuplicateMessageDelivery(from46, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from46, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  /**
   * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
   */
  markInvalidMessageDelivery(from46, topic) {
    const pstats = this.peerStats.get(from46);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  /**
   * Increments the "first message deliveries" counter for all scored topics the message is published in,
   * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()
   */
  markFirstMessageDelivery(from46, topic) {
    const pstats = this.peerStats.get(from46);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  /**
   * Increments the "mesh message deliveries" counter for messages we've seen before,
   * as long the message was received within the P3 window.
   */
  markDuplicateMessageDelivery(from46, topic, validatedTime) {
    const pstats = this.peerStats.get(from46);
    if (pstats) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  /**
   * Removes an IP list from the tracking list for a peer.
   */
  removeIPsForPeer(id, ipsToRemove) {
    for (const ipToRemove of ipsToRemove) {
      const peerSet = this.peerIPs.get(ipToRemove);
      if (peerSet) {
        peerSet.delete(id);
        if (peerSet.size === 0) {
          this.peerIPs.delete(ipToRemove);
        }
      }
    }
  }
  /**
   * Returns topic stats if they exist, otherwise if the supplied parameters score the
   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.
   */
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js
var IWantTracer = class {
  static {
    __name(this, "IWantTracer");
  }
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.promises = /* @__PURE__ */ new Map();
    this.requestMsByMsg = /* @__PURE__ */ new Map();
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  /**
   * Track a promise to deliver a message from a list of msgIds we are requesting
   */
  addPromise(from46, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId2 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId2);
    let expireByPeer = this.promises.get(msgIdStr);
    if (!expireByPeer) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from46)) {
      expireByPeer.set(from46, now + this.gossipsubIWantFollowupMs);
      if (this.metrics) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  /**
   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.
   *
   * This should be called not too often relative to the expire times, since it iterates over the whole data.
   */
  getBrokenPromises() {
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId2) => {
      expireByPeer.forEach((expire, p) => {
        if (expire < now) {
          result.set(p, (result.get(p) ?? 0) + 1);
          expireByPeer.delete(p);
          brokenPromises++;
        }
      });
      if (!expireByPeer.size) {
        this.promises.delete(msgId2);
      }
    });
    this.metrics?.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  /**
   * Someone delivered a message, stop tracking promises for it
   */
  deliverMessage(msgIdStr, isDuplicate = false) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer) {
      this.promises.delete(msgIdStr);
      if (this.metrics) {
        this.metrics.iwantPromiseResolved.inc(1);
        if (isDuplicate)
          this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  /**
   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,
   * unless its an obviously invalid message.
   */
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    let count = 0;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
        count++;
      } else {
        break;
      }
    }
    this.metrics?.iwantMessagePruned.inc(count);
  }
  trackMessage(msgIdStr) {
    if (this.metrics) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js
var SimpleTimeCache = class {
  static {
    __name(this, "SimpleTimeCache");
  }
  constructor(opts) {
    this.entries = /* @__PURE__ */ new Map();
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  /** Returns true if there was a key collision and the entry is dropped */
  put(key, value) {
    if (this.entries.has(key)) {
      return true;
    }
    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });
    return false;
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value = this.entries.get(key);
    return value && value.validUntilMs >= Date.now() ? value.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Unsub"] = "unsubscribed";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    /* Metrics for static config */
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    /* Metrics per known topic */
    /** Status of our subscription to this topic. This metric allows analyzing other topic metrics
     *  filtered by our current subscription status.
     *  = rust-libp2p `topic_subscription_status` */
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour
     * regardless of our subscription status. */
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    /* Metrics regarding mesh state */
    /** Number of peers in our mesh. This metric should be updated with the count of peers for a
     *  topic in the mesh regardless of inclusion and churn events.
     *  = rust-libp2p `mesh_peer_counts` */
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    /** Number of times we include peers in a topic mesh for different reasons.
     *  = rust-libp2p `mesh_peer_inclusion_events` */
    meshPeerInclusionEvents: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_total",
      help: "Number of times we include peers in a topic mesh for different reasons",
      labelNames: ["reason"]
    }),
    meshPeerInclusionEventsByTopic: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_by_topic_total",
      help: "Number of times we include peers in a topic",
      labelNames: ["topic"]
    }),
    /** Number of times we remove peers in a topic mesh for different reasons.
     *  = rust-libp2p `mesh_peer_churn_events` */
    meshPeerChurnEvents: register.gauge({
      name: "gossipsub_peer_churn_events_total",
      help: "Number of times we remove peers in a topic mesh for different reasons",
      labelNames: ["reason"]
    }),
    meshPeerChurnEventsByTopic: register.gauge({
      name: "gossipsub_peer_churn_events_by_topic_total",
      help: "Number of times we remove peers in a topic",
      labelNames: ["topic"]
    }),
    /* General Metrics */
    /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based
     *  on which protocol they support. This metric keeps track of the number of peers that are
     *  connected of each type. */
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    /** The time it takes to complete one iteration of the heartbeat. */
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled
      buckets: [0.01, 0.1, 1]
    }),
    /** Heartbeat run took longer than heartbeat interval so next is skipped */
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    /** Message validation results for each topic.
     *  Invalid == Reject?
     *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */
    asyncValidationResult: register.gauge({
      name: "gossipsub_async_validation_result_total",
      help: "Message validation result",
      labelNames: ["acceptance"]
    }),
    asyncValidationResultByTopic: register.gauge({
      name: "gossipsub_async_validation_result_by_topic_total",
      help: "Message validation result for each topic",
      labelNames: ["topic"]
    }),
    /** When the user validates a message, it tries to re propagate it to its mesh peers. If the
     *  message expires from the memcache before it can be validated, we count this a cache miss
     *  and it is an indicator that the memcache size should be increased.
     *  = rust-libp2p `mcache_misses` */
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    // peer stream
    peerReadStreamError: register.gauge({
      name: "gossipsub_peer_read_stream_err_count_total",
      help: "Peer read stream error"
    }),
    // RPC outgoing. Track byte length + data structure sizes
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcDataError: register.gauge({ name: "gossipsub_rpc_data_err_count_total", help: "RPC data error" }),
    rpcRecvError: register.gauge({ name: "gossipsub_rpc_recv_err_count_total", help: "RPC recv error" }),
    /** Total count of RPC dropped because acceptFrom() == false */
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    // RPC incoming. Track byte length + data structure sizes
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    // publish message. Track peers sent to and bytes
    /** Total count of msg published by topic */
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we publish a msg to */
    msgPublishPeersByTopic: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of peers (by group) that we publish a msg to */
    // NOTE: Do not use 'group' label since it's a generic already used by Prometheus to group instances
    msgPublishPeersByGroup: register.gauge({
      name: "gossipsub_msg_publish_peers_by_group",
      help: "Total count of peers (by group) that we publish a msg to",
      labelNames: ["peerGroup"]
    }),
    /** Total count of msg publish data.length bytes */
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    /** Total count of msg forwarded by topic */
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we forward a msg to */
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs before any validation */
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs error */
    msgReceivedError: register.gauge({
      name: "gossipsub_msg_received_error_total",
      help: "Total count of recv msgs error",
      labelNames: ["topic"]
    }),
    /** Tracks distribution of recv msgs by duplicate, invalid, valid */
    msgReceivedStatus: register.gauge({
      name: "gossipsub_msg_received_status_total",
      help: "Tracks distribution of recv msgs by duplicate, invalid, valid",
      labelNames: ["status"]
    }),
    msgReceivedTopic: register.gauge({
      name: "gossipsub_msg_received_topic_total",
      help: "Tracks distribution of recv msgs by topic label",
      labelNames: ["topic"]
    }),
    /** Tracks specific reason of invalid */
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["error"]
    }),
    msgReceivedInvalidByTopic: register.gauge({
      name: "gossipsub_msg_received_invalid_by_topic_total",
      help: "Tracks specific invalid message by topic",
      labelNames: ["topic"]
    }),
    /** Track duplicate message delivery time */
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        1 * opts.maxMeshMessageDeliveriesWindowSec,
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    /** Total count of late msg delivery total by topic */
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    duplicateMsgIgnored: register.gauge({
      name: "gossisub_ignored_published_duplicate_msgs_total",
      help: "Total count of published duplicate message ignored by topic",
      labelNames: ["topic"]
    }),
    /* Metrics related to scoring */
    /** Total times score() is called */
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    /** Total times score() call actually computed computeScore(), no cache */
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    /** Current count of peers by score threshold */
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores"
    }),
    /**
     * Separate score weights
     * Need to use 2-label metrics in this case to debug the score weights
     **/
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    /** Histogram of the scores for each mesh topic. */
    // TODO: Not implemented
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    /** A counter of the kind of penalties being applied to peers. */
    // TODO: Not fully implemented
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        1 * opts.behaviourPenaltyThreshold,
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    // TODO:
    // - iasked per peer (on heartbeat)
    // - when promise is resolved, track messages from promises
    /** Total received IHAVE messages that we ignore for some reason */
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    /** Total received IHAVE messages by topic */
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    /** Total messages per topic we don't have. Not actual requests.
     *  The number of times we have decided that an IWANT control message is required for this
     *  topic. A very high metric might indicate an underperforming network.
     *  = rust-libp2p `topic_iwant_msgs` */
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    /** Total received IWANT messages by topic */
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    /** Total requested messageIDs that we don't have */
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    /** Total count of resolved IWANT promises */
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    /** Total count of resolved IWANT promises from duplicate messages */
    iwantPromiseResolvedFromDuplicate: register.gauge({
      name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
      help: "Total count of resolved IWANT promises from duplicate messages"
    }),
    /** Total count of peers we have asked IWANT promises that are resolved */
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantMessagePruned: register.gauge({
      name: "gossipsub_iwant_message_pruned",
      help: "Total count of pruned IWANT messages"
    }),
    /** Histogram of delivery time of resolved IWANT promises */
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        1 * opts.gossipPromiseExpireSec,
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    iwantPromiseUntracked: register.gauge({
      name: "gossip_iwant_promise_untracked",
      help: "Total count of untracked IWANT promise"
    }),
    /* Data structure sizes */
    /** Unbounded cache sizes */
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    /** Current mcache msg count */
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    mcacheNotValidatedCount: register.gauge({
      name: "gossipsub_mcache_not_validated_count",
      help: "Current mcache msg count not validated"
    }),
    fastMsgIdCacheCollision: register.gauge({
      name: "gossipsub_fastmsgid_cache_collision_total",
      help: "Total count of key collisions on fastmsgid cache put"
    }),
    newConnectionCount: register.gauge({
      name: "gossipsub_new_connection_total",
      help: "Total new connection by status",
      labelNames: ["status"]
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    /** We joined a topic */
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** We left a topic */
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** Register the inclusion of peers in our mesh due to some reason. */
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerInclusionEvents.inc({ reason }, count);
      this.meshPeerInclusionEventsByTopic.inc({ topic }, count);
    },
    /** Register the removal of peers in our mesh due to some reason */
    // - remove_peer_from_mesh()
    // - heartbeat() Churn::BadScore
    // - heartbeat() Churn::Excess
    // - on_disconnect() Churn::Ds
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerChurnEvents.inc({ reason }, count);
      this.meshPeerChurnEventsByTopic.inc({ topic }, count);
    },
    onReportValidationMcacheHit(hit) {
      this.asyncValidationMcacheHit.inc({ hit: hit ? "hit" : "miss" });
    },
    onReportValidation(topicStr, acceptance) {
      const topic = this.toTopic(topicStr);
      this.asyncValidationResult.inc({ acceptance });
      this.asyncValidationResultByTopic.inc({ topic });
    },
    /**
     * - in handle_graft() Penalty::GraftBackoff
     * - in apply_iwant_penalties() Penalty::BrokenPromise
     * - in metric_score() P3 Penalty::MessageDeficit
     * - in metric_score() P6 Penalty::IPColocation
     */
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeersByTopic.inc({ topic }, tosendCount);
      this.msgPublishPeersByGroup.inc({ peerGroup: "direct" }, tosendGroupCount.direct);
      this.msgPublishPeersByGroup.inc({ peerGroup: "floodsub" }, tosendGroupCount.floodsub);
      this.msgPublishPeersByGroup.inc({ peerGroup: "mesh" }, tosendGroupCount.mesh);
      this.msgPublishPeersByGroup.inc({ peerGroup: "fanout" }, tosendGroupCount.fanout);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvError(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedError.inc({ topic }, 1);
    },
    onMsgRecvResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedTopic.inc({ topic });
      this.msgReceivedStatus.inc({ status });
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ error }, 1);
      this.msgReceivedInvalidByTopic.inc({ topic }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onPublishDuplicateMsg(topicStr) {
      const topic = this.toTopic(topicStr);
      this.duplicateMsgIgnored.inc({ topic }, 1);
    },
    onPeerReadStreamError() {
      this.peerReadStreamError.inc(1);
    },
    onRpcRecvError() {
      this.rpcRecvError.inc(1);
    },
    onRpcDataError() {
      this.rpcDataError.inc(1);
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions)
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcRecvMessage.inc(rpc.messages.length);
      if (rpc.control) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave)
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        if (rpc.control.iwant)
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        if (rpc.control.graft)
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        if (rpc.control.prune)
          this.rpcRecvPrune.inc(rpc.control.prune.length);
      }
    },
    onRpcSent(rpc, rpcBytes) {
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions)
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcSentMessage.inc(rpc.messages.length);
      if (rpc.control) {
        const ihave = rpc.control.ihave?.length ?? 0;
        const iwant = rpc.control.iwant?.length ?? 0;
        const graft = rpc.control.graft?.length ?? 0;
        const prune = rpc.control.prune?.length ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (!peersInMesh) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p) => peersInMesh?.add(p));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}
__name(getMetrics, "getMetrics");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
var SignPrefix = fromString7("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toBytes(),
        data: transformedData,
        seqno: randomBytes(8),
        topic,
        signature: void 0,
        key: void 0
        // Exclude key field for signing
      };
      const bytes3 = concat3([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes3);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString5(rpcMsg.seqno, "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: rpcMsg.key
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
  }
}
__name(buildRawMessage, "buildRawMessage");
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.key != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromBytes(msg.from);
      } catch (e) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key) {
        publicKey = unmarshalPublicKey2(msg.key);
        if (fromPeerId.publicKey !== void 0 && !equals7(publicKey.bytes, fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = unmarshalPublicKey2(fromPeerId.publicKey);
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        key: void 0
        // Exclude key field for signing
      };
      const bytes3 = concat3([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);
      if (!await publicKey.verify(bytes3, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString5(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key ?? marshalPublicKey2(publicKey)
        }
      };
    }
  }
}
__name(validateToRawMessage, "validateToRawMessage");

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/vendor/varint.js
var encode_111 = encode47;
var MSB12 = 128;
var REST12 = 127;
var MSBALL11 = ~REST12;
var INT11 = Math.pow(2, 31);
function encode47(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT11) {
    out[offset++] = num & 255 | MSB12;
    num /= 128;
  }
  while (num & MSBALL11) {
    out[offset++] = num & 255 | MSB12;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode47.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode47, "encode");
var decode57 = read13;
var MSB$111 = 128;
var REST$111 = 127;
function read13(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read13.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$111) << shift : (b & REST$111) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$111);
  read13.bytes = counter - offset;
  return res;
}
__name(read13, "read");
var N113 = Math.pow(2, 7);
var N213 = Math.pow(2, 14);
var N313 = Math.pow(2, 21);
var N413 = Math.pow(2, 28);
var N513 = Math.pow(2, 35);
var N613 = Math.pow(2, 42);
var N713 = Math.pow(2, 49);
var N812 = Math.pow(2, 56);
var N912 = Math.pow(2, 63);
var length12 = /* @__PURE__ */ __name(function(value) {
  return value < N113 ? 1 : value < N213 ? 2 : value < N313 ? 3 : value < N413 ? 4 : value < N513 ? 5 : value < N613 ? 6 : value < N713 ? 7 : value < N812 ? 8 : value < N912 ? 9 : 10;
}, "length");
var varint12 = {
  encode: encode_111,
  decode: decode57,
  encodingLength: length12
};
var _brrp_varint11 = varint12;
var varint_default11 = _brrp_varint11;

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/varint.js
var encodeTo11 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default11.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength12 = /* @__PURE__ */ __name((int) => {
  return varint_default11.encodingLength(int);
}, "encodingLength");

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/digest.js
var create13 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength12(code16);
  const digestOffset = sizeOffset + encodingLength12(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo11(code16, bytes3, 0);
  encodeTo11(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest11(code16, size, digest13, bytes3);
}, "create");
var Digest11 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/hasher.js
var from25 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher9(name14, code16, encode79), "from");
var Hasher9 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create13(this.code, result) : result.then((digest13) => create13(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/sha2-browser.js
var sha9 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha2569 = from25({
  name: "sha2-256",
  code: 18,
  encode: sha9("SHA-256")
});
var sha5129 = from25({
  name: "sha2-512",
  code: 19,
  encode: sha9("SHA-512")
});

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/bytes.js
var empty17 = new Uint8Array(0);

// node_modules/@libp2p/pubsub/node_modules/multiformats/vendor/varint.js
var encode_112 = encode48;
var MSB13 = 128;
var REST13 = 127;
var MSBALL12 = ~REST13;
var INT12 = Math.pow(2, 31);
function encode48(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT12) {
    out[offset++] = num & 255 | MSB13;
    num /= 128;
  }
  while (num & MSBALL12) {
    out[offset++] = num & 255 | MSB13;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode48.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode48, "encode");
var decode59 = read14;
var MSB$112 = 128;
var REST$112 = 127;
function read14(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read14.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$112) << shift : (b & REST$112) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$112);
  read14.bytes = counter - offset;
  return res;
}
__name(read14, "read");
var N114 = Math.pow(2, 7);
var N214 = Math.pow(2, 14);
var N314 = Math.pow(2, 21);
var N414 = Math.pow(2, 28);
var N514 = Math.pow(2, 35);
var N614 = Math.pow(2, 42);
var N714 = Math.pow(2, 49);
var N813 = Math.pow(2, 56);
var N913 = Math.pow(2, 63);
var length13 = /* @__PURE__ */ __name(function(value) {
  return value < N114 ? 1 : value < N214 ? 2 : value < N314 ? 3 : value < N414 ? 4 : value < N514 ? 5 : value < N614 ? 6 : value < N714 ? 7 : value < N813 ? 8 : value < N913 ? 9 : 10;
}, "length");
var varint13 = {
  encode: encode_112,
  decode: decode59,
  encodingLength: length13
};
var _brrp_varint12 = varint13;
var varint_default12 = _brrp_varint12;

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/varint.js
var encodeTo12 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default12.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength13 = /* @__PURE__ */ __name((int) => {
  return varint_default12.encodingLength(int);
}, "encodingLength");

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/hashes/digest.js
var create14 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength13(code16);
  const digestOffset = sizeOffset + encodingLength13(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo12(code16, bytes3, 0);
  encodeTo12(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest12(code16, size, digest13, bytes3);
}, "create");
var Digest12 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/hashes/hasher.js
var from26 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher10(name14, code16, encode79), "from");
var Hasher10 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create14(this.code, result) : result.then((digest13) => create14(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/hashes/sha2-browser.js
var sha10 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha25610 = from26({
  name: "sha2-256",
  code: 18,
  encode: sha10("SHA-256")
});
var sha51210 = from26({
  name: "sha2-512",
  code: 19,
  encode: sha10("SHA-512")
});

// node_modules/@libp2p/pubsub/dist/src/utils.js
var msgId = /* @__PURE__ */ __name((key, seqno) => {
  const seqnoBytes = fromString7(seqno.toString(16).padStart(16, "0"), "base16");
  const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
  msgId2.set(key, 0);
  msgId2.set(seqnoBytes, key.length);
  return msgId2;
}, "msgId");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.toBytes(), msg.sequenceNumber);
}
__name(msgIdFnStrictSign, "msgIdFnStrictSign");
async function msgIdFnStrictNoSign(msg) {
  return await sha2569.encode(msg.data);
}
__name(msgIdFnStrictNoSign, "msgIdFnStrictNoSign");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (!topicScores) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
__name(computeScoreWeights, "computeScoreWeights");
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (!swTopic) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}
__name(computeAllPeersScoreWeights, "computeAllPeersScoreWeights");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js
var OutboundStream = class {
  static {
    __name(this, "OutboundStream");
  }
  constructor(rawStream, errCallback, opts) {
    this.rawStream = rawStream;
    this.pushable = pushable({ objectMode: false });
    this.closeController = new AbortController();
    this.maxBufferSize = opts.maxBufferSize ?? Infinity;
    pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), (source) => encode16(source), this.rawStream).catch(errCallback);
  }
  get protocol() {
    return this.rawStream.stat.protocol;
  }
  push(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(data);
  }
  close() {
    this.closeController.abort();
    this.pushable.return();
    this.rawStream.close();
  }
};
var InboundStream = class {
  static {
    __name(this, "InboundStream");
  }
  constructor(rawStream, opts = {}) {
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.source = abortableSource(pipe(this.rawStream, (source) => decode21(source, opts)), this.closeController.signal, {
      returnOnAbort: true
    });
  }
  close() {
    this.closeController.abort();
    this.rawStream.close();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/decodeRpc.js
var import_minimal = __toESM(require_minimal2(), 1);
var defaultDecodeRpcLimits = {
  maxSubscriptions: Infinity,
  maxMessages: Infinity,
  maxIhaveMessageIDs: Infinity,
  maxIwantMessageIDs: Infinity,
  maxControlMessages: Infinity,
  maxPeerInfos: Infinity
};
function decodeRpc(bytes3, opts) {
  opts = { ...opts };
  const r = import_minimal.default.Reader.create(bytes3);
  const l = bytes3.length;
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m2.subscriptions && m2.subscriptions.length))
          m2.subscriptions = [];
        if (m2.subscriptions.length < opts.maxSubscriptions)
          m2.subscriptions.push(decodeSubOpts(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 2:
        if (!(m2.messages && m2.messages.length))
          m2.messages = [];
        if (m2.messages.length < opts.maxMessages)
          m2.messages.push(decodeMessage2(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 3:
        m2.control = decodeControlMessage(r, r.uint32(), opts);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeRpc, "decodeRpc");
function decodeSubOpts(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m2.subscribe = r.bool();
        break;
      case 2:
        m2.topic = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeSubOpts, "decodeSubOpts");
function decodeMessage2(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m2.from = r.bytes();
        break;
      case 2:
        m2.data = r.bytes();
        break;
      case 3:
        m2.seqno = r.bytes();
        break;
      case 4:
        m2.topic = r.string();
        break;
      case 5:
        m2.signature = r.bytes();
        break;
      case 6:
        m2.key = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  if (!m2.topic)
    throw Error("missing required 'topic'");
  return m2;
}
__name(decodeMessage2, "decodeMessage");
function decodeControlMessage(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m2.ihave && m2.ihave.length))
          m2.ihave = [];
        if (m2.ihave.length < opts.maxControlMessages)
          m2.ihave.push(decodeControlIHave(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      case 2:
        if (!(m2.iwant && m2.iwant.length))
          m2.iwant = [];
        if (m2.iwant.length < opts.maxControlMessages)
          m2.iwant.push(decodeControlIWant(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      case 3:
        if (!(m2.graft && m2.graft.length))
          m2.graft = [];
        if (m2.graft.length < opts.maxControlMessages)
          m2.graft.push(decodeControlGraft(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 4:
        if (!(m2.prune && m2.prune.length))
          m2.prune = [];
        if (m2.prune.length < opts.maxControlMessages)
          m2.prune.push(decodeControlPrune(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeControlMessage, "decodeControlMessage");
function decodeControlIHave(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m2.topicID = r.string();
        break;
      case 2:
        if (!(m2.messageIDs && m2.messageIDs.length))
          m2.messageIDs = [];
        if (opts.maxIhaveMessageIDs-- > 0)
          m2.messageIDs.push(r.bytes());
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeControlIHave, "decodeControlIHave");
function decodeControlIWant(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m2.messageIDs && m2.messageIDs.length))
          m2.messageIDs = [];
        if (opts.maxIwantMessageIDs-- > 0)
          m2.messageIDs.push(r.bytes());
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeControlIWant, "decodeControlIWant");
function decodeControlGraft(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m2.topicID = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeControlGraft, "decodeControlGraft");
function decodeControlPrune(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m2.topicID = r.string();
        break;
      case 2:
        if (!(m2.peers && m2.peers.length))
          m2.peers = [];
        if (opts.maxPeerInfos-- > 0)
          m2.peers.push(decodePeerInfo(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 3:
        m2.backoff = r.uint64();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodeControlPrune, "decodeControlPrune");
function decodePeerInfo(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m2 = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m2.peerID = r.bytes();
        break;
      case 2:
        m2.signedPeerRecord = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m2;
}
__name(decodePeerInfo, "decodePeerInfo");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/multiaddr.js
var Protocol;
(function(Protocol2) {
  Protocol2[Protocol2["ip4"] = 4] = "ip4";
  Protocol2[Protocol2["ip6"] = 41] = "ip6";
})(Protocol || (Protocol = {}));
function multiaddrToIPStr(multiaddr2) {
  for (const tuple of multiaddr2.tuples()) {
    switch (tuple[0]) {
      case Protocol.ip4:
      case Protocol.ip6:
        return convertToString(tuple[0], tuple[1]);
    }
  }
  return null;
}
__name(multiaddrToIPStr, "multiaddrToIPStr");

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
var GossipSub = class extends EventEmitter6 {
  static {
    __name(this, "GossipSub");
  }
  constructor(components, options = {}) {
    super();
    this.multicodecs = [GossipsubIDv11, GossipsubIDv10];
    this.peers = /* @__PURE__ */ new Set();
    this.streamsInbound = /* @__PURE__ */ new Map();
    this.streamsOutbound = /* @__PURE__ */ new Map();
    this.outboundInflightQueue = pushable({ objectMode: true });
    this.direct = /* @__PURE__ */ new Set();
    this.floodsubPeers = /* @__PURE__ */ new Set();
    this.acceptFromWhitelist = /* @__PURE__ */ new Map();
    this.topics = /* @__PURE__ */ new Map();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.mesh = /* @__PURE__ */ new Map();
    this.fanout = /* @__PURE__ */ new Map();
    this.fanoutLastpub = /* @__PURE__ */ new Map();
    this.gossip = /* @__PURE__ */ new Map();
    this.control = /* @__PURE__ */ new Map();
    this.peerhave = /* @__PURE__ */ new Map();
    this.iasked = /* @__PURE__ */ new Map();
    this.backoff = /* @__PURE__ */ new Map();
    this.outbound = /* @__PURE__ */ new Map();
    this.topicValidators = /* @__PURE__ */ new Map();
    this.heartbeatTicks = 0;
    this.directPeerInitial = null;
    this.status = { code: GossipStatusCode.stopped };
    this.heartbeatTimer = null;
    this.runHeartbeat = () => {
      const timer = this.metrics?.heartbeatDuration.startTimer();
      this.heartbeat().catch((err) => {
        this.log("Error running heartbeat", err);
      }).finally(() => {
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            this.metrics?.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    };
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      ...options,
      scoreParams: createPeerScoreParams(options.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
    };
    this.components = components;
    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.multicodecs.push(FloodsubID);
    }
    this.log = logger9(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options.msgIdFn) {
      this.msgIdFn = options.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
      }
    }
    if (options.fastMsgIdFn) {
      this.fastMsgIdFn = options.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options.dataTransform) {
      this.dataTransform = options.dataTransform;
    }
    if (options.metricsRegister) {
      if (!options.metricsTopicStrToLabel) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
      for (const protocol of this.multicodecs) {
        metrics.protocolsEnabled.set({ protocol }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options.maxInboundStreams;
    this.maxOutboundStreams = options.maxOutboundStreams;
    this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null;
  }
  getPeers() {
    return [...this.peers.keys()].map((str) => peerIdFromString(str));
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  // LIFECYCLE METHODS
  /**
   * Mounts the gossipsub protocol onto the libp2p node and sends our
   * our subscriptions to every peer connected
   */
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId);
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe(this.outboundInflightQueue, async (source) => {
      for await (const { peerId, connection } of source) {
        await this.createOutboundStream(peerId, connection);
      }
    }).catch((e) => this.log.error("outbound inflight queue error", e));
    await Promise.all(this.opts.directPeers.map(async (p) => {
      await this.components.peerStore.merge(p.id, {
        multiaddrs: p.addrs
      });
    }));
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    })));
    const topology = createTopology({
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this)
    });
    const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
      }).catch((err) => {
        this.log(err);
      });
    }, GossipsubDirectConnectInitialDelay);
    this.log("started");
  }
  /**
   * Unmounts the gossipsub protocol and shuts down every connection
   */
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map((multicodec) => registrar.unhandle(multicodec)));
    registrarTopologyIds.forEach((id) => registrar.unregister(id));
    this.outboundInflightQueue.end();
    for (const outboundStream of this.streamsOutbound.values()) {
      outboundStream.close();
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      inboundStream.close();
    }
    this.streamsInbound.clear();
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache)
      this.fastMsgIdCache.clear();
    if (this.directPeerInitial)
      clearTimeout(this.directPeerInitial);
    this.log("stopped");
  }
  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  /**
   * On an inbound stream opened
   */
  onIncomingStream({ stream, connection }) {
    if (!this.isStarted()) {
      return;
    }
    const peerId = connection.remotePeer;
    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr);
    this.createInboundStream(peerId, stream);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies an established connection with pubsub protocol
   */
  onPeerConnected(peerId, connection) {
    this.metrics?.newConnectionCount.inc({ status: connection.stat.status });
    if (!this.isStarted() || connection.stat.status !== "OPEN") {
      return;
    }
    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies a closing connection with pubsub protocol
   */
  onPeerDisconnected(peerId) {
    this.log("connection ended %p", peerId);
    this.removePeer(peerId);
  }
  async createOutboundStream(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId);
      this.streamsOutbound.set(id, stream);
      const protocol = stream.protocol;
      if (protocol === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      this.metrics?.peersPerProtocol.inc({ protocol }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e) {
      this.log.error("createOutboundStream error", e);
    }
  }
  async createInboundStream(peerId, stream) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close();
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => this.log(err));
  }
  /**
   * Add a peer to the router
   */
  addPeer(peerId, direction, addr) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      this.log("new peer %p", peerId);
      this.peers.add(id);
      this.score.addPeer(id);
      const currentIP = multiaddrToIPStr(addr);
      if (currentIP !== null) {
        this.score.addIP(id, currentIP);
      } else {
        this.log("Added peer has no IP in current address %s %s", id, addr.toString());
      }
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  /**
   * Removes a peer from the router
   */
  removePeer(peerId) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream) {
      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream?.close();
    inboundStream?.close();
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id) === true) {
        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  // API METHODS
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  /**
   * Get a the peer-ids in a topic mesh
   */
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic ? Array.from(peersInTopic) : [];
  }
  /**
   * Get a list of the peer-ids that are subscribed to one topic.
   */
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
  }
  /**
   * Get the list of topics which the peer is subscribed to.
   */
  getTopics() {
    return Array.from(this.subscriptions);
  }
  // TODO: Reviewing Pubsub API
  // MESSAGE METHODS
  /**
   * Responsible for processing each RPC message received by other peers.
   */
  async pipePeerReadStream(peerId, stream) {
    try {
      await pipe(stream, async (source) => {
        for await (const data of source) {
          try {
            const rpcBytes = data.subarray();
            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits);
            this.metrics?.onRpcRecv(rpc, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              try {
                await this.handleReceivedRpc(peerId, rpc);
              } catch (err) {
                this.metrics?.onRpcRecvError();
                this.log(err);
              }
            } else {
              this.handleReceivedRpc(peerId, rpc).catch((err) => {
                this.metrics?.onRpcRecvError();
                this.log(err);
              });
            }
          } catch (e) {
            this.metrics?.onRpcDataError();
            this.log(e);
          }
        }
      });
    } catch (err) {
      this.metrics?.onPeerReadStreamError();
      this.handlePeerReadStreamError(err, peerId);
    }
  }
  /**
   * Handle error when read stream pipe throws, less of the functional use but more
   * to for testing purposes to spy on the error handling
   * */
  handlePeerReadStreamError(err, peerId) {
    this.log.error(err);
    this.onPeerDisconnected(peerId);
  }
  /**
   * Handles an rpc request from a peer
   */
  async handleReceivedRpc(from46, rpc) {
    if (!this.acceptFrom(from46.toString())) {
      this.log("received message from unacceptable peer %p", from46);
      this.metrics?.rpcRecvNotAccepted.inc();
      return;
    }
    const subscriptions = rpc.subscriptions ? rpc.subscriptions.length : 0;
    const messages2 = rpc.messages ? rpc.messages.length : 0;
    let ihave = 0;
    let iwant = 0;
    let graft = 0;
    let prune = 0;
    if (rpc.control) {
      if (rpc.control.ihave)
        ihave = rpc.control.ihave.length;
      if (rpc.control.iwant)
        iwant = rpc.control.iwant.length;
      if (rpc.control.graft)
        graft = rpc.control.graft.length;
      if (rpc.control.prune)
        prune = rpc.control.prune.length;
    }
    this.log(`rpc.from ${from46.toString()} subscriptions ${subscriptions} messages ${messages2} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);
    if (rpc.subscriptions && rpc.subscriptions.length > 0) {
      const subscriptions2 = [];
      rpc.subscriptions.forEach((subOpt) => {
        const topic = subOpt.topic;
        const subscribe = subOpt.subscribe === true;
        if (topic != null) {
          if (this.allowedTopics && !this.allowedTopics.has(topic)) {
            return;
          }
          this.handleReceivedSubscription(from46, topic, subscribe);
          subscriptions2.push({ topic, subscribe });
        }
      });
      this.dispatchEvent(new CustomEvent("subscription-change", {
        detail: { peerId: from46, subscriptions: subscriptions2 }
      }));
    }
    if (rpc.messages) {
      for (const message2 of rpc.messages) {
        if (this.allowedTopics && !this.allowedTopics.has(message2.topic)) {
          continue;
        }
        const handleReceivedMessagePromise = this.handleReceivedMessage(from46, message2).catch((err) => {
          this.metrics?.onMsgRecvError(message2.topic);
          this.log(err);
        });
        if (this.opts.awaitRpcMessageHandler) {
          await handleReceivedMessagePromise;
        }
      }
    }
    if (rpc.control) {
      await this.handleControlMessage(from46.toString(), rpc.control);
    }
  }
  /**
   * Handles a subscription change from a peer
   */
  handleReceivedSubscription(from46, topic, subscribe) {
    this.log("subscription update from %p topic %s", from46, topic);
    let topicSet = this.topics.get(topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(topic, topicSet);
    }
    if (subscribe) {
      topicSet.add(from46.toString());
    } else {
      topicSet.delete(from46.toString());
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async handleReceivedMessage(from46, rpcMsg) {
    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from46, rpcMsg);
    this.metrics?.onMsgRecvResult(rpcMsg.topic, validationResult.code);
    switch (validationResult.code) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from46.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from46.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from46.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from46.toString(), rpcMsg.topic);
        }
        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.peerId.equals(from46);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent("gossipsub:message", {
              detail: {
                propagationSource: from46,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from46.toString());
        }
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async validateReceivedMessage(propagationSource, rpcMsg) {
    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
    const msgIdCached = fastMsgIdStr !== void 0 ? this.fastMsgIdCache?.get(fastMsgIdStr) : void 0;
    if (msgIdCached) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e) {
      this.log("Invalid message, transform failed", e);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const messageId = { msgId: msgId2, msgIdStr };
    if (fastMsgIdStr !== void 0 && this.fastMsgIdCache) {
      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
      if (collision) {
        this.metrics?.fastMsgIdCacheCollision.inc();
      }
    }
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(propagationSource, msg);
      } catch (e) {
        const errCode6 = e.code;
        if (errCode6 === ERR_TOPIC_VALIDATOR_IGNORE)
          acceptance = TopicValidatorResult.Ignore;
        if (errCode6 === ERR_TOPIC_VALIDATOR_REJECT)
          acceptance = TopicValidatorResult.Reject;
        else
          acceptance = TopicValidatorResult.Ignore;
      }
      if (acceptance !== TopicValidatorResult.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  /**
   * Return score of a peer.
   */
  getScore(peerId) {
    return this.score.score(peerId);
  }
  /**
   * Send an rpc object to a peer with subscriptions
   */
  sendSubscriptions(toPeer, topics, subscribe) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe }))
    });
  }
  /**
   * Handles an rpc control message from a peer
   */
  async handleControlMessage(id, controlMsg) {
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
    if (!iwant.length && !ihave.length && !prune.length) {
      return;
    }
    const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } });
    const iwantMessageIds = iwant[0]?.messageIDs;
    if (iwantMessageIds) {
      if (sent) {
        this.gossipTracer.addPromise(id, iwantMessageIds);
      } else {
        this.metrics?.iwantPromiseUntracked.inc(1);
      }
    }
  }
  /**
   * Whether to accept a message from a peer
   */
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  /**
   * Handles IHAVE messages
   */
  handleIHave(id, ihave) {
    if (!ihave.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId2);
          idonthave++;
        }
      });
      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (!iwant.size) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  /**
   * Handles IWANT messages
   * Returns messages to send back to peer
   */
  handleIWant(id, iwant) {
    if (!iwant.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs && messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
    if (!ihave.size) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  /**
   * Handles Graft messages
   */
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      if (!topicID) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
        return;
      }
      const expire = this.backoff.get(topicID)?.get(id);
      if (typeof expire === "number" && now < expire) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
        return;
      }
      if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
        return;
      }
      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
        return;
      }
      this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
      this.score.graft(id, topicID);
      peersInMesh.add(id);
      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
    });
    if (!prune.length) {
      return [];
    }
    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX)));
  }
  /**
   * Handles Prune messages
   */
  async handlePrune(id, prune) {
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers && peers.length) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
          continue;
        }
        await this.pxConnect(peers);
      }
    }
  }
  /**
   * Add standard backoff log for a peer in a topic
   */
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  /**
   * Add backoff expiry interval for a peer in a topic
   *
   * @param id
   * @param topic
   * @param interval - backoff duration in milliseconds
   */
  doAddBackoff(id, topic, interval) {
    let backoff = this.backoff.get(topic);
    if (!backoff) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + interval;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  /**
   * Apply penalties from broken IHAVE/IWANT promises
   */
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
    });
  }
  /**
   * Clear expired backoff expiries
   */
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  /**
   * Maybe reconnect to direct peers
   */
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  /**
   * Maybe attempt connection given signed peer records
   */
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (!pi.peerID) {
        return;
      }
      const peer = peerIdFromBytes(pi.peerID);
      const p = peer.toString();
      if (this.peers.has(p)) {
        return;
      }
      if (!pi.signedPeerRecord) {
        toconnect.push(p);
        return;
      }
      try {
        if (!await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer)) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p);
      } catch (e) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (!toconnect.length) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  /**
   * Connect to a peer using the gossipsub protocol
   */
  async connect(id) {
    this.log("Initiating connection with %s", id);
    const peerId = peerIdFromString(id);
    const connection = await this.components.connectionManager.openConnection(peerId);
    for (const multicodec of this.multicodecs) {
      for (const topology of this.components.registrar.getTopologies(multicodec)) {
        topology.onConnect(peerId, connection);
      }
    }
  }
  /**
   * Subscribes to a topic
   */
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], true);
      }
    }
    this.join(topic);
  }
  /**
   * Unsubscribe to a topic
   */
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], false);
      }
    }
    this.leave(topic);
  }
  /**
   * Join topic
   */
  join(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    this.metrics?.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0) {
          toAdd.add(id);
        }
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => (
        // filter direct peers and peers with negative score
        !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0
      ));
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  /**
   * Leave topic
   */
  leave(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    this.metrics?.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers) {
      Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        return await this.sendPrune(id, topic);
      })).catch((err) => {
        this.log("Error sending prunes to mesh peers", err);
      });
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  /**
   * Forwards a message from our peers.
   *
   * For messages published by us (the app layer), this class uses `publish`
   */
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    if (propagationSource) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    tosend.forEach((id) => {
      this.sendRpc(id, { messages: [rawMsg] });
    });
    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
  }
  /**
   * App layer publishes a message to peers, return number of peers this message is published to
   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.
   *
   * For messages not from us, this class uses `forwardMessage`.
   */
  async publish(topic, data, opts) {
    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;
    if (this.seenCache.has(msgIdStr)) {
      if (ignoreDuplicatePublishError) {
        this.metrics?.onPublishDuplicateMsg(topic);
        return { recipients: [] };
      }
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
    const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers;
    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {
      throw Error("PublishError.InsufficientPeers");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
    this.publishedMessageIds.put(msgIdStr);
    for (const id of tosend) {
      const sent = this.sendRpc(id, { messages: [rawMsg] });
      if (!sent) {
        tosend.delete(id);
      }
    }
    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0);
    if (willSendToSelf) {
      tosend.add(this.components.peerId.toString());
      super.dispatchEvent(new CustomEvent("gossipsub:message", {
        detail: {
          propagationSource: this.components.peerId,
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
    };
  }
  /**
   * This function should be called when `asyncValidation` is `true` after
   * the message got validated by the caller. Messages are stored in the `mcache` and
   * validation is expected to be fast enough that the messages should still exist in the cache.
   * There are three possible validation outcomes and the outcome is given in acceptance.
   *
   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the
   * network. The `propagation_source` parameter indicates who the message was received by and
   * will not be forwarded back to that peer.
   *
   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache
   * and the P₄ penalty will be applied to the `propagationSource`.
   *
   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache
   * but no P₄ penalty will be applied.
   *
   * This function will return true if the message was found in the cache and false if was not
   * in the cache anymore.
   *
   * This should only be called once per message.
   */
  reportMessageValidationResult(msgId2, propagationSource, acceptance) {
    if (acceptance === TopicValidatorResult.Accept) {
      const cacheEntry = this.mcache.validate(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource.toString(), msgId2, rawMsg.topic);
        this.forwardMessage(msgId2, cacheEntry.message, propagationSource.toString(), originatingPeers);
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    } else {
      const cacheEntry = this.mcache.remove(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource.toString(), msgId2, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
        }
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    }
  }
  /**
   * Sends a GRAFT message to a peer
   */
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    this.sendRpc(id, { control: { graft } });
  }
  /**
   * Sends a PRUNE message to a peer
   */
  async sendPrune(id, topic) {
    const prune = [await this.makePrune(id, topic, this.opts.doPX)];
    this.sendRpc(id, { control: { prune } });
  }
  /**
   * Send an rpc object to a peer
   */
  sendRpc(id, rpc) {
    const outboundStream = this.streamsOutbound.get(id);
    if (!outboundStream) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl) {
      this.piggybackControl(id, rpc, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave) {
      this.piggybackGossip(id, rpc, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC.encode(rpc).finish();
    try {
      outboundStream.push(rpcBytes);
    } catch (e) {
      this.log.error(`Cannot send rpc to ${id}`, e);
      if (ctrl) {
        this.control.set(id, ctrl);
      }
      if (ihave) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    this.metrics?.onRpcSent(rpc, rpcBytes.length);
    return true;
  }
  /** Mutates `outRpc` adding graft and prune control messages */
  piggybackControl(id, outRpc, ctrl) {
    if (ctrl.graft) {
      if (!outRpc.control)
        outRpc.control = {};
      if (!outRpc.control.graft)
        outRpc.control.graft = [];
      for (const graft of ctrl.graft) {
        if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {
          outRpc.control.graft.push(graft);
        }
      }
    }
    if (ctrl.prune) {
      if (!outRpc.control)
        outRpc.control = {};
      if (!outRpc.control.prune)
        outRpc.control.prune = [];
      for (const prune of ctrl.prune) {
        if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {
          outRpc.control.prune.push(prune);
        }
      }
    }
  }
  /** Mutates `outRpc` adding ihave control messages */
  piggybackGossip(id, outRpc, ihave) {
    if (!outRpc.control)
      outRpc.control = {};
    outRpc.control.ihave = ihave;
  }
  /**
   * Send graft and prune messages
   *
   * @param tograft - peer id => topic[]
   * @param toprune - peer id => topic[]
   */
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning) {
        prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
        toprune.delete(id);
      }
      this.sendRpc(id, { control: { graft, prune } });
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
      this.sendRpc(id, { control: { prune } });
    }
  }
  /**
   * Emits gossip - Send IHAVE messages to a random set of gossip peers
   */
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  /**
   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy
   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers
   * We also exclude direct peers, as there is no reason to emit gossip to them
   * @param topic
   * @param candidateToGossip - peers to gossip
   * @param messageIDs - message ids to gossip
   */
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (!messageIDs.length) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (!candidateToGossip.size)
      return;
    let target = this.opts.Dlazy;
    const factor = GossipsubGossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  /**
   * Flush gossip and control messages
   */
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, { control: { ihave } });
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } });
    }
  }
  /**
   * Adds new IHAVE messages to pending gossip
   */
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) || [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  /**
   * Make a PRUNE control message for a peer in a topic
   */
  async makePrune(id, topic, doPX) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoff = this.opts.pruneBackoff / 1e3;
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId) => {
      const id2 = peerIdFromString(peerId);
      let peerInfo;
      try {
        peerInfo = await this.components.peerStore.get(id2);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      return {
        peerID: id2.toBytes(),
        signedPeerRecord: peerInfo?.peerRecordEnvelope
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  /**
   * Maintains the mesh and fanout maps in gossipsub.
   */
  async heartbeat() {
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = /* @__PURE__ */ __name((id) => {
      let s2 = scores.get(id);
      if (s2 === void 0) {
        s2 = this.score.score(id);
        scores.set(id, s2);
      }
      return s2;
    }, "getScore");
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    this.fastMsgIdCache?.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if ((!backoff || !backoff.has(id)) && score >= 0)
              candidateMeshPeers.add(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      const prunePeer = /* @__PURE__ */ __name((id, reason) => {
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
          peersToGossip.add(id);
        this.metrics?.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (!topics) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      }, "prunePeer");
      const graftPeer = /* @__PURE__ */ __name((id, reason) => {
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        this.metrics?.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (!topics) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      }, "graftPeer");
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p) => {
          graftPeer(p, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a, b) => getScore(b) - getScore(a));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = /* @__PURE__ */ __name((i) => {
            const p = peersArray[i];
            for (let j = i; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p;
          }, "rotate");
          if (outbound > 0) {
            let ihave = outbound;
            for (let i = 1; i < D && ihave > 0; i++) {
              if (this.outbound.get(peersArray[i])) {
                rotate(i);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i = D; i < peersArray.length && ineed > 0; i++) {
            if (this.outbound.get(peersArray[i])) {
              rotate(i);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p) => {
          prunePeer(p, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold)
              candidateFanoutPeers.push(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip?.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
  }
  /**
   * Given a topic, returns up to count peers subscribed to that topic
   * that pass an optional filter function
   *
   * @param topic
   * @param count
   * @param filter - a function to filter acceptable peers
   */
  getRandomGossipPeers(topic, count, filter2 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (!peersInTopic) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (!peerStreams) {
        return;
      }
      if (this.multicodecs.includes(peerStreams.protocol) && filter2(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    metrics.mcacheSize.set(this.mcache.size);
    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
};
GossipSub.multicodec = GossipsubIDv11;
function gossipsub(init = {}) {
  return (components) => new GossipSub(components, init);
}
__name(gossipsub, "gossipsub");

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}
__name(pair, "pair");

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}
__name(duplexPair, "duplexPair");

// node_modules/it-pb-stream/dist/src/index.js
var import_err_code3 = __toESM(require_err_code(), 1);

// node_modules/it-pb-stream/node_modules/uint8-varint/dist/src/index.js
var N115 = Math.pow(2, 7);
var N215 = Math.pow(2, 14);
var N315 = Math.pow(2, 21);
var N415 = Math.pow(2, 28);
var N515 = Math.pow(2, 35);
var N615 = Math.pow(2, 42);
var N715 = Math.pow(2, 49);
var N814 = Math.pow(2, 56);
var N914 = Math.pow(2, 63);
var unsigned2 = {
  encodingLength(value) {
    if (value < N115) {
      return 1;
    }
    if (value < N215) {
      return 2;
    }
    if (value < N315) {
      return 3;
    }
    if (value < N415) {
      return 4;
    }
    if (value < N515) {
      return 5;
    }
    if (value < N615) {
      return 6;
    }
    if (value < N715) {
      return 7;
    }
    if (value < N814) {
      return 8;
    }
    if (value < N914) {
      return 9;
    }
    return 10;
  },
  encode(value, buf3, offset = 0) {
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    if (buf3 == null) {
      buf3 = allocUnsafe6(unsigned2.encodingLength(value));
    }
    LongBits2.fromNumber(value).toBytes(buf3, offset);
    return buf3;
  },
  decode(buf3, offset = 0) {
    return LongBits2.fromBytes(buf3, offset).toNumber(true);
  }
};

// node_modules/it-pb-stream/dist/src/index.js
var defaultLengthDecoder = /* @__PURE__ */ __name((buf3) => {
  return unsigned2.decode(buf3);
}, "defaultLengthDecoder");
defaultLengthDecoder.bytes = 0;
function pbStream(duplex, opts) {
  const write3 = pushable();
  duplex.sink(write3).catch((err) => {
    write3.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf3 of source2) {
      write3.push(buf3);
    }
    write3.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes3) => {
      if (bytes3 == null) {
        const { done, value } = await source.next();
        if (done === true) {
          return new Uint8ArrayList();
        }
        return value;
      }
      while (readBuffer.byteLength < bytes3) {
        const { value, done } = await source.next();
        if (done === true) {
          throw (0, import_err_code3.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
        }
        readBuffer.append(value);
      }
      const buf3 = readBuffer.sublist(0, bytes3);
      readBuffer.consume(bytes3);
      return buf3;
    },
    readLP: async () => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;
      while (true) {
        lengthBuffer.append(await W.read(1));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength > -1) {
          break;
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw (0, import_err_code3.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw (0, import_err_code3.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
      }
      return W.read(dataLength);
    },
    readPB: async (proto) => {
      const value = await W.readLP();
      if (value == null) {
        throw new Error("Value is null");
      }
      const buf3 = value instanceof Uint8Array ? value : value.subarray();
      return proto.decode(buf3);
    },
    write: (data) => {
      if (data instanceof Uint8Array) {
        write3.push(data);
      } else {
        write3.push(data.subarray());
      }
    },
    writeLP: (data) => {
      W.write(encode16.single(data, opts));
    },
    writePB: (data, proto) => {
      W.writeLP(proto.encode(data));
    },
    pb: (proto) => {
      return {
        read: async () => W.readPB(proto),
        write: (d2) => {
          W.writePB(d2, proto);
        },
        unwrap: () => W
      };
    },
    unwrap: () => {
      const originalStream = duplex.source;
      duplex.source = async function* () {
        yield* readBuffer;
        yield* originalStream;
      }();
      return duplex;
    }
  };
  return W;
}
__name(pbStream, "pbStream");

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

// node_modules/@noble/ciphers/esm/utils.js
var u8a = /* @__PURE__ */ __name((a) => a instanceof Uint8Array, "u8a");
var u32 = /* @__PURE__ */ __name((arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)), "u32");
var createView = /* @__PURE__ */ __name((arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength), "createView");
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
__name(utf8ToBytes2, "utf8ToBytes");
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
__name(toBytes2, "toBytes");
var isPlainObject = /* @__PURE__ */ __name((obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object, "isPlainObject");
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
__name(checkOpts, "checkOpts");
function ensureBytes3(b, len) {
  if (!(b instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
__name(ensureBytes3, "ensureBytes");
function equalBytes2(a, b) {
  if (a.length !== b.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let isSame = true;
  for (let i = 0; i < a.length; i++)
    isSame && (isSame = a[i] === b[i]);
  return isSame;
}
__name(equalBytes2, "equalBytes");
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
__name(setBigUint64, "setBigUint64");

// node_modules/@noble/ciphers/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
__name(number, "number");
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
__name(bool, "bool");
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
__name(bytes, "bytes");
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
__name(hash, "hash");
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
__name(exists, "exists");
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
__name(output, "output");
var assert = { number, bool, bytes, hash, exists, output };
var assert_default = assert;

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = /* @__PURE__ */ __name((a, i) => a[i++] & 255 | (a[i++] & 255) << 8, "u8to16");
var Poly1305 = class {
  static {
    __name(this, "Poly1305");
  }
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    ensureBytes3(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h: h2, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h2[0] + (t0 & 8191);
    let h1 = h2[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h22 = h2[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h2[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h2[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h2[5] + (t4 >>> 1 & 8191);
    let h6 = h2[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h2[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h2[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h2[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h22 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h22 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h22 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h22 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h22 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h22 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h22 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h22 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h22 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h22 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h2[0] = d0;
    h2[1] = d1;
    h2[2] = d2;
    h2[3] = d3;
    h2[4] = d4;
    h2[5] = d5;
    h2[6] = d6;
    h2[7] = d7;
    h2[8] = d8;
    h2[9] = d9;
  }
  finalize() {
    const { h: h2, pad } = this;
    const g = new Uint16Array(10);
    let c = h2[1] >>> 13;
    h2[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h2[i] += c;
      c = h2[i] >>> 13;
      h2[i] &= 8191;
    }
    h2[0] += c * 5;
    c = h2[0] >>> 13;
    h2[0] &= 8191;
    h2[1] += c;
    c = h2[1] >>> 13;
    h2[1] &= 8191;
    h2[2] += c;
    g[0] = h2[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h2[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h2[i] = h2[i] & mask | g[i];
    h2[0] = (h2[0] | h2[1] << 13) & 65535;
    h2[1] = (h2[1] >>> 3 | h2[2] << 10) & 65535;
    h2[2] = (h2[2] >>> 6 | h2[3] << 7) & 65535;
    h2[3] = (h2[3] >>> 9 | h2[4] << 4) & 65535;
    h2[4] = (h2[4] >>> 12 | h2[5] << 1 | h2[6] << 14) & 65535;
    h2[5] = (h2[6] >>> 2 | h2[7] << 11) & 65535;
    h2[6] = (h2[7] >>> 5 | h2[8] << 8) & 65535;
    h2[7] = (h2[8] >>> 8 | h2[9] << 5) & 65535;
    let f = h2[0] + pad[0];
    h2[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h2[i] + pad[i] | 0) + (f >>> 16) | 0;
      h2[i] = f & 65535;
    }
  }
  update(data) {
    assert_default.exists(this);
    const { buffer: buffer3, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(buffer3, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer: buffer3, h: h2 } = this;
    let { pos } = this;
    if (pos) {
      buffer3[pos++] = 1;
      for (; pos < 16; pos++)
        buffer3[pos] = 0;
      this.process(buffer3, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h2[i] >>> 0;
      out[opos++] = h2[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = /* @__PURE__ */ __name((msg, key) => hashCons(key).update(toBytes2(msg)).digest(), "hashC");
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
__name(wrapConstructorWithKey, "wrapConstructorWithKey");
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/_salsa.js
var sigma16 = utf8ToBytes2("expand 16-byte k");
var sigma32 = utf8ToBytes2("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
var isAligned32 = /* @__PURE__ */ __name((b) => !(b.byteOffset % 4), "isAligned32");
var salsaBasic = /* @__PURE__ */ __name((opts) => {
  const { core, rounds, counterRight, counterLen, allow128bitKeys, extendNonceFn, blockLen } = checkOpts({ rounds: 20, counterRight: false, counterLen: 8, allow128bitKeys: true, blockLen: 64 }, opts);
  assert_default.number(counterLen);
  assert_default.number(rounds);
  assert_default.number(blockLen);
  assert_default.bool(counterRight);
  assert_default.bool(allow128bitKeys);
  const blockLen32 = blockLen / 4;
  if (blockLen % 4 !== 0)
    throw new Error("Salsa/ChaCha: blockLen should be aligned to 4 bytes");
  return (key, nonce, data, output3, counter = 0) => {
    assert_default.bytes(key);
    assert_default.bytes(nonce);
    assert_default.bytes(data);
    if (!output3)
      output3 = new Uint8Array(data.length);
    assert_default.bytes(output3);
    assert_default.number(counter);
    if (counter < 0 || counter >= 2 ** 32 - 1)
      throw new Error("Salsa/ChaCha: counter overflow");
    if (output3.length < data.length) {
      throw new Error(`Salsa/ChaCha: output (${output3.length}) is shorter than data (${data.length})`);
    }
    const toClean = [];
    let k, sigma;
    if (key.length === 32) {
      k = key;
      sigma = sigma32_32;
    } else if (key.length === 16 && allow128bitKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else
      throw new Error(`Salsa/ChaCha: wrong key length=${key.length}, expected`);
    if (extendNonceFn) {
      if (nonce.length <= 16)
        throw new Error(`Salsa/ChaCha: extended nonce should be bigger than 16 bytes`);
      k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));
      toClean.push(k);
      nonce = nonce.subarray(16);
    }
    const nonceLen = 16 - counterLen;
    if (nonce.length !== nonceLen)
      throw new Error(`Salsa/ChaCha: nonce should be ${nonceLen} or 16 bytes`);
    if (nonceLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      toClean.push(nonce = nc);
    }
    const block = new Uint8Array(blockLen);
    const b32 = u32(block);
    const k32 = u32(k);
    const n32 = u32(nonce);
    const d32 = isAligned32(data) && u32(data);
    const o32 = isAligned32(output3) && u32(output3);
    toClean.push(b32);
    const len = data.length;
    for (let pos = 0, ctr = counter; pos < len; ctr++) {
      core(sigma, k32, n32, b32, ctr, rounds);
      if (ctr >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      const take2 = Math.min(blockLen, len - pos);
      if (take2 === blockLen && o32 && d32) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("Salsa/ChaCha: wrong block position");
        for (let j = 0; j < blockLen32; j++)
          o32[pos32 + j] = d32[pos32 + j] ^ b32[j];
        pos += blockLen;
        continue;
      }
      for (let j = 0; j < take2; j++)
        output3[pos + j] = data[pos + j] ^ block[j];
      pos += take2;
    }
    for (let i = 0; i < toClean.length; i++)
      toClean[i].fill(0);
    return output3;
  };
}, "salsaBasic");

// node_modules/@noble/ciphers/esm/chacha.js
var rotl = /* @__PURE__ */ __name((a, b) => a << b | a >>> 32 - b, "rotl");
function chachaCore(c, k, n, out, cnt, rounds = 20) {
  let y00 = c[0], y01 = c[1], y02 = c[2], y03 = c[3];
  let y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3];
  let y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7];
  let y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < rounds; i += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
__name(chachaCore, "chachaCore");
function hchacha(c, key, src30, out) {
  const k32 = u32(key);
  const i32 = u32(src30);
  const o32 = u32(out);
  let x00 = c[0], x01 = c[1], x02 = c[2], x03 = c[3];
  let x04 = k32[0], x05 = k32[1], x06 = k32[2], x07 = k32[3];
  let x08 = k32[4], x09 = k32[5], x10 = k32[6], x11 = k32[7];
  let x12 = i32[0], x13 = i32[1], x14 = i32[2], x15 = i32[3];
  for (let i = 0; i < 20; i += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  o32[0] = x00;
  o32[1] = x01;
  o32[2] = x02;
  o32[3] = x03;
  o32[4] = x12;
  o32[5] = x13;
  o32[6] = x14;
  o32[7] = x15;
  return out;
}
__name(hchacha, "hchacha");
var chacha20orig = salsaBasic({ core: chachaCore, counterRight: false, counterLen: 8 });
var chacha20 = salsaBasic({
  core: chachaCore,
  counterRight: false,
  counterLen: 4,
  allow128bitKeys: false
});
var xchacha20 = salsaBasic({
  core: chachaCore,
  counterRight: false,
  counterLen: 8,
  extendNonceFn: hchacha,
  allow128bitKeys: false
});
var chacha8 = salsaBasic({
  core: chachaCore,
  counterRight: false,
  counterLen: 4,
  rounds: 8
});
var chacha12 = salsaBasic({
  core: chachaCore,
  counterRight: false,
  counterLen: 4,
  rounds: 12
});
var ZERO = new Uint8Array(16);
var updatePadded = /* @__PURE__ */ __name((h2, msg) => {
  h2.update(msg);
  const left = msg.length % 16;
  if (left)
    h2.update(ZERO.subarray(left));
}, "updatePadded");
var computeTag = /* @__PURE__ */ __name((fn, key, nonce, data, AAD) => {
  const authKey = fn(key, nonce, new Uint8Array(32));
  const h2 = poly1305.create(authKey);
  if (AAD)
    updatePadded(h2, AAD);
  updatePadded(h2, data);
  const num = new Uint8Array(16);
  const view = createView(num);
  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint64(view, 8, BigInt(data.length), true);
  h2.update(num);
  const res = h2.digest();
  authKey.fill(0);
  return res;
}, "computeTag");
var _poly1305_aead = /* @__PURE__ */ __name((fn) => (key, nonce, AAD) => {
  const tagLength = 16;
  ensureBytes3(key, 32);
  ensureBytes3(nonce);
  return {
    tagLength,
    encrypt: (plaintext) => {
      const res = new Uint8Array(plaintext.length + tagLength);
      fn(key, nonce, plaintext, res, 1);
      const tag = computeTag(fn, key, nonce, res.subarray(0, -tagLength), AAD);
      res.set(tag, plaintext.length);
      return res;
    },
    decrypt: (ciphertext) => {
      if (ciphertext.length < tagLength)
        throw new Error(`Encrypted data should be at least ${tagLength}`);
      const realTag = ciphertext.subarray(-tagLength);
      const data = ciphertext.subarray(0, -tagLength);
      const tag = computeTag(fn, key, nonce, data, AAD);
      if (!equalBytes2(realTag, tag))
        throw new Error("Wrong tag");
      return fn(key, nonce, data, void 0, 1);
    }
  };
}, "_poly1305_aead");
var chacha20_poly1305 = _poly1305_aead(chacha20);
var xchacha20_poly1305 = _poly1305_aead(xchacha20);

// node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
__name(number2, "number");
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
__name(isBytes, "isBytes");
function bytes2(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
__name(bytes2, "bytes");
function hash2(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(h2.outputLen);
  number2(h2.blockLen);
}
__name(hash2, "hash");
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
__name(exists2, "exists");
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
__name(output2, "output");

// node_modules/@noble/hashes/esm/crypto.js
var crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var createView2 = /* @__PURE__ */ __name((arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength), "createView");
var rotr = /* @__PURE__ */ __name((word2, shift) => word2 << 32 - shift | word2 >>> shift, "rotr");
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
__name(utf8ToBytes3, "utf8ToBytes");
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  bytes2(data);
  return data;
}
__name(toBytes3, "toBytes");
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    bytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
__name(concatBytes3, "concatBytes");
var Hash = class {
  static {
    __name(this, "Hash");
  }
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = /* @__PURE__ */ __name((msg) => hashCons().update(toBytes3(msg)).digest(), "hashC");
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
__name(wrapConstructor, "wrapConstructor");
function randomBytes2(bytesLength = 32) {
  if (crypto4 && typeof crypto4.getRandomValues === "function") {
    return crypto4.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
__name(randomBytes2, "randomBytes");

// node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
__name(setBigUint642, "setBigUint64");
var Chi = /* @__PURE__ */ __name((a, b, c) => a & b ^ ~a & c, "Chi");
var Maj = /* @__PURE__ */ __name((a, b, c) => a & b ^ a & c ^ b & c, "Maj");
var HashMD = class extends Hash {
  static {
    __name(this, "HashMD");
  }
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView3 = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView3, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length21, finished, destroyed, pos } = this;
    to.length = length21;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length21 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
};

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
__name(fromBig, "fromBig");
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
__name(split, "split");
var toBig = /* @__PURE__ */ __name((h2, l) => BigInt(h2 >>> 0) << _32n | BigInt(l >>> 0), "toBig");
var shrSH = /* @__PURE__ */ __name((h2, _l, s2) => h2 >>> s2, "shrSH");
var shrSL = /* @__PURE__ */ __name((h2, l, s2) => h2 << 32 - s2 | l >>> s2, "shrSL");
var rotrSH = /* @__PURE__ */ __name((h2, l, s2) => h2 >>> s2 | l << 32 - s2, "rotrSH");
var rotrSL = /* @__PURE__ */ __name((h2, l, s2) => h2 << 32 - s2 | l >>> s2, "rotrSL");
var rotrBH = /* @__PURE__ */ __name((h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32, "rotrBH");
var rotrBL = /* @__PURE__ */ __name((h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2, "rotrBL");
var rotr32H = /* @__PURE__ */ __name((_h, l) => l, "rotr32H");
var rotr32L = /* @__PURE__ */ __name((h2, _l) => h2, "rotr32L");
var rotlSH = /* @__PURE__ */ __name((h2, l, s2) => h2 << s2 | l >>> 32 - s2, "rotlSH");
var rotlSL = /* @__PURE__ */ __name((h2, l, s2) => l << s2 | h2 >>> 32 - s2, "rotlSL");
var rotlBH = /* @__PURE__ */ __name((h2, l, s2) => l << s2 - 32 | h2 >>> 64 - s2, "rotlBH");
var rotlBL = /* @__PURE__ */ __name((h2, l, s2) => h2 << s2 - 32 | l >>> 64 - s2, "rotlBL");
function add(Ah, Al, Bh, Bl3) {
  const l = (Al >>> 0) + (Bl3 >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
__name(add, "add");
var add3L = /* @__PURE__ */ __name((Al, Bl3, Cl) => (Al >>> 0) + (Bl3 >>> 0) + (Cl >>> 0), "add3L");
var add3H = /* @__PURE__ */ __name((low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0, "add3H");
var add4L = /* @__PURE__ */ __name((Al, Bl3, Cl, Dl) => (Al >>> 0) + (Bl3 >>> 0) + (Cl >>> 0) + (Dl >>> 0), "add4L");
var add4H = /* @__PURE__ */ __name((low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0, "add4H");
var add5L = /* @__PURE__ */ __name((Al, Bl3, Cl, Dl, El) => (Al >>> 0) + (Bl3 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0), "add5L");
var add5H = /* @__PURE__ */ __name((low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0, "add5H");
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
  static {
    __name(this, "SHA512");
  }
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl3 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl3 ^ Al & Cl ^ Bl3 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl3 | 0;
      Bh = Ah | 0;
      Bl3 = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl3 } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl3 | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha51211 = /* @__PURE__ */ wrapConstructor(() => new SHA512());

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex3,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE2,
  concatBytes: () => concatBytes4,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes4,
  equalBytes: () => equalBytes3,
  hexToBytes: () => hexToBytes3,
  hexToNumber: () => hexToNumber2,
  inRange: () => inRange,
  isBytes: () => isBytes2,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded2,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes4,
  validateObject: () => validateObject
});
var _0n3 = /* @__PURE__ */ BigInt(0);
var _1n3 = /* @__PURE__ */ BigInt(1);
var _2n3 = /* @__PURE__ */ BigInt(2);
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
__name(isBytes2, "isBytes");
function abytes(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
__name(abytes, "abytes");
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(`${title} must be valid boolean, got "${value}".`);
}
__name(abool, "abool");
var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex3(bytes3) {
  abytes(bytes3);
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes3[bytes3[i]];
  }
  return hex;
}
__name(bytesToHex3, "bytesToHex");
function numberToHexUnpadded2(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
__name(numberToHexUnpadded2, "numberToHexUnpadded");
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
__name(hexToNumber2, "hexToNumber");
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
__name(asciiToBase16, "asciiToBase16");
function hexToBytes3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
__name(hexToBytes3, "hexToBytes");
function bytesToNumberBE(bytes3) {
  return hexToNumber2(bytesToHex3(bytes3));
}
__name(bytesToNumberBE, "bytesToNumberBE");
function bytesToNumberLE2(bytes3) {
  abytes(bytes3);
  return hexToNumber2(bytesToHex3(Uint8Array.from(bytes3).reverse()));
}
__name(bytesToNumberLE2, "bytesToNumberLE");
function numberToBytesBE(n, len) {
  return hexToBytes3(n.toString(16).padStart(len * 2, "0"));
}
__name(numberToBytesBE, "numberToBytesBE");
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
__name(numberToBytesLE, "numberToBytesLE");
function numberToVarBytesBE(n) {
  return hexToBytes3(numberToHexUnpadded2(n));
}
__name(numberToVarBytesBE, "numberToVarBytesBE");
function ensureBytes4(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes3(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
__name(ensureBytes4, "ensureBytes");
function concatBytes4(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
__name(concatBytes4, "concatBytes");
function equalBytes3(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
__name(equalBytes3, "equalBytes");
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
__name(utf8ToBytes4, "utf8ToBytes");
var isPosBig = /* @__PURE__ */ __name((n) => typeof n === "bigint" && _0n3 <= n, "isPosBig");
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
__name(inRange, "inRange");
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
__name(aInRange, "aInRange");
function bitLen(n) {
  let len;
  for (len = 0; n > _0n3; n >>= _1n3, len += 1)
    ;
  return len;
}
__name(bitLen, "bitLen");
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n3;
}
__name(bitGet, "bitGet");
function bitSet(n, pos, value) {
  return n | (value ? _1n3 : _0n3) << BigInt(pos);
}
__name(bitSet, "bitSet");
var bitMask = /* @__PURE__ */ __name((n) => (_2n3 << BigInt(n - 1)) - _1n3, "bitMask");
var u8n = /* @__PURE__ */ __name((data) => new Uint8Array(data), "u8n");
var u8fr = /* @__PURE__ */ __name((arr) => Uint8Array.from(arr), "u8fr");
function createHmacDrbg(hashLen2, qByteLen, hmacFn) {
  if (typeof hashLen2 !== "number" || hashLen2 < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen2);
  let k = u8n(hashLen2);
  let i = 0;
  const reset = /* @__PURE__ */ __name(() => {
    v.fill(1);
    k.fill(0);
    i = 0;
  }, "reset");
  const h2 = /* @__PURE__ */ __name((...b) => hmacFn(k, v, ...b), "h");
  const reseed = /* @__PURE__ */ __name((seed = u8n()) => {
    k = h2(u8fr([0]), seed);
    v = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v = h2();
  }, "reseed");
  const gen = /* @__PURE__ */ __name(() => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h2();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes4(...out);
  }, "gen");
  const genUntil = /* @__PURE__ */ __name((seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  }, "genUntil");
  return genUntil;
}
__name(createHmacDrbg, "createHmacDrbg");
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators2, optValidators = {}) {
  const checkField = /* @__PURE__ */ __name((fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  }, "checkField");
  for (const [fieldName, type] of Object.entries(validators2))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
__name(validateObject, "validateObject");
var notImplemented = /* @__PURE__ */ __name(() => {
  throw new Error("not implemented");
}, "notImplemented");
function memoized(fn) {
  const map3 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map3.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map3.set(arg, computed);
    return computed;
  };
}
__name(memoized, "memoized");

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n3 = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod4(a, b) {
  const result = a % b;
  return result >= _0n4 ? result : b + result;
}
__name(mod4, "mod");
function pow(num, power, modulo) {
  if (modulo <= _0n4 || power < _0n4)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n4)
    return _0n4;
  let res = _1n4;
  while (power > _0n4) {
    if (power & _1n4)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n4;
  }
  return res;
}
__name(pow, "pow");
function pow23(x, power, modulo) {
  let res = x;
  while (power-- > _0n4) {
    res *= res;
    res %= modulo;
  }
  return res;
}
__name(pow23, "pow2");
function invert3(number3, modulo) {
  if (number3 === _0n4 || modulo <= _0n4) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod4(number3, modulo);
  let b = modulo;
  let x = _0n4, y2 = _1n4, u = _1n4, v = _0n4;
  while (a !== _0n4) {
    const q = b / a;
    const r = b % a;
    const m2 = x - u * q;
    const n = y2 - v * q;
    b = a, a = r, x = u, y2 = v, u = m2, v = n;
  }
  const gcd = b;
  if (gcd !== _1n4)
    throw new Error("invert: does not exist");
  return mod4(x, modulo);
}
__name(invert3, "invert");
function tonelliShanks(P) {
  const legendreC = (P - _1n4) / _2n4;
  let Q, S, Z;
  for (Q = P - _1n4, S = 0; Q % _2n4 === _0n4; Q /= _2n4, S++)
    ;
  for (Z = _2n4; Z < P && pow(Z, legendreC, P) !== P - _1n4; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n4) / _4n;
    return /* @__PURE__ */ __name(function tonelliFast(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    }, "tonelliFast");
  }
  const Q1div2 = (Q + _1n4) / _2n4;
  return /* @__PURE__ */ __name(function tonelliSlow(Fp3, n) {
    if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n, Q1div2);
    let b = Fp3.pow(n, Q);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO))
        return Fp3.ZERO;
      let m2 = 1;
      for (let t2 = Fp3.sqr(b); m2 < r; m2++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g, _1n4 << BigInt(r - m2 - 1));
      g = Fp3.sqr(ge);
      x = Fp3.mul(x, ge);
      b = Fp3.mul(b, g);
      r = m2;
    }
    return x;
  }, "tonelliSlow");
}
__name(tonelliShanks, "tonelliShanks");
function FpSqrt(P) {
  if (P % _4n === _3n2) {
    const p1div4 = (P + _1n4) / _4n;
    return /* @__PURE__ */ __name(function sqrt3mod4(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    }, "sqrt3mod4");
  }
  if (P % _8n3 === _5n) {
    const c1 = (P - _5n) / _8n3;
    return /* @__PURE__ */ __name(function sqrt5mod8(Fp3, n) {
      const n2 = Fp3.mul(n, _2n4);
      const v = Fp3.pow(n2, c1);
      const nv = Fp3.mul(n, v);
      const i = Fp3.mul(Fp3.mul(nv, _2n4), v);
      const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    }, "sqrt5mod8");
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
__name(FpSqrt, "FpSqrt");
var isNegativeLE = /* @__PURE__ */ __name((num, modulo) => (mod4(num, modulo) & _1n4) === _1n4, "isNegativeLE");
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map3, val) => {
    map3[val] = "function";
    return map3;
  }, initial);
  return validateObject(field, opts);
}
__name(validateField, "validateField");
function FpPow(f, num, power) {
  if (power < _0n4)
    throw new Error("Expected power > 0");
  if (power === _0n4)
    return f.ONE;
  if (power === _1n4)
    return num;
  let p = f.ONE;
  let d2 = num;
  while (power > _0n4) {
    if (power & _1n4)
      p = f.mul(p, d2);
    d2 = f.sqr(d2);
    power >>= _1n4;
  }
  return p;
}
__name(FpPow, "FpPow");
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
__name(FpInvertBatch, "FpInvertBatch");
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
__name(nLength, "nLength");
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n4)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n4,
    ONE: _1n4,
    create: (num) => mod4(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n4 <= num && num < ORDER;
    },
    is0: (num) => num === _0n4,
    isOdd: (num) => (num & _1n4) === _1n4,
    neg: (num) => mod4(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod4(num * num, ORDER),
    add: (lhs, rhs) => mod4(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod4(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod4(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod4(lhs * invert3(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert3(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE2(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f);
}
__name(Field, "Field");
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
__name(getFieldBytesLength, "getFieldBytesLength");
function getMinHashLength(fieldOrder) {
  const length21 = getFieldBytesLength(fieldOrder);
  return length21 + Math.ceil(length21 / 2);
}
__name(getMinHashLength, "getMinHashLength");
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen2 = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE2(key);
  const reduced = mod4(num, fieldOrder - _1n4) + _1n4;
  return isLE3 ? numberToBytesLE(reduced, fieldLen2) : numberToBytesBE(reduced, fieldLen2);
}
__name(mapHashToField, "mapHashToField");

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var pointPrecomputes3 = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function wNAF(c, bits3) {
  const constTimeNegate3 = /* @__PURE__ */ __name((condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  }, "constTimeNegate");
  const validateW = /* @__PURE__ */ __name((W) => {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits3)
      throw new Error(`Wrong window size=${W}, should be [1..${bits3}]`);
  }, "validateW");
  const opts = /* @__PURE__ */ __name((W) => {
    validateW(W);
    const windows = Math.ceil(bits3 / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  }, "opts");
  return {
    constTimeNegate: constTimeNegate3,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d2 = elm;
      while (n > _0n5) {
        if (n & _1n5)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n5;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base42 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base42 = p;
        points.push(base42);
        for (let i = 1; i < windowSize; i++) {
          base42 = base42.add(p);
          points.push(base42);
        }
        p = base42.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n5;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate3(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate3(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, n, transform) {
      const W = pointWindowSizes.get(P) || 1;
      let comp = pointPrecomputes3.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes3.set(P, transform(comp));
      }
      return this.wNAF(W, comp, n);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W);
      pointWindowSizes.set(P, W);
      pointPrecomputes3.delete(P);
    }
  };
}
__name(wNAF, "wNAF");
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
__name(validateBasic, "validateBasic");

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var _8n4 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
__name(validateOpts, "validateOpts");
function twistedEdwards(curveDef) {
  const CURVE3 = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes4, nByteLength, h: cofactor } = CURVE3;
  const MASK = _2n5 << BigInt(nByteLength * 8) - _1n6;
  const modP = Fp3.create;
  const uvRatio3 = CURVE3.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(u * Fp3.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n6 };
    }
  });
  const adjustScalarBytes2 = CURVE3.adjustScalarBytes || ((bytes3) => bytes3);
  const domain = CURVE3.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n) {
    aInRange("coordinate " + title, n, _0n6, MASK);
  }
  __name(aCoordinate, "aCoordinate");
  function assertPoint(other) {
    if (!(other instanceof Point4))
      throw new Error("ExtendedPoint expected");
  }
  __name(assertPoint, "assertPoint");
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y2, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n4 : Fp3.inv(z);
    const ax = modP(x * iz);
    const ay = modP(y2 * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n6, y: _1n6 };
    if (zz !== _1n6)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d: d2 } = CURVE3;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point4 {
    static {
      __name(this, "Point");
    }
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point4)
        throw new Error("extended point not allowed");
      const { x, y: y2 } = p || {};
      aCoordinate("x", x);
      aCoordinate("y", y2);
      return new Point4(x, y2, _1n6, modP(x * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point4.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point4.ZERO);
    }
    negate() {
      return new Point4(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE3;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n5 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point4(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a, d: d2 } = CURVE3;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a === BigInt(-1)) {
        const A2 = modP((Y1 - X1) * (Y2 + X2));
        const B2 = modP((Y1 + X1) * (Y2 - X2));
        const F2 = modP(B2 - A2);
        if (F2 === _0n6)
          return this.double();
        const C2 = modP(Z1 * _2n5 * T2);
        const D2 = modP(T1 * _2n5 * Z2);
        const E2 = D2 + C2;
        const G3 = B2 + A2;
        const H2 = D2 - C2;
        const X32 = modP(E2 * F2);
        const Y32 = modP(G3 * H2);
        const T32 = modP(E2 * H2);
        const Z32 = modP(F2 * G3);
        return new Point4(X32, Y32, Z32, T32);
      }
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G2 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point4(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point4.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n6, CURVE_ORDER);
      const { p, f } = this.wNAF(n);
      return Point4.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      const n = scalar;
      aInRange("scalar", n, _0n6, CURVE_ORDER);
      if (n === _0n6)
        return I;
      if (this.equals(I) || n === _1n6)
        return this;
      if (this.equals(G))
        return this.wNAF(n).p;
      return wnaf.unsafeLadder(this, n);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE3;
      if (cofactor2 === _1n6)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d2, a } = CURVE3;
      const len = Fp3.BYTES;
      hex = ensureBytes4("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE2(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange("pointHex.y", y2, _0n6, max);
      const y22 = modP(y2 * y2);
      const u = modP(y22 - _1n6);
      const v = modP(d2 * y22 - a);
      let { isValid, value: x } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n6) === _1n6;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n6 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point4.fromAffine({ x, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey2(privKey).point;
    }
    toRawBytes() {
      const { x, y: y2 } = this.toAffine();
      const bytes3 = numberToBytesLE(y2, Fp3.BYTES);
      bytes3[bytes3.length - 1] |= x & _1n6 ? 128 : 0;
      return bytes3;
    }
    toHex() {
      return bytesToHex3(this.toRawBytes());
    }
  }
  Point4.BASE = new Point4(CURVE3.Gx, CURVE3.Gy, _1n6, modP(CURVE3.Gx * CURVE3.Gy));
  Point4.ZERO = new Point4(_0n6, _1n6, _1n6, _0n6);
  const { BASE: G, ZERO: I } = Point4;
  const wnaf = wNAF(Point4, nByteLength * 8);
  function modN(a) {
    return mod4(a, CURVE_ORDER);
  }
  __name(modN, "modN");
  function modN_LE(hash3) {
    return modN(bytesToNumberLE2(hash3));
  }
  __name(modN_LE, "modN_LE");
  function getExtendedPublicKey2(key) {
    const len = nByteLength;
    key = ensureBytes4("private key", key, len);
    const hashed = ensureBytes4("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  __name(getExtendedPublicKey2, "getExtendedPublicKey");
  function getPublicKey3(privKey) {
    return getExtendedPublicKey2(privKey).pointBytes;
  }
  __name(getPublicKey3, "getPublicKey");
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes4(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes4("context", context), !!prehash)));
  }
  __name(hashDomainToScalar, "hashDomainToScalar");
  function sign4(msg, privKey, options = {}) {
    msg = ensureBytes4("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey2(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toRawBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s2 = modN(r + k * scalar);
    aInRange("signature.s", s2, _0n6, CURVE_ORDER);
    const res = concatBytes4(R, numberToBytesLE(s2, Fp3.BYTES));
    return ensureBytes4("result", res, nByteLength * 2);
  }
  __name(sign4, "sign");
  const verifyOpts = VERIFY_DEFAULT;
  function verify3(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes4("signature", sig, 2 * len);
    msg = ensureBytes4("message", msg);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE2(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point4.fromHex(publicKey, zip215);
      R = Point4.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point4.ZERO);
  }
  __name(verify3, "verify");
  G._setWindowSize(8);
  const utils3 = {
    getExtendedPublicKey: getExtendedPublicKey2,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes4(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point4.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE: CURVE3,
    getPublicKey: getPublicKey3,
    sign: sign4,
    verify: verify3,
    ExtendedPoint: Point4,
    utils: utils3
  };
}
__name(twistedEdwards, "twistedEdwards");

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
function validateOpts2(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
__name(validateOpts2, "validateOpts");
function montgomery(curveDef) {
  const CURVE3 = validateOpts2(curveDef);
  const { P } = CURVE3;
  const modP = /* @__PURE__ */ __name((n) => mod4(n, P), "modP");
  const montgomeryBits = CURVE3.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen2 = CURVE3.nByteLength;
  const adjustScalarBytes2 = CURVE3.adjustScalarBytes || ((bytes3) => bytes3);
  const powPminus2 = CURVE3.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return [x_2, x_3];
  }
  __name(cswap, "cswap");
  const a24 = (CURVE3.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n7, P);
    aInRange("scalar", scalar, _0n7, P);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n7;
    let z_2 = _0n7;
    let x_3 = u;
    let z_3 = _1n7;
    let swap = _0n7;
    let sw;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n7; t--) {
      const k_t = k >> t & _1n7;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  __name(montgomeryLadder, "montgomeryLadder");
  function encodeUCoordinate(u) {
    return numberToBytesLE(modP(u), montgomeryBytes);
  }
  __name(encodeUCoordinate, "encodeUCoordinate");
  function decodeUCoordinate(uEnc) {
    const u = ensureBytes4("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen2 === 32)
      u[31] &= 127;
    return bytesToNumberLE2(u);
  }
  __name(decodeUCoordinate, "decodeUCoordinate");
  function decodeScalar(n) {
    const bytes3 = ensureBytes4("scalar", n);
    const len = bytes3.length;
    if (len !== montgomeryBytes && len !== fieldLen2)
      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen2} bytes, got ${len}`);
    return bytesToNumberLE2(adjustScalarBytes2(bytes3));
  }
  __name(decodeScalar, "decodeScalar");
  function scalarMult(scalar, u) {
    const pointU = decodeUCoordinate(u);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n7)
      throw new Error("Invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  __name(scalarMult, "scalarMult");
  const GuBytes = encodeUCoordinate(CURVE3.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  __name(scalarMultBase, "scalarMultBase");
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE3.randomBytes(CURVE3.nByteLength) },
    GuBytes
  };
}
__name(montgomery, "montgomery");

// node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n6 = BigInt(2);
var _3n3 = BigInt(3);
var _5n2 = BigInt(5);
var _8n5 = BigInt(8);
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow23(b2, _2n6, P) * b2 % P;
  const b5 = pow23(b4, _1n8, P) * x % P;
  const b10 = pow23(b5, _5n2, P) * b5 % P;
  const b20 = pow23(b10, _10n, P) * b10 % P;
  const b40 = pow23(b20, _20n, P) * b20 % P;
  const b80 = pow23(b40, _40n, P) * b40 % P;
  const b160 = pow23(b80, _80n, P) * b80 % P;
  const b240 = pow23(b160, _80n, P) * b80 % P;
  const b250 = pow23(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow23(b250, _2n6, P) * x % P;
  return { pow_p_5_8, b2 };
}
__name(ed25519_pow_2_252_3, "ed25519_pow_2_252_3");
function adjustScalarBytes(bytes3) {
  bytes3[0] &= 248;
  bytes3[31] &= 127;
  bytes3[31] |= 64;
  return bytes3;
}
__name(adjustScalarBytes, "adjustScalarBytes");
function uvRatio2(u, v) {
  const P = ED25519_P;
  const v3 = mod4(v * v * v, P);
  const v7 = mod4(v3 * v3 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod4(u * v3 * pow3, P);
  const vx2 = mod4(v * x * x, P);
  const root1 = x;
  const root2 = mod4(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod4(-u, P);
  const noRoot = vx2 === mod4(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod4(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
__name(uvRatio2, "uvRatio");
var Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = /* @__PURE__ */ (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n5,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha51211,
  randomBytes: randomBytes2,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio: uvRatio2
}))();
var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var x25519 = /* @__PURE__ */ (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
    return mod4(pow23(pow_p_5_8, _3n3, P) * b2, P);
  },
  adjustScalarBytes,
  randomBytes: randomBytes2
}))();

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  static {
    __name(this, "HMAC");
  }
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash2(hash3);
    const key = toBytes3(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf3) {
    exists2(this);
    this.iHash.update(buf3);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = /* @__PURE__ */ __name((hash3, key, message2) => new HMAC(hash3, key).update(message2).digest(), "hmac");
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash3, ikm, salt) {
  hash2(hash3);
  if (salt === void 0)
    salt = new Uint8Array(hash3.outputLen);
  return hmac(hash3, toBytes3(salt), toBytes3(ikm));
}
__name(extract, "extract");
var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
var EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
function expand(hash3, prk, info, length21 = 32) {
  hash2(hash3);
  number2(length21);
  if (length21 > 255 * hash3.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length21 / hash3.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash3.outputLen);
  const HMAC2 = hmac.create(hash3, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash3.outputLen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length21);
}
__name(expand, "expand");

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  static {
    __name(this, "SHA256");
  }
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha25611 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
var pureJsCrypto = {
  hashSHA256(data) {
    return sha25611(data);
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha25611, ikm, ck);
    const okmU8Array = expand(sha25611, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x25519.utils.randomPrivateKey();
    const publicKey = x25519.getPublicKey(secretKey);
    return {
      publicKey,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey = x25519.getPublicKey(seed);
    return {
      publicKey,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.getSharedSecret(privateKey, publicKey);
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20_poly1305(k, nonce, ad).encrypt(plaintext);
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    const result = chacha20_poly1305(k, nonce, ad).decrypt(ciphertext);
    if (dst) {
      dst.set(result);
      return result;
    }
    return result;
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var allocUnsafe9 = /* @__PURE__ */ __name((len) => {
  if (globalThis.Buffer) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
}, "allocUnsafe");
var uint16BEEncode = /* @__PURE__ */ __name((value) => {
  const target = allocUnsafe9(2);
  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);
  return target;
}, "uint16BEEncode");
uint16BEEncode.bytes = 2;
var uint16BEDecode = /* @__PURE__ */ __name((data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
  }
  return data.getUint16(0);
}, "uint16BEDecode");
uint16BEDecode.bytes = 2;
function encode0(message2) {
  return concat3([message2.ne, message2.ciphertext], message2.ne.length + message2.ciphertext.length);
}
__name(encode0, "encode0");
function encode1(message2) {
  return concat3([message2.ne, message2.ns, message2.ciphertext], message2.ne.length + message2.ns.length + message2.ciphertext.length);
}
__name(encode1, "encode1");
function encode210(message2) {
  return concat3([message2.ns, message2.ciphertext], message2.ns.length + message2.ciphertext.length);
}
__name(encode210, "encode2");
function decode0(input) {
  if (input.length < 32) {
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ciphertext: input.subarray(32, input.length),
    ns: new Uint8Array(0)
  };
}
__name(decode0, "decode0");
function decode1(input) {
  if (input.length < 80) {
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ns: input.subarray(32, 80),
    ciphertext: input.subarray(80, input.length)
  };
}
__name(decode1, "decode1");
function decode210(input) {
  if (input.length < 48) {
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  }
  return {
    ne: new Uint8Array(0),
    ns: input.subarray(0, 48),
    ciphertext: input.subarray(48, input.length)
  };
}
__name(decode210, "decode2");

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/streaming.js
var CHACHA_TAG_LENGTH = 16;
function encryptStream(handshake2, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const data = handshake2.encrypt(chunk.subarray(i, end), handshake2.session);
        metrics?.encryptedPackets.increment();
        yield uint16BEEncode(data.byteLength);
        yield data;
      }
    }
  };
}
__name(encryptStream, "encryptStream");
function decryptStream(handshake2, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        if (end - CHACHA_TAG_LENGTH < i) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.subarray(i, end);
        const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
        const { plaintext: decrypted, valid } = handshake2.decrypt(encrypted, handshake2.session, dst);
        if (!valid) {
          metrics?.decryptErrors.increment();
          throw new Error("Failed to validate decrypted chunk");
        }
        metrics?.decryptedPackets.increment();
        yield decrypted;
      }
    }
  };
}
__name(decryptStream, "decryptStream");

// node_modules/@libp2p/interface-connection-encrypter/dist/src/errors.js
var UnexpectedPeerError = class _UnexpectedPeerError extends Error {
  static {
    __name(this, "UnexpectedPeerError");
  }
  code;
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.code = _UnexpectedPeerError.code;
  }
  static code = "ERR_UNEXPECTED_PEER";
};
var InvalidCryptoExchangeError = class _InvalidCryptoExchangeError extends Error {
  static {
    __name(this, "InvalidCryptoExchangeError");
  }
  code;
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = _InvalidCryptoExchangeError.code;
  }
  static code = "ERR_INVALID_CRYPTO_EXCHANGE";
};

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value of obj.webtransportCerthashes) {
            w2.uint32(10);
            w2.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          webtransportCerthashes: []
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.webtransportCerthashes.push(reader2.bytes());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf3) => {
    return decodeMessage(buf3, NoiseExtensions2.codec());
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (opts.writeDefaults === true || obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.identityKey ?? new Uint8Array(0));
        }
        if (opts.writeDefaults === true || obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.identitySig ?? new Uint8Array(0));
        }
        if (obj.extensions != null) {
          w2.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w2, {
            writeDefaults: false
          });
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          identityKey: new Uint8Array(0),
          identitySig: new Uint8Array(0)
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identityKey = reader2.bytes();
              break;
            case 2:
              obj.identitySig = reader2.bytes();
              break;
            case 4:
              obj.extensions = NoiseExtensions.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf3) => {
    return decodeMessage(buf3, NoiseHandshakePayload2.codec());
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
async function getPayload(localPeer, staticPublicKey, extensions) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
  if (localPeer.publicKey == null) {
    throw new Error("PublicKey was missing from local PeerId");
  }
  return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);
}
__name(getPayload, "getPayload");
function createHandshakePayload(libp2pPublicKey, signedPayload, extensions) {
  return NoiseHandshakePayload.encode({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    extensions: extensions ?? { webtransportCerthashes: [] }
  }).subarray();
}
__name(createHandshakePayload, "createHandshakePayload");
async function signPayload(peerId, payload) {
  if (peerId.privateKey == null) {
    throw new Error("PrivateKey was missing from PeerId");
  }
  const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
  return privateKey.sign(payload);
}
__name(signPayload, "signPayload");
async function getPeerIdFromPayload(payload) {
  return peerIdFromKeys(payload.identityKey);
}
__name(getPeerIdFromPayload, "getPeerIdFromPayload");
function decodePayload(payload) {
  return NoiseHandshakePayload.decode(payload);
}
__name(decodePayload, "decodePayload");
function getHandshakePayload(publicKey) {
  const prefix = fromString7("noise-libp2p-static-key:");
  return concat3([prefix, publicKey], prefix.length + publicKey.length);
}
__name(getHandshakePayload, "getHandshakePayload");
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const payloadPeerId = await peerIdFromKeys(payload.identityKey);
  if (!payloadPeerId.equals(remotePeer)) {
    throw new Error(`Payload identity key ${payloadPeerId.toString()} does not match expected remote peer ${remotePeer.toString()}`);
  }
  const generatedPayload = getHandshakePayload(noiseStaticKey);
  if (payloadPeerId.publicKey == null) {
    throw new Error("PublicKey was missing from PeerId");
  }
  if (payload.identitySig == null) {
    throw new Error("Signature was missing from message");
  }
  const publicKey = unmarshalPublicKey2(payloadPeerId.publicKey);
  const valid = await publicKey.verify(generatedPayload, payload.identitySig);
  if (!valid) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }
  return payloadPeerId;
}
__name(verifySignedPayload, "verifySignedPayload");
function isValidPublicKey(pk) {
  if (!(pk instanceof Uint8Array)) {
    return false;
  }
  if (pk.length !== 32) {
    return false;
  }
  return true;
}
__name(isValidPublicKey, "isValidPublicKey");

// node_modules/uint8arrays/dist/src/compare.js
function compare2(a, b) {
  if (globalThis.Buffer != null) {
    return globalThis.Buffer.compare(a, b);
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] < b[i]) {
      return -1;
    }
    if (a[i] > b[i]) {
      return 1;
    }
  }
  if (a.byteLength > b.byteLength) {
    return 1;
  }
  if (a.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}
__name(compare2, "compare");

// node_modules/uint8arrays/dist/src/xor.js
function xor(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe6(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return asUint8Array2(result);
}
__name(xor, "xor");

// node_modules/@chainsafe/libp2p-noise/node_modules/@libp2p/logger/dist/src/index.js
var import_debug7 = __toESM(require_browser(), 1);

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/vendor/base-x.js
function base20(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base20, "base");
var src17 = base20;
var _brrp__multiformats_scope_baseX17 = src17;
var base_x_default17 = _brrp__multiformats_scope_baseX17;

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bytes.js
var empty18 = new Uint8Array(0);
var coerce18 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bases/base.js
var Encoder17 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder17 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or17(this, decoder);
  }
};
var ComposedDecoder17 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or17(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or17 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder17(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec17 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder17(name14, prefix, baseEncode);
    this.decoder = new Decoder17(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from27 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec17(name14, prefix, encode79, decode97), "from");
var baseX17 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default17(alphabet11, name14);
  return from27({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce18(decode97(text))
  });
}, "baseX");
var decode61 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode49 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464817 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from27({
    prefix,
    name: name14,
    encode(input) {
      return encode49(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode61(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bases/base58.js
var base58btc17 = baseX17({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr17 = baseX17({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bases/base32.js
var base3216 = rfc464817({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper16 = rfc464817({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad16 = rfc464817({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper16 = rfc464817({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex16 = rfc464817({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper16 = rfc464817({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad16 = rfc464817({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper16 = rfc464817({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z16 = rfc464817({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/src/bases/base64.js
var base6416 = rfc464817({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad16 = rfc464817({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url16 = rfc464817({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad16 = rfc464817({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@chainsafe/libp2p-noise/node_modules/@libp2p/logger/dist/src/index.js
import_debug7.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc17.baseEncode(v);
};
import_debug7.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3216.baseEncode(v);
};
import_debug7.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6416.baseEncode(v);
};
import_debug7.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug7.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug7.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug7.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger9(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger9, "createDisabledLogger");
function logger10(name14) {
  let trace = createDisabledLogger9(`${name14}:trace`);
  if (import_debug7.default.enabled(`${name14}:trace`) && import_debug7.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug7.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug7.default)(name14), {
    error: (0, import_debug7.default)(`${name14}:error`),
    trace
  });
}
__name(logger10, "logger");

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
var log24 = logger10("libp2p:noise");
var keyLogger;
if (DUMP_SESSION_KEYS) {
  keyLogger = log24;
} else {
  keyLogger = Object.assign(() => {
  }, {
    enabled: false,
    trace: () => {
    },
    error: () => {
    }
  });
}
function logLocalStaticKeys(s2) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString5(s2.publicKey, "hex")}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString5(s2.privateKey, "hex")}`);
}
__name(logLocalStaticKeys, "logLocalStaticKeys");
function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString5(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString5(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
__name(logLocalEphemeralKeys, "logLocalEphemeralKeys");
function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString5(rs, "hex")}`);
}
__name(logRemoteStaticKey, "logRemoteStaticKey");
function logRemoteEphemeralKey(re) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString5(re, "hex")}`);
}
__name(logRemoteEphemeralKey, "logRemoteEphemeralKey");
function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString5(session.cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString5(session.cs2.k, "hex")}`);
  } else {
    keyLogger("Missing cipher state.");
  }
}
__name(logCipherState, "logCipherState");

// node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  static {
    __name(this, "Nonce");
  }
  n;
  bytes;
  view;
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = new Uint8Array(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var AbstractHandshake = class {
  static {
    __name(this, "AbstractHandshake");
  }
  crypto;
  constructor(crypto5) {
    this.crypto = crypto5;
  }
  encryptWithAd(cs, ad, plaintext) {
    const e = this.encrypt(cs.k, cs.n, ad, plaintext);
    cs.n.increment();
    return e;
  }
  decryptWithAd(cs, ad, ciphertext, dst) {
    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);
    if (valid)
      cs.n.increment();
    return { plaintext, valid };
  }
  // Cipher state related
  hasKey(cs) {
    return !this.isEmptyKey(cs.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(k) {
    const emptyKey = this.createEmptyKey();
    return equals7(emptyKey, k);
  }
  encrypt(k, n, ad, plaintext) {
    n.assertValue();
    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
  }
  encryptAndHash(ss, plaintext) {
    let ciphertext;
    if (this.hasKey(ss.cs)) {
      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
    } else {
      ciphertext = plaintext;
    }
    this.mixHash(ss, ciphertext);
    return ciphertext;
  }
  decrypt(k, n, ad, ciphertext, dst) {
    n.assertValue();
    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);
    if (encryptedMessage) {
      return {
        plaintext: encryptedMessage,
        valid: true
      };
    } else {
      return {
        plaintext: new Uint8Array(0),
        valid: false
      };
    }
  }
  decryptAndHash(ss, ciphertext) {
    let plaintext;
    let valid = true;
    if (this.hasKey(ss.cs)) {
      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
    } else {
      plaintext = ciphertext;
    }
    this.mixHash(ss, ciphertext);
    return { plaintext, valid };
  }
  dh(privateKey, publicKey) {
    try {
      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
      if (derivedU8.length === 32) {
        return derivedU8;
      }
      return derivedU8.subarray(0, 32);
    } catch (e) {
      const err = e;
      log24.error(err);
      return new Uint8Array(32);
    }
  }
  mixHash(ss, data) {
    ss.h = this.getHash(ss.h, data);
  }
  getHash(a, b) {
    const u = this.crypto.hashSHA256(concat3([a, b], a.length + b.length));
    return u;
  }
  mixKey(ss, ikm) {
    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
    ss.cs = this.initializeKey(tempK);
    ss.ck = ck;
  }
  initializeKey(k) {
    return { k, n: new Nonce() };
  }
  // Symmetric state related
  initializeSymmetric(protocolName) {
    const protocolNameBytes = fromString7(protocolName, "utf-8");
    const h2 = this.hashProtocolName(protocolNameBytes);
    const ck = h2;
    const key = this.createEmptyKey();
    const cs = this.initializeKey(key);
    return { cs, ck, h: h2 };
  }
  hashProtocolName(protocolName) {
    if (protocolName.length <= 32) {
      const h2 = new Uint8Array(32);
      h2.set(protocolName);
      return h2;
    } else {
      return this.getHash(protocolName, new Uint8Array(0));
    }
  }
  split(ss) {
    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
    const cs1 = this.initializeKey(tempk1);
    const cs2 = this.initializeKey(tempk2);
    return { cs1, cs2 };
  }
  writeMessageRegular(cs, payload) {
    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
    const ne = this.createEmptyKey();
    const ns = new Uint8Array(0);
    return { ne, ns, ciphertext };
  }
  readMessageRegular(cs, message2) {
    return this.decryptWithAd(cs, new Uint8Array(0), message2.ciphertext);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
var XX = class extends AbstractHandshake {
  static {
    __name(this, "XX");
  }
  initializeInitiator(prologue, s2, rs, psk) {
    const name14 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name14);
    this.mixHash(ss, prologue);
    const re = new Uint8Array(32);
    return { ss, s: s2, rs, psk, re };
  }
  initializeResponder(prologue, s2, rs, psk) {
    const name14 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name14);
    this.mixHash(ss, prologue);
    const re = new Uint8Array(32);
    return { ss, s: s2, rs, psk, re };
  }
  writeMessageA(hs, payload, e) {
    const ns = new Uint8Array(0);
    if (e !== void 0) {
      hs.e = e;
    } else {
      hs.e = this.crypto.generateX25519KeyPair();
    }
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageB(hs, payload) {
    hs.e = this.crypto.generateX25519KeyPair();
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageC(hs, payload) {
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    const ne = this.createEmptyKey();
    const messageBuffer = { ne, ns, ciphertext };
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, messageBuffer, cs1, cs2 };
  }
  readMessageA(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    return this.decryptAndHash(hs.ss, message2.ciphertext);
  }
  readMessageB(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    return { plaintext, valid: valid1 && valid2 };
  }
  readMessageC(hs, message2) {
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
  }
  initSession(initiator, prologue, s2) {
    const psk = this.createEmptyKey();
    const rs = new Uint8Array(32);
    let hs;
    if (initiator) {
      hs = this.initializeInitiator(prologue, s2, rs, psk);
    } else {
      hs = this.initializeResponder(prologue, s2, rs, psk);
    }
    return {
      hs,
      i: initiator,
      mc: 0
    };
  }
  sendMessage(session, message2, ephemeral) {
    let messageBuffer;
    if (session.mc === 0) {
      messageBuffer = this.writeMessageA(session.hs, message2, ephemeral);
    } else if (session.mc === 1) {
      messageBuffer = this.writeMessageB(session.hs, message2);
    } else if (session.mc === 2) {
      const { h: h2, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message2);
      messageBuffer = resultingBuffer;
      session.h = h2;
      session.cs1 = cs1;
      session.cs2 = cs2;
    } else if (session.mc > 2) {
      if (session.i) {
        if (!session.cs1) {
          throw new Error("CS1 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs1, message2);
      } else {
        if (!session.cs2) {
          throw new Error("CS2 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs2, message2);
      }
    } else {
      throw new Error("Session invalid.");
    }
    session.mc++;
    return messageBuffer;
  }
  recvMessage(session, message2) {
    let plaintext = new Uint8Array(0);
    let valid = false;
    if (session.mc === 0) {
      ({ plaintext, valid } = this.readMessageA(session.hs, message2));
    } else if (session.mc === 1) {
      ({ plaintext, valid } = this.readMessageB(session.hs, message2));
    } else if (session.mc === 2) {
      const { h: h2, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message2);
      plaintext = resultingPlaintext;
      valid = resultingValid;
      session.h = h2;
      session.cs1 = cs1;
      session.cs2 = cs2;
    }
    session.mc++;
    return { plaintext, valid };
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
var XXHandshake = class {
  static {
    __name(this, "XXHandshake");
  }
  isInitiator;
  session;
  remotePeer;
  remoteExtensions = { webtransportCerthashes: [] };
  payload;
  connection;
  xx;
  staticKeypair;
  prologue;
  constructor(isInitiator, payload, prologue, crypto5, staticKeypair, connection, remotePeer, handshake2) {
    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;
    if (remotePeer) {
      this.remotePeer = remotePeer;
    }
    this.xx = handshake2 ?? new XX(crypto5);
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
  }
  // stage 0
  async propose() {
    logLocalStaticKeys(this.session.hs.s);
    if (this.isInitiator) {
      log24.trace("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
      this.connection.writeLP(encode0(messageBuffer));
      log24.trace("Stage 0 - Initiator finished sending first message.");
      logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log24.trace("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());
      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      }
      log24.trace("Stage 0 - Responder received first message.");
      logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  // stage 1
  async exchange() {
    if (this.isInitiator) {
      log24.trace("Stage 1 - Initiator waiting to receive first message from responder...");
      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      }
      log24.trace("Stage 1 - Initiator received the message.");
      logRemoteEphemeralKey(this.session.hs.re);
      logRemoteStaticKey(this.session.hs.rs);
      log24.trace("Initiator going to check remote's signature...");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);
      }
      log24.trace("All good with the signature!");
    } else {
      log24.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode1(messageBuffer));
      log24.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
      logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  // stage 2
  async finish() {
    if (this.isInitiator) {
      log24.trace("Stage 2 - Initiator sending third handshake message.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode210(messageBuffer));
      log24.trace("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log24.trace("Stage 2 - Responder waiting for third handshake message...");
      const receivedMessageBuffer = decode210((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      }
      log24.trace("Stage 2 - Responder received the message, finished handshake.");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
  }
  decrypt(ciphertext, session, dst) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    }
    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }
  setRemoteNoiseExtension(e) {
    if (e) {
      this.remoteExtensions = e;
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}
__name(registerMetrics, "registerMetrics");

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var Noise = class {
  static {
    __name(this, "Noise");
  }
  protocol = "/noise";
  crypto;
  prologue;
  staticKeys;
  extensions;
  metrics;
  constructor(init = {}) {
    const { staticNoiseKey, extensions, crypto: crypto5, prologueBytes, metrics } = init;
    this.crypto = crypto5 ?? pureJsCrypto;
    this.extensions = extensions;
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKeys = this.crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? new Uint8Array(0);
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer
   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encrypted
   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
   * @returns {Promise<SecuredConnection>}
   */
  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteExtensions: handshake2.remoteExtensions,
      remotePeer: handshake2.remotePeer
    };
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer.
   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encryption.
   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
   * @returns {Promise<SecuredConnection>}
   */
  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remotePeer: handshake2.remotePeer,
      remoteExtensions: handshake2.remoteExtensions
    };
  }
  /**
   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.
   * If noise pipes disabled or remote peer static key is unknown, use XX.
   *
   * @param {HandshakeParams} params
   */
  async performHandshake(params) {
    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions);
    return this.performXXHandshake(params, payload);
  }
  async performXXHandshake(params, payload) {
    const { isInitiator, remotePeer, connection } = params;
    const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
    try {
      await handshake2.propose();
      await handshake2.exchange();
      await handshake2.finish();
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      if (e instanceof Error) {
        e.message = `Error occurred during XX handshake: ${e.message}`;
        throw e;
      }
    }
    return handshake2;
  }
  async createSecureConnection(connection, handshake2) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      // write to wrapper
      encryptStream(handshake2, this.metrics),
      // encrypt data + prefix with message length
      network,
      // send to the remote peer
      (source) => decode21(source, { lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(handshake2, this.metrics),
      // decrypt the incoming data
      secure
      // pipe to the wrapper
    );
    return user;
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
function noise(init = {}) {
  return () => new Noise(init);
}
__name(noise, "noise");

// node_modules/@chainsafe/libp2p-yamux/node_modules/@libp2p/logger/dist/src/index.js
var import_debug8 = __toESM(require_browser(), 1);

// node_modules/@chainsafe/libp2p-yamux/node_modules/multiformats/vendor/base-x.js
function base21(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base21, "base");
var src18 = base21;
var _brrp__multiformats_scope_baseX18 = src18;
var base_x_default18 = _brrp__multiformats_scope_baseX18;

// node_modules/@chainsafe/libp2p-yamux/node_modules/multiformats/src/bytes.js
var empty19 = new Uint8Array(0);
var coerce19 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@chainsafe/libp2p-yamux/node_modules/multiformats/src/bases/base.js
var Encoder18 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder18 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or18(this, decoder);
  }
};
var ComposedDecoder18 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or18(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or18 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder18(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec18 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder18(name14, prefix, baseEncode);
    this.decoder = new Decoder18(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from28 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec18(name14, prefix, encode79, decode97), "from");
var baseX18 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default18(alphabet11, name14);
  return from28({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce19(decode97(text))
  });
}, "baseX");
var decode62 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode50 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464818 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from28({
    prefix,
    name: name14,
    encode(input) {
      return encode50(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode62(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@chainsafe/libp2p-yamux/node_modules/multiformats/src/bases/base58.js
var base58btc18 = baseX18({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr18 = baseX18({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@chainsafe/libp2p-yamux/node_modules/multiformats/src/bases/base32.js
var base3217 = rfc464818({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper17 = rfc464818({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad17 = rfc464818({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper17 = rfc464818({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex17 = rfc464818({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper17 = rfc464818({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad17 = rfc464818({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper17 = rfc464818({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z17 = rfc464818({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@chainsafe/libp2p-yamux/node_modules/multiformats/src/bases/base64.js
var base6417 = rfc464818({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad17 = rfc464818({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url17 = rfc464818({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad17 = rfc464818({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@chainsafe/libp2p-yamux/node_modules/@libp2p/logger/dist/src/index.js
import_debug8.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc18.baseEncode(v);
};
import_debug8.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3217.baseEncode(v);
};
import_debug8.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6417.baseEncode(v);
};
import_debug8.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug8.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug8.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug8.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger10(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger10, "createDisabledLogger");
function logger11(name14) {
  let trace = createDisabledLogger10(`${name14}:trace`);
  if (import_debug8.default.enabled(`${name14}:trace`) && import_debug8.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug8.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug8.default)(name14), {
    error: (0, import_debug8.default)(`${name14}:error`),
    trace
  });
}
__name(logger11, "logger");

// node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
var ERR_INVALID_FRAME = "ERR_INVALID_FRAME";
var ERR_UNREQUESTED_PING = "ERR_UNREQUESTED_PING";
var ERR_NOT_MATCHING_PING = "ERR_NOT_MATCHING_PING";
var ERR_STREAM_ALREADY_EXISTS = "ERR_STREAM_ALREADY_EXISTS";
var ERR_DECODE_INVALID_VERSION = "ERR_DECODE_INVALID_VERSION";
var ERR_BOTH_CLIENTS = "ERR_BOTH_CLIENTS";
var ERR_RECV_WINDOW_EXCEEDED = "ERR_RECV_WINDOW_EXCEEDED";
var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  ERR_INVALID_FRAME,
  ERR_UNREQUESTED_PING,
  ERR_NOT_MATCHING_PING,
  ERR_STREAM_ALREADY_EXISTS,
  ERR_DECODE_INVALID_VERSION,
  ERR_BOTH_CLIENTS,
  ERR_RECV_WINDOW_EXCEEDED
]);
var ERR_INVALID_CONFIG = "ERR_INVALID_CONFIG";
var ERR_MUXER_LOCAL_CLOSED = "ERR_MUXER_LOCAL_CLOSED";
var ERR_MUXER_REMOTE_CLOSED = "ERR_MUXER_REMOTE_CLOSED";
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = "ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED";
var ERR_DECODE_IN_PROGRESS = "ERR_DECODE_IN_PROGRESS";
var INITIAL_STREAM_WINDOW = 256 * 1024;
var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

// node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
var defaultConfig = {
  log: logger11("libp2p:yamux"),
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  initialStreamWindowSize: INITIAL_STREAM_WINDOW,
  maxStreamWindowSize: MAX_STREAM_WINDOW,
  maxMessageSize: 64 * 1024
};
function verifyConfig(config) {
  if (config.keepAliveInterval <= 0) {
    throw new CodeError("keep-alive interval must be positive", ERR_INVALID_CONFIG);
  }
  if (config.maxInboundStreams < 0) {
    throw new CodeError("max inbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  }
  if (config.maxOutboundStreams < 0) {
    throw new CodeError("max outbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  }
  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
    throw new CodeError("InitialStreamWindowSize must be larger or equal 256 kB", ERR_INVALID_CONFIG);
  }
  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {
    throw new CodeError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize", ERR_INVALID_CONFIG);
  }
  if (config.maxStreamWindowSize > 2 ** 32 - 1) {
    throw new CodeError("MaxStreamWindowSize must be less than equal MAX_UINT32", ERR_INVALID_CONFIG);
  }
  if (config.maxMessageSize < 1024) {
    throw new CodeError("MaxMessageSize must be greater than a kilobyte", ERR_INVALID_CONFIG);
  }
}
__name(verifyConfig, "verifyConfig");

// node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
var YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
var HEADER_LENGTH = 12;
function stringifyHeader(header) {
  const flags = flagCodes.filter((f) => (header.flag & f) === f).map((f) => Flag[f]).join("|");
  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`;
}
__name(stringifyHeader, "stringifyHeader");

// node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
var twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new CodeError("Invalid frame version", ERR_DECODE_INVALID_VERSION);
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
__name(decodeHeader, "decodeHeader");
var Decoder19 = class {
  static {
    __name(this, "Decoder");
  }
  source;
  /** Buffer for in-progress frames */
  buffer;
  /** Used to sanity check against decoding while in an inconsistent state */
  frameInProgress;
  constructor(source) {
    this.source = returnlessSource(source);
    this.buffer = new Uint8ArrayList();
    this.frameInProgress = false;
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  async *emitFrames() {
    for await (const chunk of this.source) {
      this.buffer.append(chunk);
      while (true) {
        const header = this.readHeader();
        if (header === void 0) {
          break;
        }
        const { type, length: length21 } = header;
        if (type === FrameType.Data) {
          this.frameInProgress = true;
          yield {
            header,
            readData: this.readBytes.bind(this, length21)
          };
        } else {
          yield { header };
        }
      }
    }
  }
  readHeader() {
    if (this.frameInProgress) {
      throw new CodeError("decoding frame already in progress", ERR_DECODE_IN_PROGRESS);
    }
    if (this.buffer.length < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    this.buffer.consume(HEADER_LENGTH);
    return header;
  }
  async readBytes(length21) {
    if (this.buffer.length < length21) {
      for await (const chunk of this.source) {
        this.buffer.append(chunk);
        if (this.buffer.length >= length21) {
          break;
        }
      }
    }
    const out = this.buffer.sublist(0, length21);
    this.buffer.consume(length21);
    this.frameInProgress = false;
    return out;
  }
};
function returnlessSource(source) {
  if (source[Symbol.iterator] !== void 0) {
    const iterator = source[Symbol.iterator]();
    iterator.return = void 0;
    return {
      [Symbol.iterator]() {
        return iterator;
      }
    };
  } else if (source[Symbol.asyncIterator] !== void 0) {
    const iterator = source[Symbol.asyncIterator]();
    iterator.return = void 0;
    return {
      [Symbol.asyncIterator]() {
        return iterator;
      }
    };
  } else {
    throw new Error("a source must be either an iterable or an async iterable");
  }
}
__name(returnlessSource, "returnlessSource");

// node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}
__name(encodeHeader, "encodeHeader");

// node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
})(StreamState || (StreamState = {}));
var HalfStreamState;
(function(HalfStreamState2) {
  HalfStreamState2[HalfStreamState2["Open"] = 0] = "Open";
  HalfStreamState2[HalfStreamState2["Closed"] = 1] = "Closed";
  HalfStreamState2[HalfStreamState2["Reset"] = 2] = "Reset";
})(HalfStreamState || (HalfStreamState = {}));
var YamuxStream = class {
  static {
    __name(this, "YamuxStream");
  }
  id;
  name;
  stat;
  metadata;
  state;
  /** Used to track received FIN/RST */
  readState;
  /** Used to track sent FIN/RST */
  writeState;
  /** Input to the read side of the stream */
  sourceInput;
  /** Read side of the stream */
  source;
  /** Write side of the stream */
  sink;
  config;
  log;
  _id;
  /** The number of available bytes to send */
  sendWindowCapacity;
  /** Callback to notify that the sendWindowCapacity has been updated */
  sendWindowCapacityUpdate;
  /** The number of bytes available to receive in a full window */
  recvWindow;
  /** The number of available bytes to receive */
  recvWindowCapacity;
  /**
   * An 'epoch' is the time it takes to process and read data
   *
   * Used in conjunction with RTT to determine whether to increase the recvWindow
   */
  epochStart;
  getRTT;
  /** Used to stop the sink */
  abortController;
  sendFrame;
  onStreamEnd;
  constructor(init) {
    this.config = init.config;
    this.log = init.log;
    this._id = init.id;
    this.id = String(init.id);
    this.name = init.name;
    this.stat = {
      direction: init.direction,
      timeline: {
        open: Date.now()
      }
    };
    this.metadata = {};
    this.state = init.state;
    this.readState = HalfStreamState.Open;
    this.writeState = HalfStreamState.Open;
    this.sendWindowCapacity = INITIAL_STREAM_WINDOW;
    this.recvWindow = this.config.initialStreamWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = Date.now();
    this.getRTT = init.getRTT;
    this.abortController = new AbortController();
    this.sendFrame = init.sendFrame;
    this.onStreamEnd = init.onStreamEnd;
    this.sourceInput = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log?.error("stream source ended id=%s", this._id, err);
        } else {
          this.log?.trace("stream source ended id=%s", this._id);
        }
        this.closeRead();
      }
    });
    this.source = this.createSource();
    this.sink = async (source) => {
      if (this.writeState !== HalfStreamState.Open) {
        throw new Error("stream closed for writing");
      }
      source = abortableSource(source, this.abortController.signal, { returnOnAbort: true });
      try {
        for await (let data of source) {
          while (data.length !== 0) {
            if (this.sendWindowCapacity === 0)
              await this.waitForSendWindowCapacity();
            const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, data.length);
            this.sendData(data.subarray(0, toSend));
            this.sendWindowCapacity -= toSend;
            data = data.subarray(toSend);
          }
        }
      } catch (e) {
        this.log?.error("stream sink error id=%s", this._id, e);
      } finally {
        this.log?.trace("stream sink ended id=%s", this._id);
        this.closeWrite();
      }
    };
  }
  async *createSource() {
    try {
      for await (const val of this.sourceInput) {
        this.sendWindowUpdate();
        yield val;
      }
    } catch (err) {
      const errCode6 = err.code;
      if (errCode6 !== ERR_STREAM_ABORT) {
        this.log?.error("stream source error id=%s", this._id, err);
        throw err;
      }
    }
  }
  close() {
    this.log?.trace("stream close id=%s", this._id);
    this.closeRead();
    this.closeWrite();
  }
  closeRead() {
    if (this.state === StreamState.Finished) {
      return;
    }
    if (this.readState !== HalfStreamState.Open) {
      return;
    }
    this.log?.trace("stream close read id=%s", this._id);
    this.readState = HalfStreamState.Closed;
    this.sourceInput.end();
    if (this.writeState !== HalfStreamState.Open) {
      this.finish();
    }
  }
  closeWrite() {
    if (this.state === StreamState.Finished) {
      return;
    }
    if (this.writeState !== HalfStreamState.Open) {
      return;
    }
    this.log?.trace("stream close write id=%s", this._id);
    this.writeState = HalfStreamState.Closed;
    this.sendClose();
    this.abortController.abort();
    if (this.readState !== HalfStreamState.Open) {
      this.finish();
    }
  }
  abort(err) {
    switch (this.state) {
      case StreamState.Finished:
        return;
      case StreamState.Init:
        break;
      case StreamState.SYNSent:
      case StreamState.SYNReceived:
      case StreamState.Established:
        this.sendReset();
        break;
      default:
        throw new Error("unreachable");
    }
    if (err != null) {
      this.log?.error("stream abort id=%s error=%s", this._id, err);
    } else {
      this.log?.trace("stream abort id=%s", this._id);
    }
    this.onReset(new CodeError(String(err) ?? "stream aborted", ERR_STREAM_ABORT));
  }
  reset() {
    if (this.state === StreamState.Finished) {
      return;
    }
    this.log?.trace("stream reset id=%s", this._id);
    this.onReset(new CodeError("stream reset", ERR_STREAM_RESET));
  }
  /**
   * Called when initiating and receiving a stream reset
   */
  onReset(err) {
    if (this.writeState === HalfStreamState.Open) {
      this.writeState = HalfStreamState.Reset;
    }
    if (this.readState === HalfStreamState.Open) {
      this.readState = HalfStreamState.Reset;
    }
    this.state = StreamState.Finished;
    this.sourceInput.end(err);
    this.abortController.abort();
    this.finish();
  }
  /**
   * Wait for the send window to be non-zero
   *
   * Will throw with ERR_STREAM_ABORT if the stream gets aborted
   */
  async waitForSendWindowCapacity() {
    if (this.abortController.signal.aborted) {
      throw new CodeError("stream aborted", ERR_STREAM_ABORT);
    }
    if (this.sendWindowCapacity > 0) {
      return;
    }
    let reject;
    const abort = /* @__PURE__ */ __name(() => {
      reject(new CodeError("stream aborted", ERR_STREAM_ABORT));
    }, "abort");
    this.abortController.signal.addEventListener("abort", abort);
    await new Promise((_resolve, _reject) => {
      this.sendWindowCapacityUpdate = () => {
        this.abortController.signal.removeEventListener("abort", abort);
        _resolve(void 0);
      };
      reject = _reject;
    });
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(header) {
    this.log?.trace("stream received window update id=%s", this._id);
    this.processFlags(header.flag);
    const available = this.sendWindowCapacity;
    this.sendWindowCapacity += header.length;
    if (available === 0 && header.length > 0) {
      this.sendWindowCapacityUpdate?.();
    }
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  async handleData(header, readData) {
    this.log?.trace("stream received data id=%s", this._id);
    this.processFlags(header.flag);
    if (this.recvWindowCapacity < header.length) {
      throw new CodeError("receive window exceeded", ERR_RECV_WINDOW_EXCEEDED, { available: this.recvWindowCapacity, recv: header.length });
    }
    const data = await readData();
    this.recvWindowCapacity -= header.length;
    this.sourceInput.push(data);
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.closeRead();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.reset();
    }
  }
  /**
   * finish sets the state and triggers eventual garbage collection of the stream
   */
  finish() {
    this.log?.trace("stream finished id=%s", this._id);
    this.state = StreamState.Finished;
    this.stat.timeline.close = Date.now();
    this.onStreamEnd();
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * potentially sends a window update enabling further writes to take place.
   */
  sendWindowUpdate() {
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > 0 && now - this.epochStart < rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: delta
    });
  }
  sendData(data) {
    const flags = this.getSendFlags();
    this.sendFrame({
      type: FrameType.Data,
      flag: flags,
      streamID: this._id,
      length: data.length
    }, data);
  }
  sendClose() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: 0
    });
  }
  sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this._id,
      length: 0
    });
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
var Yamux = class {
  static {
    __name(this, "Yamux");
  }
  protocol = YAMUX_PROTOCOL_ID;
  _init;
  constructor(init = {}) {
    this._init = init;
  }
  createStreamMuxer(init) {
    return new YamuxMuxer({
      ...this._init,
      ...init
    });
  }
};
var YamuxMuxer = class {
  static {
    __name(this, "YamuxMuxer");
  }
  protocol = YAMUX_PROTOCOL_ID;
  source;
  sink;
  _init;
  config;
  log;
  /** Used to close the muxer from either the sink or source */
  closeController;
  /** The next stream id to be used when initiating a new stream */
  nextStreamID;
  /** Primary stream mapping, streamID => stream */
  _streams;
  /** The next ping id to be used when pinging */
  nextPingID;
  /** Tracking info for the currently active ping */
  activePing;
  /** Round trip time */
  rtt;
  /** True if client, false if server */
  client;
  localGoAway;
  remoteGoAway;
  /** Number of tracked inbound streams */
  numInboundStreams;
  /** Number of tracked outbound streams */
  numOutboundStreams;
  onIncomingStream;
  onStreamEnd;
  constructor(init) {
    this._init = init;
    this.client = init.direction === "outbound";
    this.config = { ...defaultConfig, ...init };
    this.log = this.config.log;
    verifyConfig(this.config);
    this.closeController = new AbortController();
    this.onIncomingStream = init.onIncomingStream;
    this.onStreamEnd = init.onStreamEnd;
    this._streams = /* @__PURE__ */ new Map();
    this.source = pushable({
      onEnd: (err) => {
        this.log?.trace("muxer source ended");
        this.close(err);
      }
    });
    this.sink = async (source) => {
      let signal;
      if (this._init.signal != null) {
        signal = anySignal([this.closeController.signal, this._init.signal]);
      }
      source = abortableSource(source, signal ?? this.closeController.signal, { returnOnAbort: true });
      let reason, error;
      try {
        const decoder = new Decoder19(source);
        await pipe(decoder.emitFrames.bind(decoder), async (source2) => {
          for await (const { header, readData } of source2) {
            await this.handleFrame(header, readData);
          }
        });
        reason = GoAwayCode.NormalTermination;
      } catch (err) {
        const errCode6 = err.code;
        if (PROTOCOL_ERRORS.has(errCode6)) {
          this.log?.error("protocol error in sink", err);
          reason = GoAwayCode.ProtocolError;
        } else {
          this.log?.error("internal error in sink", err);
          reason = GoAwayCode.InternalError;
        }
        error = err;
      } finally {
        if (signal != null) {
          signal.clear();
        }
      }
      this.log?.trace("muxer sink ended");
      this.close(error, reason);
    };
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = 0;
    this.log?.trace("muxer created");
    if (this.config.enableKeepAlive) {
      this.keepAliveLoop().catch((e) => this.log?.error("keepalive error: %s", e));
    }
  }
  get streams() {
    return Array.from(this._streams.values());
  }
  newStream(name14) {
    if (this.remoteGoAway !== void 0) {
      throw new CodeError("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    }
    if (this.localGoAway !== void 0) {
      throw new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {
      throw new CodeError("max outbound streams exceeded", ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);
    }
    this.log?.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, name14, StreamState.Init, "outbound");
    this._streams.set(id, stream);
    this.numOutboundStreams++;
    stream.sendWindowUpdate();
    return stream;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping() {
    if (this.remoteGoAway !== void 0) {
      throw new CodeError("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    }
    if (this.localGoAway !== void 0) {
      throw new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    }
    if (this.activePing === void 0) {
      let _resolve = /* @__PURE__ */ __name(() => {
      }, "_resolve");
      this.activePing = {
        id: this.nextPingID++,
        // this promise awaits resolution or the close controller aborting
        promise: new Promise((resolve, reject) => {
          const closed = /* @__PURE__ */ __name(() => {
            reject(new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED));
          }, "closed");
          this.closeController.signal.addEventListener("abort", closed, { once: true });
          _resolve = /* @__PURE__ */ __name(() => {
            this.closeController.signal.removeEventListener("abort", closed);
            resolve();
          }, "_resolve");
        }),
        resolve: _resolve
      };
      const start = Date.now();
      this.sendPing(this.activePing.id);
      try {
        await this.activePing.promise;
      } finally {
        delete this.activePing;
      }
      const end = Date.now();
      this.rtt = end - start;
    } else {
      await this.activePing.promise;
    }
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   *
   * @param err
   * @param reason - The GoAway reason to be sent
   */
  close(err, reason) {
    if (this.closeController.signal.aborted) {
      return;
    }
    reason = reason ?? (err === void 0 ? GoAwayCode.InternalError : GoAwayCode.NormalTermination);
    if (err != null) {
      this.log?.error("muxer close reason=%s error=%s", GoAwayCode[reason], err);
    } else {
      this.log?.trace("muxer close reason=%s", GoAwayCode[reason]);
    }
    if (err === void 0) {
      for (const stream of this._streams.values()) {
        stream.close();
      }
    } else {
      for (const stream of this._streams.values()) {
        stream.abort(err);
      }
    }
    this.sendGoAway(reason);
    this._closeMuxer();
  }
  isClosed() {
    return this.closeController.signal.aborted;
  }
  /**
   * Called when either the local or remote shuts down the muxer
   */
  _closeMuxer() {
    this.closeController.abort();
    this.source.end();
  }
  /** Create a new stream */
  _newStream(id, name14, state, direction) {
    if (this._streams.get(id) != null) {
      throw new CodeError("Stream already exists", ERR_STREAM_ALREADY_EXISTS, { id });
    }
    const stream = new YamuxStream({
      id,
      name: name14,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      onStreamEnd: () => {
        this.closeStream(id);
        this.onStreamEnd?.(stream);
      },
      log: this.log,
      config: this.config,
      getRTT: this.getRTT.bind(this)
    });
    return stream;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
    this._streams.delete(id);
  }
  async keepAliveLoop() {
    const abortPromise = new Promise((_resolve, reject) => {
      this.closeController.signal.addEventListener("abort", reject, { once: true });
    });
    this.log?.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval);
    while (true) {
      let timeoutId;
      try {
        await Promise.race([
          abortPromise,
          new Promise((resolve) => {
            timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
          })
        ]);
        this.ping().catch((e) => this.log?.error("ping error: %s", e));
      } catch (e) {
        clearInterval(timeoutId);
        return;
      }
    }
  }
  async handleFrame(header, readData) {
    const { streamID, type, length: length21 } = header;
    this.log?.trace("received frame %s", stringifyHeader(header));
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length21);
          return;
        }
        default:
          throw new CodeError("Invalid frame type", ERR_INVALID_FRAME, { header });
      }
    } else {
      switch (header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          await this.handleStreamMessage(header, readData);
          return;
        }
        default:
          throw new CodeError("Invalid frame type", ERR_INVALID_FRAME, { header });
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log?.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log?.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new CodeError("Invalid frame flag", ERR_INVALID_FRAME, { header });
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new CodeError("ping not requested", ERR_UNREQUESTED_PING);
    }
    if (this.activePing.id !== pingId) {
      throw new CodeError("ping doesn't match our id", ERR_NOT_MATCHING_PING);
    }
    this.activePing.resolve();
  }
  handleGoAway(reason) {
    this.log?.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    for (const stream of this._streams.values()) {
      stream.reset();
    }
    this._closeMuxer();
  }
  async handleStreamMessage(header, readData) {
    const { streamID, flag, type } = header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this._streams.get(streamID);
    if (stream === void 0) {
      if (type === FrameType.Data) {
        this.log?.("discarding data for stream id=%s", streamID);
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await readData();
      } else {
        this.log?.("frame for missing stream id=%s", streamID);
      }
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(header);
        return;
      }
      case FrameType.Data: {
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await stream.handleData(header, readData);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new CodeError("both endpoints are clients", ERR_BOTH_CLIENTS);
    }
    if (this._streams.has(id)) {
      return;
    }
    this.log?.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.config.maxInboundStreams) {
      this.log?.("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, void 0, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this._streams.set(id, stream);
    this.onIncomingStream?.(stream);
  }
  sendFrame(header, data) {
    this.log?.trace("sending frame %s", stringifyHeader(header));
    if (header.type === FrameType.Data) {
      if (data === void 0) {
        throw new CodeError("invalid frame", ERR_INVALID_FRAME);
      }
      this.source.push(encodeHeader(header));
      this.source.push(data);
    } else {
      this.source.push(encodeHeader(header));
    }
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log?.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log?.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log?.("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
function yamux(init = {}) {
  return () => new Yamux(init);
}
__name(yamux, "yamux");

// node_modules/@libp2p/bootstrap/node_modules/@libp2p/logger/dist/src/index.js
var import_debug9 = __toESM(require_browser(), 1);

// node_modules/@libp2p/bootstrap/node_modules/multiformats/vendor/base-x.js
function base28(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base28, "base");
var src19 = base28;
var _brrp__multiformats_scope_baseX19 = src19;
var base_x_default19 = _brrp__multiformats_scope_baseX19;

// node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bytes.js
var empty20 = new Uint8Array(0);
var coerce20 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bases/base.js
var Encoder19 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder20 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or19(this, decoder);
  }
};
var ComposedDecoder19 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or19(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or19 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder19(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec19 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder19(name14, prefix, baseEncode);
    this.decoder = new Decoder20(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from29 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec19(name14, prefix, encode79, decode97), "from");
var baseX19 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default19(alphabet11, name14);
  return from29({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce20(decode97(text))
  });
}, "baseX");
var decode63 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode51 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464819 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from29({
    prefix,
    name: name14,
    encode(input) {
      return encode51(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode63(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bases/base58.js
var base58btc19 = baseX19({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr19 = baseX19({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bases/base32.js
var base3218 = rfc464819({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper18 = rfc464819({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad18 = rfc464819({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper18 = rfc464819({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex18 = rfc464819({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper18 = rfc464819({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad18 = rfc464819({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper18 = rfc464819({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z18 = rfc464819({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/bootstrap/node_modules/multiformats/src/bases/base64.js
var base6418 = rfc464819({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad18 = rfc464819({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url18 = rfc464819({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad18 = rfc464819({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/bootstrap/node_modules/@libp2p/logger/dist/src/index.js
import_debug9.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc19.baseEncode(v);
};
import_debug9.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3218.baseEncode(v);
};
import_debug9.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6418.baseEncode(v);
};
import_debug9.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug9.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug9.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug9.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger11(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger11, "createDisabledLogger");
function logger12(name14) {
  let trace = createDisabledLogger11(`${name14}:trace`);
  if (import_debug9.default.enabled(`${name14}:trace`) && import_debug9.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug9.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug9.default)(name14), {
    error: (0, import_debug9.default)(`${name14}:error`),
    trace
  });
}
__name(logger12, "logger");

// node_modules/@multiformats/mafmt/dist/src/index.js
var DNS4 = base29("dns4");
var DNS6 = base29("dns6");
var DNSADDR = base29("dnsaddr");
var DNS2 = or20(base29("dns"), DNSADDR, DNS4, DNS6);
var IP = or20(base29("ip4"), base29("ip6"));
var TCP = or20(and(IP, base29("tcp")), and(DNS2, base29("tcp")));
var UDP = and(IP, base29("udp"));
var UTP = and(UDP, base29("utp"));
var QUIC = and(UDP, base29("quic"));
var QUICV1 = and(UDP, base29("quic-v1"));
var _WebSockets = or20(and(TCP, base29("ws")), and(DNS2, base29("ws")));
var WebSockets = or20(and(_WebSockets, base29("p2p")), _WebSockets);
var _WebSocketsSecure = or20(and(TCP, base29("wss")), and(DNS2, base29("wss")), and(TCP, base29("tls"), base29("ws")), and(DNS2, base29("tls"), base29("ws")));
var WebSocketsSecure = or20(and(_WebSocketsSecure, base29("p2p")), _WebSocketsSecure);
var HTTP = or20(and(TCP, base29("http")), and(IP, base29("http")), and(DNS2, base29("http")));
var HTTPS = or20(and(TCP, base29("https")), and(IP, base29("https")), and(DNS2, base29("https")));
var _WebRTCDirect = and(UDP, base29("webrtc-direct"), base29("certhash"));
var WebRTCDirect = or20(and(_WebRTCDirect, base29("p2p")), _WebRTCDirect);
var _WebTransport = and(QUICV1, base29("webtransport"), base29("certhash"), base29("certhash"));
var WebTransport2 = or20(and(_WebTransport, base29("p2p")), _WebTransport);
var P2PWebRTCStar = or20(and(WebSockets, base29("p2p-webrtc-star"), base29("p2p")), and(WebSocketsSecure, base29("p2p-webrtc-star"), base29("p2p")), and(WebSockets, base29("p2p-webrtc-star")), and(WebSocketsSecure, base29("p2p-webrtc-star")));
var WebSocketStar = or20(and(WebSockets, base29("p2p-websocket-star"), base29("p2p")), and(WebSocketsSecure, base29("p2p-websocket-star"), base29("p2p")), and(WebSockets, base29("p2p-websocket-star")), and(WebSocketsSecure, base29("p2p-websocket-star")));
var P2PWebRTCDirect = or20(and(HTTP, base29("p2p-webrtc-direct"), base29("p2p")), and(HTTPS, base29("p2p-webrtc-direct"), base29("p2p")), and(HTTP, base29("p2p-webrtc-direct")), and(HTTPS, base29("p2p-webrtc-direct")));
var Reliable = or20(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS2, WebRTCDirect, WebTransport2);
var Stardust = or20(and(Reliable, base29("p2p-stardust"), base29("p2p")), and(Reliable, base29("p2p-stardust")));
var _P2P = or20(and(Reliable, base29("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport2, base29("p2p"));
var _Circuit = or20(and(_P2P, base29("p2p-circuit"), _P2P), and(_P2P, base29("p2p-circuit")), and(base29("p2p-circuit"), _P2P), and(Reliable, base29("p2p-circuit")), and(base29("p2p-circuit"), Reliable), base29("p2p-circuit"));
var CircuitRecursive = /* @__PURE__ */ __name(() => or20(and(_Circuit, CircuitRecursive), _Circuit), "CircuitRecursive");
var Circuit = CircuitRecursive();
var P2P = or20(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
var WebRTC = or20(and(Circuit, base29("webrtc"), base29("p2p")), and(Circuit, base29("webrtc")), and(Reliable, base29("webrtc"), base29("p2p")), and(Reliable, base29("webrtc")), base29("webrtc"));
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  __name(matches, "matches");
  return matches;
}
__name(makeMatchesFunction, "makeMatchesFunction");
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  __name(partialMatch, "partialMatch");
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
__name(and, "and");
function or20(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  __name(partialMatch, "partialMatch");
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
__name(or20, "or");
function base29(n) {
  const name14 = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name14) {
      return true;
    }
    return false;
  }
  __name(matches, "matches");
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name14) {
      return protos.slice(1);
    }
    return null;
  }
  __name(partialMatch, "partialMatch");
  return {
    toString: function() {
      return name14;
    },
    matches,
    partialMatch
  };
}
__name(base29, "base");

// node_modules/@libp2p/bootstrap/dist/src/index.js
var log25 = logger12("libp2p:bootstrap");
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_TAG_TTL = 12e4;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var Bootstrap = class extends EventEmitter6 {
  static {
    __name(this, "Bootstrap");
  }
  static tag = "bootstrap";
  timer;
  list;
  timeout;
  components;
  _init;
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.components = components;
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        log25.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        log25.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma],
        protocols: []
      };
      this.list.push(peerData);
    }
    this._init = options;
  }
  [peerDiscovery] = this;
  [Symbol.toStringTag] = "@libp2p/bootstrap";
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    log25("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        log25.error(err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
          }
        }
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}
__name(bootstrap, "bootstrap");

// node_modules/@libp2p/ipni-content-routing/node_modules/@libp2p/logger/dist/src/index.js
var import_debug10 = __toESM(require_browser(), 1);

// node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/vendor/base-x.js
function base30(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base30, "base");
var src20 = base30;
var _brrp__multiformats_scope_baseX20 = src20;
var base_x_default20 = _brrp__multiformats_scope_baseX20;

// node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bytes.js
var empty21 = new Uint8Array(0);
var coerce21 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bases/base.js
var Encoder20 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder21 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or21(this, decoder);
  }
};
var ComposedDecoder20 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or21(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or21 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder20(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec20 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder20(name14, prefix, baseEncode);
    this.decoder = new Decoder21(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from30 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec20(name14, prefix, encode79, decode97), "from");
var baseX20 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default20(alphabet11, name14);
  return from30({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce21(decode97(text))
  });
}, "baseX");
var decode64 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode52 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464820 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from30({
    prefix,
    name: name14,
    encode(input) {
      return encode52(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode64(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bases/base58.js
var base58btc20 = baseX20({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr20 = baseX20({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bases/base32.js
var base3219 = rfc464820({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper19 = rfc464820({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad19 = rfc464820({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper19 = rfc464820({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex19 = rfc464820({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper19 = rfc464820({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad19 = rfc464820({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper19 = rfc464820({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z19 = rfc464820({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/ipni-content-routing/node_modules/multiformats/src/bases/base64.js
var base6419 = rfc464820({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad19 = rfc464820({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url19 = rfc464820({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad19 = rfc464820({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/ipni-content-routing/node_modules/@libp2p/logger/dist/src/index.js
import_debug10.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc20.baseEncode(v);
};
import_debug10.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3219.baseEncode(v);
};
import_debug10.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6419.baseEncode(v);
};
import_debug10.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug10.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug10.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug10.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger12(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger12, "createDisabledLogger");
function logger13(name14) {
  let trace = createDisabledLogger12(`${name14}:trace`);
  if (import_debug10.default.enabled(`${name14}:trace`) && import_debug10.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug10.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug10.default)(name14), {
    error: (0, import_debug10.default)(`${name14}:error`),
    trace
  });
}
__name(logger13, "logger");

// node_modules/browser-readablestream-to-it/dist/src/index.js
async function* browserReadableStreamToIt(stream, options = {}) {
  const reader2 = stream.getReader();
  try {
    while (true) {
      const result = await reader2.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      await reader2.cancel();
    }
    reader2.releaseLock();
  }
}
__name(browserReadableStreamToIt, "browserReadableStreamToIt");

// node_modules/@libp2p/ipni-content-routing/dist/src/index.js
var import_iterable_ndjson = __toESM(require_browser4(), 1);

// node_modules/@libp2p/ipni-content-routing/node_modules/eventemitter3/index.mjs
var import_index14 = __toESM(require_eventemitter34(), 1);

// node_modules/@libp2p/ipni-content-routing/node_modules/p-timeout/index.js
var TimeoutError4 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError9 = class extends Error {
  static {
    __name(this, "AbortError");
  }
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException4 = /* @__PURE__ */ __name((errorMessage) => globalThis.DOMException === void 0 ? new AbortError9(errorMessage) : new DOMException(errorMessage), "getDOMException");
var getAbortedReason4 = /* @__PURE__ */ __name((signal) => {
  const reason = signal.reason === void 0 ? getDOMException4("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException4(reason);
}, "getAbortedReason");
function pTimeout4(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason4(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason4(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError4(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
__name(pTimeout4, "pTimeout");

// node_modules/@libp2p/ipni-content-routing/node_modules/p-queue/dist/lower-bound.js
function lowerBound5(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
__name(lowerBound5, "lowerBound");

// node_modules/@libp2p/ipni-content-routing/node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet5 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue3;
var PriorityQueue4 = class {
  static {
    __name(this, "PriorityQueue");
  }
  constructor() {
    _PriorityQueue_queue3.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet5(this, _PriorityQueue_queue3, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet5(this, _PriorityQueue_queue3, "f").push(element);
      return;
    }
    const index = lowerBound5(__classPrivateFieldGet5(this, _PriorityQueue_queue3, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet5(this, _PriorityQueue_queue3, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet5(this, _PriorityQueue_queue3, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet5(this, _PriorityQueue_queue3, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet5(this, _PriorityQueue_queue3, "f").length;
  }
};
_PriorityQueue_queue3 = /* @__PURE__ */ new WeakMap();
var priority_queue_default3 = PriorityQueue4;

// node_modules/@libp2p/ipni-content-routing/node_modules/p-queue/dist/index.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances3;
var _PQueue_carryoverConcurrencyCount3;
var _PQueue_isIntervalIgnored3;
var _PQueue_intervalCount3;
var _PQueue_intervalCap3;
var _PQueue_interval3;
var _PQueue_intervalEnd3;
var _PQueue_intervalId3;
var _PQueue_timeoutId3;
var _PQueue_queue3;
var _PQueue_queueClass3;
var _PQueue_pending3;
var _PQueue_concurrency3;
var _PQueue_isPaused3;
var _PQueue_throwOnTimeout3;
var _PQueue_doesIntervalAllowAnother_get5;
var _PQueue_doesConcurrentAllowAnother_get5;
var _PQueue_next5;
var _PQueue_onResumeInterval5;
var _PQueue_isIntervalPaused_get5;
var _PQueue_tryToStartAnother5;
var _PQueue_initializeIntervalIfNeeded5;
var _PQueue_onInterval5;
var _PQueue_processQueue5;
var _PQueue_throwOnAbort5;
var _PQueue_onEvent5;
var AbortError10 = class extends Error {
  static {
    __name(this, "AbortError");
  }
};
var PQueue4 = class extends import_index14.default {
  static {
    __name(this, "PQueue");
  }
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    _PQueue_instances3.add(this);
    _PQueue_carryoverConcurrencyCount3.set(this, void 0);
    _PQueue_isIntervalIgnored3.set(this, void 0);
    _PQueue_intervalCount3.set(this, 0);
    _PQueue_intervalCap3.set(this, void 0);
    _PQueue_interval3.set(this, void 0);
    _PQueue_intervalEnd3.set(this, 0);
    _PQueue_intervalId3.set(this, void 0);
    _PQueue_timeoutId3.set(this, void 0);
    _PQueue_queue3.set(this, void 0);
    _PQueue_queueClass3.set(this, void 0);
    _PQueue_pending3.set(this, 0);
    _PQueue_concurrency3.set(this, void 0);
    _PQueue_isPaused3.set(this, void 0);
    _PQueue_throwOnTimeout3.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: priority_queue_default3,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet3(this, _PQueue_carryoverConcurrencyCount3, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet3(this, _PQueue_isIntervalIgnored3, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet3(this, _PQueue_intervalCap3, options.intervalCap, "f");
    __classPrivateFieldSet3(this, _PQueue_interval3, options.interval, "f");
    __classPrivateFieldSet3(this, _PQueue_queue3, new options.queueClass(), "f");
    __classPrivateFieldSet3(this, _PQueue_queueClass3, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet3(this, _PQueue_throwOnTimeout3, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet3(this, _PQueue_isPaused3, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet6(this, _PQueue_concurrency3, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet3(this, _PQueue_concurrency3, newConcurrency, "f");
    __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_processQueue5).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet6(this, _PQueue_throwOnTimeout3, "f"),
      ...options
    };
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet6(this, _PQueue_queue3, "f").enqueue(async () => {
        var _a;
        var _b, _c;
        __classPrivateFieldSet3(this, _PQueue_pending3, (_b = __classPrivateFieldGet6(this, _PQueue_pending3, "f"), _b++, _b), "f");
        __classPrivateFieldSet3(this, _PQueue_intervalCount3, (_c = __classPrivateFieldGet6(this, _PQueue_intervalCount3, "f"), _c++, _c), "f");
        try {
          if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
            throw new AbortError10("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout4(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_throwOnAbort5).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError4 && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_next5).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_tryToStartAnother5).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet6(this, _PQueue_isPaused3, "f")) {
      return this;
    }
    __classPrivateFieldSet3(this, _PQueue_isPaused3, false, "f");
    __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_processQueue5).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet3(this, _PQueue_isPaused3, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet3(this, _PQueue_queue3, new (__classPrivateFieldGet6(this, _PQueue_queueClass3, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet6(this, _PQueue_queue3, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_onEvent5).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet6(this, _PQueue_queue3, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_onEvent5).call(this, "next", () => __classPrivateFieldGet6(this, _PQueue_queue3, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet6(this, _PQueue_pending3, "f") === 0 && __classPrivateFieldGet6(this, _PQueue_queue3, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_onEvent5).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet6(this, _PQueue_queue3, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet6(this, _PQueue_queue3, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet6(this, _PQueue_pending3, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet6(this, _PQueue_isPaused3, "f");
  }
};
_PQueue_carryoverConcurrencyCount3 = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored3 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount3 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap3 = /* @__PURE__ */ new WeakMap(), _PQueue_interval3 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd3 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId3 = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId3 = /* @__PURE__ */ new WeakMap(), _PQueue_queue3 = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass3 = /* @__PURE__ */ new WeakMap(), _PQueue_pending3 = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency3 = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused3 = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout3 = /* @__PURE__ */ new WeakMap(), _PQueue_instances3 = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get5 = /* @__PURE__ */ __name(function _PQueue_doesIntervalAllowAnother_get6() {
  return __classPrivateFieldGet6(this, _PQueue_isIntervalIgnored3, "f") || __classPrivateFieldGet6(this, _PQueue_intervalCount3, "f") < __classPrivateFieldGet6(this, _PQueue_intervalCap3, "f");
}, "_PQueue_doesIntervalAllowAnother_get"), _PQueue_doesConcurrentAllowAnother_get5 = /* @__PURE__ */ __name(function _PQueue_doesConcurrentAllowAnother_get6() {
  return __classPrivateFieldGet6(this, _PQueue_pending3, "f") < __classPrivateFieldGet6(this, _PQueue_concurrency3, "f");
}, "_PQueue_doesConcurrentAllowAnother_get"), _PQueue_next5 = /* @__PURE__ */ __name(function _PQueue_next6() {
  var _a;
  __classPrivateFieldSet3(this, _PQueue_pending3, (_a = __classPrivateFieldGet6(this, _PQueue_pending3, "f"), _a--, _a), "f");
  __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_tryToStartAnother5).call(this);
  this.emit("next");
}, "_PQueue_next"), _PQueue_onResumeInterval5 = /* @__PURE__ */ __name(function _PQueue_onResumeInterval6() {
  __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_onInterval5).call(this);
  __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_initializeIntervalIfNeeded5).call(this);
  __classPrivateFieldSet3(this, _PQueue_timeoutId3, void 0, "f");
}, "_PQueue_onResumeInterval"), _PQueue_isIntervalPaused_get5 = /* @__PURE__ */ __name(function _PQueue_isIntervalPaused_get6() {
  const now = Date.now();
  if (__classPrivateFieldGet6(this, _PQueue_intervalId3, "f") === void 0) {
    const delay = __classPrivateFieldGet6(this, _PQueue_intervalEnd3, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet3(this, _PQueue_intervalCount3, __classPrivateFieldGet6(this, _PQueue_carryoverConcurrencyCount3, "f") ? __classPrivateFieldGet6(this, _PQueue_pending3, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet6(this, _PQueue_timeoutId3, "f") === void 0) {
        __classPrivateFieldSet3(this, _PQueue_timeoutId3, setTimeout(() => {
          __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_onResumeInterval5).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, "_PQueue_isIntervalPaused_get"), _PQueue_tryToStartAnother5 = /* @__PURE__ */ __name(function _PQueue_tryToStartAnother6() {
  if (__classPrivateFieldGet6(this, _PQueue_queue3, "f").size === 0) {
    if (__classPrivateFieldGet6(this, _PQueue_intervalId3, "f")) {
      clearInterval(__classPrivateFieldGet6(this, _PQueue_intervalId3, "f"));
    }
    __classPrivateFieldSet3(this, _PQueue_intervalId3, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet6(this, _PQueue_pending3, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet6(this, _PQueue_isPaused3, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet6(this, _PQueue_instances3, "a", _PQueue_isIntervalPaused_get5);
    if (__classPrivateFieldGet6(this, _PQueue_instances3, "a", _PQueue_doesIntervalAllowAnother_get5) && __classPrivateFieldGet6(this, _PQueue_instances3, "a", _PQueue_doesConcurrentAllowAnother_get5)) {
      const job = __classPrivateFieldGet6(this, _PQueue_queue3, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_initializeIntervalIfNeeded5).call(this);
      }
      return true;
    }
  }
  return false;
}, "_PQueue_tryToStartAnother"), _PQueue_initializeIntervalIfNeeded5 = /* @__PURE__ */ __name(function _PQueue_initializeIntervalIfNeeded6() {
  if (__classPrivateFieldGet6(this, _PQueue_isIntervalIgnored3, "f") || __classPrivateFieldGet6(this, _PQueue_intervalId3, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet3(this, _PQueue_intervalId3, setInterval(() => {
    __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_onInterval5).call(this);
  }, __classPrivateFieldGet6(this, _PQueue_interval3, "f")), "f");
  __classPrivateFieldSet3(this, _PQueue_intervalEnd3, Date.now() + __classPrivateFieldGet6(this, _PQueue_interval3, "f"), "f");
}, "_PQueue_initializeIntervalIfNeeded"), _PQueue_onInterval5 = /* @__PURE__ */ __name(function _PQueue_onInterval6() {
  if (__classPrivateFieldGet6(this, _PQueue_intervalCount3, "f") === 0 && __classPrivateFieldGet6(this, _PQueue_pending3, "f") === 0 && __classPrivateFieldGet6(this, _PQueue_intervalId3, "f")) {
    clearInterval(__classPrivateFieldGet6(this, _PQueue_intervalId3, "f"));
    __classPrivateFieldSet3(this, _PQueue_intervalId3, void 0, "f");
  }
  __classPrivateFieldSet3(this, _PQueue_intervalCount3, __classPrivateFieldGet6(this, _PQueue_carryoverConcurrencyCount3, "f") ? __classPrivateFieldGet6(this, _PQueue_pending3, "f") : 0, "f");
  __classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_processQueue5).call(this);
}, "_PQueue_onInterval"), _PQueue_processQueue5 = /* @__PURE__ */ __name(function _PQueue_processQueue6() {
  while (__classPrivateFieldGet6(this, _PQueue_instances3, "m", _PQueue_tryToStartAnother5).call(this)) {
  }
}, "_PQueue_processQueue"), _PQueue_throwOnAbort5 = /* @__PURE__ */ __name(async function _PQueue_throwOnAbort6(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError10("The task was aborted."));
    }, { once: true });
  });
}, "_PQueue_throwOnAbort"), _PQueue_onEvent5 = /* @__PURE__ */ __name(async function _PQueue_onEvent6(event, filter2) {
  return new Promise((resolve) => {
    const listener = /* @__PURE__ */ __name(() => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    }, "listener");
    this.on(event, listener);
  });
}, "_PQueue_onEvent");
var dist_default4 = PQueue4;

// node_modules/@libp2p/ipni-content-routing/dist/src/index.js
var log26 = logger13("ipni-content-routing");
var defaultValues = {
  concurrentRequests: 4,
  timeout: 3e4
};
var IpniContentRouting = class {
  static {
    __name(this, "IpniContentRouting");
  }
  started;
  httpQueue;
  shutDownController;
  clientUrl;
  timeout;
  /**
   * Create a new DelegatedContentRouting instance
   */
  constructor(url, init = {}) {
    log26("enabled IPNI routing via", url);
    this.started = false;
    this.shutDownController = new AbortController();
    this.httpQueue = new dist_default4({
      concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
    });
    this.clientUrl = url instanceof URL ? url : new URL(url);
    this.timeout = init.timeout ?? defaultValues.timeout;
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.shutDownController.abort();
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    log26("findProviders starts: %c", key);
    const signal = anySignal([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const resource = `${this.clientUrl}cid/${key.toString()}?cascade=ipfs-dht`;
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const a = await fetch(resource, getOptions);
      if (a.body == null) {
        throw new CodeError("IPNI response had no body", "ERR_BAD_RESPONSE");
      }
      for await (const event of (0, import_iterable_ndjson.default)(browserReadableStreamToIt(a.body))) {
        if (event.Metadata !== "gBI=") {
          continue;
        }
        yield this.mapEvent(event);
      }
    } catch (err) {
      log26.error("findProviders errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log26("findProviders finished: %c", key);
    }
  }
  mapEvent(event) {
    const peer = peerIdFromString(event.Provider.ID);
    const ma = [];
    for (const strAddr of event.Provider.Addrs) {
      const addr = multiaddr(strAddr);
      ma.push(addr);
    }
    const pi = {
      id: peer,
      multiaddrs: ma,
      protocols: []
    };
    return pi;
  }
  async provide() {
  }
  async put() {
  }
  async get() {
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
};
function ipniContentRouting(url, init = {}) {
  return () => new IpniContentRouting(url, init);
}
__name(ipniContentRouting, "ipniContentRouting");

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/dist/src/index.js
var import_debug11 = __toESM(require_browser(), 1);

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/node_modules/multiformats/vendor/base-x.js
function base31(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base31, "base");
var src21 = base31;
var _brrp__multiformats_scope_baseX21 = src21;
var base_x_default21 = _brrp__multiformats_scope_baseX21;

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/node_modules/multiformats/src/bytes.js
var empty22 = new Uint8Array(0);
var coerce22 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js
var Encoder21 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder22 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or22(this, decoder);
  }
};
var ComposedDecoder21 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or22(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or22 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder21(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec21 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder21(name14, prefix, baseEncode);
    this.decoder = new Decoder22(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from31 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec21(name14, prefix, encode79, decode97), "from");
var baseX21 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default21(alphabet11, name14);
  return from31({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce22(decode97(text))
  });
}, "baseX");
var decode65 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode53 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464821 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from31({
    prefix,
    name: name14,
    encode(input) {
      return encode53(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode65(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base58.js
var base58btc21 = baseX21({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr21 = baseX21({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base32.js
var base3220 = rfc464821({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper20 = rfc464821({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad20 = rfc464821({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper20 = rfc464821({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex20 = rfc464821({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper20 = rfc464821({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad20 = rfc464821({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper20 = rfc464821({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z20 = rfc464821({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base64.js
var base6420 = rfc464821({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad20 = rfc464821({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url20 = rfc464821({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad20 = rfc464821({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/kad-dht/node_modules/@libp2p/logger/dist/src/index.js
import_debug11.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc21.baseEncode(v);
};
import_debug11.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3220.baseEncode(v);
};
import_debug11.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6420.baseEncode(v);
};
import_debug11.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug11.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug11.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug11.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger13(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger13, "createDisabledLogger");
function logger14(name14) {
  let trace = createDisabledLogger13(`${name14}:trace`);
  if (import_debug11.default.enabled(`${name14}:trace`) && import_debug11.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug11.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug11.default)(name14), {
    error: (0, import_debug11.default)(`${name14}:error`),
    trace
  });
}
__name(logger14, "logger");

// node_modules/@libp2p/record/dist/src/selectors.js
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    const errMsg = "No records given";
    throw new CodeError(errMsg, "ERR_NO_RECORDS_RECEIVED");
  }
  const kStr = toString5(k);
  const parts = kStr.split("/");
  if (parts.length < 3) {
    const errMsg = "Record key does not have a selector function";
    throw new CodeError(errMsg, "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
  }
  const selector = selectors2[parts[1].toString()];
  if (selector == null) {
    const errMsg = `Unrecognized key prefix: ${parts[1]}`;
    throw new CodeError(errMsg, "ERR_UNRECOGNIZED_KEY_PREFIX");
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
__name(bestRecord, "bestRecord");
function publickKey(k, records) {
  return 0;
}
__name(publickKey, "publickKey");
var selectors = {
  pk: publickKey
};

// node_modules/@libp2p/record/node_modules/multiformats/src/bytes.js
var empty23 = new Uint8Array(0);

// node_modules/@libp2p/record/node_modules/multiformats/vendor/varint.js
var encode_113 = encode54;
var MSB14 = 128;
var REST14 = 127;
var MSBALL13 = ~REST14;
var INT13 = Math.pow(2, 31);
function encode54(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT13) {
    out[offset++] = num & 255 | MSB14;
    num /= 128;
  }
  while (num & MSBALL13) {
    out[offset++] = num & 255 | MSB14;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode54.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode54, "encode");
var decode66 = read15;
var MSB$113 = 128;
var REST$113 = 127;
function read15(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read15.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$113) << shift : (b & REST$113) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$113);
  read15.bytes = counter - offset;
  return res;
}
__name(read15, "read");
var N116 = Math.pow(2, 7);
var N216 = Math.pow(2, 14);
var N316 = Math.pow(2, 21);
var N416 = Math.pow(2, 28);
var N516 = Math.pow(2, 35);
var N616 = Math.pow(2, 42);
var N716 = Math.pow(2, 49);
var N815 = Math.pow(2, 56);
var N915 = Math.pow(2, 63);
var length14 = /* @__PURE__ */ __name(function(value) {
  return value < N116 ? 1 : value < N216 ? 2 : value < N316 ? 3 : value < N416 ? 4 : value < N516 ? 5 : value < N616 ? 6 : value < N716 ? 7 : value < N815 ? 8 : value < N915 ? 9 : 10;
}, "length");
var varint14 = {
  encode: encode_113,
  decode: decode66,
  encodingLength: length14
};
var _brrp_varint13 = varint14;
var varint_default13 = _brrp_varint13;

// node_modules/@libp2p/record/node_modules/multiformats/src/varint.js
var encodeTo13 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default13.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength14 = /* @__PURE__ */ __name((int) => {
  return varint_default13.encodingLength(int);
}, "encodingLength");

// node_modules/@libp2p/record/node_modules/multiformats/src/hashes/digest.js
var create15 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength14(code16);
  const digestOffset = sizeOffset + encodingLength14(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo13(code16, bytes3, 0);
  encodeTo13(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest13(code16, size, digest13, bytes3);
}, "create");
var Digest13 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/record/node_modules/multiformats/src/hashes/hasher.js
var from32 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher11(name14, code16, encode79), "from");
var Hasher11 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create15(this.code, result) : result.then((digest13) => create15(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/record/node_modules/multiformats/src/hashes/sha2-browser.js
var sha11 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha25612 = from32({
  name: "sha2-256",
  code: 18,
  encode: sha11("SHA-256")
});
var sha51212 = from32({
  name: "sha2-512",
  code: 19,
  encode: sha11("SHA-512")
});

// node_modules/@libp2p/record/dist/src/validators.js
async function verifyRecord(validators2, record) {
  const key = record.key;
  const keyString = toString5(key);
  const parts = keyString.split("/");
  if (parts.length < 3) {
    return;
  }
  const validator = validators2[parts[1].toString()];
  if (validator == null) {
    const errMsg = "Invalid record keytype";
    throw new CodeError(errMsg, "ERR_INVALID_RECORD_KEY_TYPE");
  }
  await validator(key, record.value);
}
__name(verifyRecord, "verifyRecord");
var validatePublicKeyRecord = /* @__PURE__ */ __name(async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw new CodeError('"key" must be a Uint8Array', "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
  }
  if (key.byteLength < 5) {
    throw new CodeError("invalid public key record", "ERR_INVALID_RECORD_KEY_TOO_SHORT");
  }
  const prefix = toString5(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw new CodeError("key was not prefixed with /pk/", "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
  }
  const keyhash = key.slice(4);
  const publicKeyHash = await sha25612.digest(publicKey);
  if (!equals7(keyhash, publicKeyHash.bytes)) {
    throw new CodeError("public key does not match passed in key", "ERR_INVALID_RECORD_HASH_MISMATCH");
  }
}, "validatePublicKeyRecord");
var validators = {
  pk: validatePublicKeyRecord
};

// node_modules/@libp2p/kad-dht/dist/src/constants.js
var second2 = 1e3;
var minute2 = 60 * second2;
var hour = 60 * minute2;
var MAX_RECORD_AGE = 36 * hour;
var LAN_PREFIX = "/lan";
var PROTOCOL_PREFIX = "/ipfs";
var PROTOCOL_DHT = "/kad/1.0.0";
var RECORD_KEY_PREFIX = "/dht/record";
var PROVIDER_KEY_PREFIX = "/dht/provider";
var PROVIDERS_LRU_CACHE_SIZE = 256;
var PROVIDERS_VALIDITY = 24 * hour;
var PROVIDERS_CLEANUP_INTERVAL = hour;
var READ_MESSAGE_TIMEOUT = 10 * second2;
var K = 20;
var ALPHA = 3;
var QUERY_SELF_INTERVAL = Number(5 * minute2);
var QUERY_SELF_INITIAL_INTERVAL = Number(Number(second2));
var QUERY_SELF_TIMEOUT = Number(5 * second2);
var TABLE_REFRESH_INTERVAL = Number(5 * minute2);
var TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second2);
var DEFAULT_QUERY_TIMEOUT = Number(30 * second2);

// node_modules/@libp2p/record/dist/src/record.js
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.key != null && obj.key.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.key);
        }
        if (obj.value != null && obj.value.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.value);
        }
        if (obj.timeReceived != null && obj.timeReceived !== "") {
          w2.uint32(42);
          w2.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          key: new Uint8Array(0),
          value: new Uint8Array(0),
          timeReceived: ""
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.bytes();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            case 5:
              obj.timeReceived = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf3) => {
    return decodeMessage(buf3, Record3.codec());
  };
})(Record || (Record = {}));

// node_modules/@libp2p/record/dist/src/utils.js
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour2 = String(time.getUTCHours()).padStart(2, "0");
  const minute4 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour2}:${minute4}:${seconds}.${nanoseconds}Z`;
}
__name(toRFC3339, "toRFC3339");
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m2 = String(time).trim().match(rfc3339Matcher);
  if (m2 == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m2[1], 10);
  const month = parseInt(m2[2], 10) - 1;
  const date = parseInt(m2[3], 10);
  const hour2 = parseInt(m2[4], 10);
  const minute4 = parseInt(m2[5], 10);
  const second4 = parseInt(m2[6], 10);
  const millisecond = parseInt(m2[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute4, second4, millisecond));
}
__name(parseRFC3339, "parseRFC3339");

// node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class _Libp2pRecord {
  static {
    __name(this, "Libp2pRecord");
  }
  key;
  value;
  timeReceived;
  constructor(key, value, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  /**
   * Return the object format ready to be given to the protobuf library.
   */
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  /**
   * Decode a protobuf encoded record
   */
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  /**
   * Create a record from the raw object returned from the protobuf library
   */
  static fromDeserialized(obj) {
    const recvtime = parseRFC3339(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new _Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
};

// node_modules/it-parallel/dist/src/index.js
var CustomEvent2 = globalThis.CustomEvent ?? Event;
async function* parallel(source, options = {}) {
  let concurrency = options.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options.ordered == null ? false : options.ordered;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer();
  let resultAvailable = pDefer();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        }, (err) => {
          op.done = true;
          op.err = err;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    } catch (err) {
      sourceErr = err;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    }
  });
  function valuesAvailable() {
    if (ordered) {
      return ops[0]?.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  __name(valuesAvailable, "valuesAvailable");
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  __name(yieldOrderedValues, "yieldOrderedValues");
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i = 0; i < ops.length; i++) {
        if (ops[i].done) {
          const op = ops[i];
          ops.splice(i, 1);
          i--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  __name(yieldUnOrderedValues, "yieldUnOrderedValues");
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}
__name(parallel, "parallel");

// node_modules/@libp2p/kad-dht/dist/src/message/dht.js
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.key != null) {
          w2.uint32(10);
          w2.bytes(obj.key);
        }
        if (obj.value != null) {
          w2.uint32(18);
          w2.bytes(obj.value);
        }
        if (obj.author != null) {
          w2.uint32(26);
          w2.bytes(obj.author);
        }
        if (obj.signature != null) {
          w2.uint32(34);
          w2.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          w2.uint32(42);
          w2.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.bytes();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            case 3:
              obj.author = reader2.bytes();
              break;
            case 4:
              obj.signature = reader2.bytes();
              break;
            case 5:
              obj.timeReceived = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf3) => {
    return decodeMessage(buf3, Record3.codec());
  };
})(Record2 || (Record2 = {}));
var Message2;
(function(Message7) {
  let MessageType2;
  (function(MessageType3) {
    MessageType3["PUT_VALUE"] = "PUT_VALUE";
    MessageType3["GET_VALUE"] = "GET_VALUE";
    MessageType3["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType3["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType3["FIND_NODE"] = "FIND_NODE";
    MessageType3["PING"] = "PING";
  })(MessageType2 = Message7.MessageType || (Message7.MessageType = {}));
  let __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType3) {
    MessageType3.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(MessageType2 = Message7.MessageType || (Message7.MessageType = {}));
  let ConnectionType;
  (function(ConnectionType2) {
    ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType2["CONNECTED"] = "CONNECTED";
    ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(ConnectionType = Message7.ConnectionType || (Message7.ConnectionType = {}));
  let __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType2) {
    ConnectionType2.codec = () => {
      return enumeration(__ConnectionTypeValues);
    };
  })(ConnectionType = Message7.ConnectionType || (Message7.ConnectionType = {}));
  let Peer3;
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.id != null) {
            w2.uint32(10);
            w2.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              w2.uint32(18);
              w2.bytes(value);
            }
          }
          if (obj.connection != null) {
            w2.uint32(24);
            Message7.ConnectionType.codec().encode(obj.connection, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            addrs: []
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.addrs.push(reader2.bytes());
                break;
              case 3:
                obj.connection = Message7.ConnectionType.codec().decode(reader2);
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage(obj, Peer4.codec());
    };
    Peer4.decode = (buf3) => {
      return decodeMessage(buf3, Peer4.codec());
    };
  })(Peer3 = Message7.Peer || (Message7.Peer = {}));
  let _codec;
  Message7.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          Message7.MessageType.codec().encode(obj.type, w2);
        }
        if (obj.clusterLevelRaw != null) {
          w2.uint32(80);
          w2.int32(obj.clusterLevelRaw);
        }
        if (obj.key != null) {
          w2.uint32(18);
          w2.bytes(obj.key);
        }
        if (obj.record != null) {
          w2.uint32(26);
          w2.bytes(obj.record);
        }
        if (obj.closerPeers != null) {
          for (const value of obj.closerPeers) {
            w2.uint32(66);
            Message7.Peer.codec().encode(value, w2);
          }
        }
        if (obj.providerPeers != null) {
          for (const value of obj.providerPeers) {
            w2.uint32(74);
            Message7.Peer.codec().encode(value, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          closerPeers: [],
          providerPeers: []
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message7.MessageType.codec().decode(reader2);
              break;
            case 10:
              obj.clusterLevelRaw = reader2.int32();
              break;
            case 2:
              obj.key = reader2.bytes();
              break;
            case 3:
              obj.record = reader2.bytes();
              break;
            case 8:
              obj.closerPeers.push(Message7.Peer.codec().decode(reader2, reader2.uint32()));
              break;
            case 9:
              obj.providerPeers.push(Message7.Peer.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message7.encode = (obj) => {
    return encodeMessage(obj, Message7.codec());
  };
  Message7.decode = (buf3) => {
    return decodeMessage(buf3, Message7.codec());
  };
})(Message2 || (Message2 = {}));

// node_modules/@libp2p/kad-dht/dist/src/message/index.js
var MESSAGE_TYPE = Message2.MessageType;
var CONNECTION_TYPE = Message2.ConnectionType;
var MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);
var Message3 = class _Message {
  static {
    __name(this, "Message");
  }
  type;
  key;
  clusterLevelRaw;
  closerPeers;
  providerPeers;
  record;
  constructor(type, key, level) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("Key must be a Uint8Array");
    }
    this.type = type;
    this.key = key;
    this.clusterLevelRaw = level;
    this.closerPeers = [];
    this.providerPeers = [];
    this.record = void 0;
  }
  /**
   * @type {number}
   */
  get clusterLevel() {
    const level = this.clusterLevelRaw - 1;
    if (level < 0) {
      return 0;
    }
    return level;
  }
  set clusterLevel(level) {
    this.clusterLevelRaw = level;
  }
  /**
   * Encode into protobuf
   */
  serialize() {
    return Message2.encode({
      key: this.key,
      type: this.type,
      clusterLevelRaw: this.clusterLevelRaw,
      closerPeers: this.closerPeers.map(toPbPeer),
      providerPeers: this.providerPeers.map(toPbPeer),
      record: this.record == null ? void 0 : this.record.serialize().subarray()
    });
  }
  /**
   * Decode from protobuf
   */
  static deserialize(raw) {
    const dec = Message2.decode(raw);
    const msg = new _Message(dec.type ?? Message2.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);
    msg.closerPeers = dec.closerPeers.map(fromPbPeer);
    msg.providerPeers = dec.providerPeers.map(fromPbPeer);
    if (dec.record?.length != null) {
      msg.record = Libp2pRecord.deserialize(dec.record);
    }
    return msg;
  }
};
function toPbPeer(peer) {
  const output3 = {
    id: peer.id.toBytes(),
    addrs: (peer.multiaddrs ?? []).map((m2) => m2.bytes),
    connection: CONNECTION_TYPE.CONNECTED
  };
  return output3;
}
__name(toPbPeer, "toPbPeer");
function fromPbPeer(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  return {
    id: peerIdFromBytes(peer.id),
    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),
    protocols: []
  };
}
__name(fromPbPeer, "fromPbPeer");

// node_modules/@libp2p/kad-dht/dist/src/query/events.js
function sendQueryEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "SEND_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: MESSAGE_TYPE_LOOKUP.indexOf(fields.type.toString())
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:send-query", { detail: event }));
  return event;
}
__name(sendQueryEvent, "sendQueryEvent");
function peerResponseEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer != null ? fields.closer : [],
    providers: fields.providers != null ? fields.providers : []
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:peer-response", { detail: event }));
  return event;
}
__name(peerResponseEvent, "peerResponseEvent");
function finalPeerEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:final-peer", { detail: event }));
  return event;
}
__name(finalPeerEvent, "finalPeerEvent");
function queryErrorEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:query-error", { detail: event }));
  return event;
}
__name(queryErrorEvent, "queryErrorEvent");
function providerEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:provider", { detail: event }));
  return event;
}
__name(providerEvent, "providerEvent");
function valueEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "VALUE",
    type: 5
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:value", { detail: event }));
  return event;
}
__name(valueEvent, "valueEvent");
function dialPeerEvent(fields, options = {}) {
  const event = {
    ...fields,
    name: "DIAL_PEER",
    type: 7
  };
  options.onProgress?.(new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
  return event;
}
__name(dialPeerEvent, "dialPeerEvent");

// node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString7("/pk/");
function removePrivateAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type === 53 || type === 54 || type === 55) {
        if (addr === "localhost") {
          return false;
        }
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = private_ip_default(addr);
      if (isPrivate2 == null) {
        return true;
      }
      return !isPrivate2;
    })
  };
}
__name(removePrivateAddresses, "removePrivateAddresses");
function removePublicAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (addr === "localhost") {
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = private_ip_default(addr);
      if (isPrivate2 == null) {
        return false;
      }
      return isPrivate2;
    })
  };
}
__name(removePublicAddresses, "removePublicAddresses");
async function convertBuffer(buf3) {
  const multihash = await sha2564.digest(buf3);
  return multihash.digest;
}
__name(convertBuffer, "convertBuffer");
async function convertPeerId(peerId) {
  return convertBuffer(peerId.toBytes());
}
__name(convertPeerId, "convertPeerId");
function bufferToRecordKey(buf3) {
  return new Key(`${RECORD_KEY_PREFIX}/${toString5(buf3, "base32")}`, false);
}
__name(bufferToRecordKey, "bufferToRecordKey");
function keyForPublicKey(peer) {
  return concat3([
    PK_PREFIX,
    peer.toBytes()
  ]);
}
__name(keyForPublicKey, "keyForPublicKey");
function isPublicKeyKey(key) {
  return toString5(key.subarray(0, 4)) === "/pk/";
}
__name(isPublicKeyKey, "isPublicKeyKey");
function fromPublicKeyKey(key) {
  return peerIdFromBytes(key.subarray(4));
}
__name(fromPublicKeyKey, "fromPublicKeyKey");
function createPutRecord(key, value) {
  const timeReceived = /* @__PURE__ */ new Date();
  const rec = new Libp2pRecord(key, value, timeReceived);
  return rec.serialize();
}
__name(createPutRecord, "createPutRecord");
function debounce3(callback, wait = 100) {
  let timeout;
  return () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      callback();
    }, wait);
  };
}
__name(debounce3, "debounce");

// node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var ContentFetching = class {
  static {
    __name(this, "ContentFetching");
  }
  log;
  components;
  validators;
  selectors;
  peerRouting;
  queryManager;
  network;
  constructor(components, init) {
    const { validators: validators2, selectors: selectors2, peerRouting: peerRouting2, queryManager, network, lan } = init;
    this.components = components;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-fetching`);
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting2;
    this.queryManager = queryManager;
    this.network = network;
  }
  async putLocal(key, rec) {
    const dsKey = bufferToRecordKey(key);
    await this.components.datastore.put(dsKey, rec);
  }
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore
   */
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.datastore.get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  /**
   * Send the best record found to any peers that have an out of date record
   */
  async *sendCorrectionRecord(key, vals, best, options = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = createPutRecord(key, best);
    for (const { value, from: from46 } of vals) {
      if (equals7(value, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from46)) {
        try {
          const dsKey = bufferToRecordKey(key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray());
        } catch (err) {
          this.log.error("Failed error correcting self", err);
        }
        continue;
      }
      let sentCorrection = false;
      const request = new Message3(MESSAGE_TYPE.PUT_VALUE, key, 0);
      request.record = Libp2pRecord.deserialize(fixupRec);
      for await (const event of this.network.sendRequest(from46, request, options)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals7(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from: from46, error: new CodeError("value not put correctly", "ERR_PUT_VALUE_INVALID") }, options);
      }
      this.log.error("Failed error correcting entry");
    }
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options = {}) {
    this.log("put key %b value %b", key, value);
    const record = createPutRecord(key, value);
    const dsKey = bufferToRecordKey(key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray());
    yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => src_default9(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        const msg = new Message3(MESSAGE_TYPE.PUT_VALUE, key, 0);
        msg.record = Libp2pRecord.deserialize(record);
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {
          events2.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals7(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events2.push(queryErrorEvent({ from: event.peer.id, error: new CodeError("value not put correctly", "ERR_PUT_VALUE_INVALID") }, options));
          }
        }
        return events2;
      };
    }), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
  }
  /**
   * Get the value to the given key
   */
  async *get(key, options = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i = 0;
    try {
      i = bestRecord(this.selectors, key, records);
    } catch (err) {
      if (err.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
        throw err;
      }
    }
    const best = records[i];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw new CodeError("best value was not found", "ERR_NOT_FOUND");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options);
    yield vals[i];
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, options = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId
      }, options);
    } catch (err) {
      this.log("error getting local value for %b", key, err);
    }
    const self2 = this;
    const getValueQuery = /* @__PURE__ */ __name(async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value }, options);
        }
      }
    }, "getValueQuery");
    yield* this.queryManager.run(key, getValueQuery, options);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
var ContentRouting = class {
  static {
    __name(this, "ContentRouting");
  }
  log;
  components;
  network;
  peerRouting;
  queryManager;
  routingTable;
  providers;
  constructor(components, init) {
    const { network, peerRouting: peerRouting2, queryManager, routingTable, providers, lan } = init;
    this.components = components;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting2;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
  }
  /**
   * Announce to the network that we can provide the value for a given key and
   * are contactable on the given multiaddrs
   */
  async *provide(key, multiaddrs, options = {}) {
    this.log("provide %s", key);
    await this.providers.addProvider(key, this.components.peerId);
    const msg = new Message3(MESSAGE_TYPE.ADD_PROVIDER, key.multihash.bytes, 0);
    msg.providerPeers = [{
      id: this.components.peerId,
      multiaddrs,
      protocols: []
    }];
    let sent = 0;
    const maybeNotifyPeer = /* @__PURE__ */ __name((event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events2.push(sendEvent);
          }
        } catch (err) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err);
          events2.push(queryErrorEvent({ from: event.peer.id, error: err }, options));
        }
        return events2;
      };
    }, "maybeNotifyPeer");
    yield* pipe(this.peerRouting.getClosestPeers(key.multihash.bytes, options), (source) => src_default9(source, (event) => maybeNotifyPeer(event)), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  /**
   * Search the dht for up to `K` providers of the given CID.
   */
  async *findProviders(key, options) {
    const toFind = this.routingTable.kBucketSize;
    const target = key.multihash.bytes;
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        try {
          const peer = await this.components.peerStore.get(peerId);
          providers2.push({
            id: peerId,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
            protocols: peer.protocols
          });
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
          this.log("no peer store entry for %p", peerId);
        }
      }
      yield peerResponseEvent({ from: this.components.peerId, messageType: MESSAGE_TYPE.GET_PROVIDERS, providers: providers2 }, options);
      yield providerEvent({ from: this.components.peerId, providers: providers2 }, options);
    }
    if (provs.length >= toFind) {
      return;
    }
    const findProvidersQuery = /* @__PURE__ */ __name(async function* ({ peer, signal }) {
      const request = new Message3(MESSAGE_TYPE.GET_PROVIDERS, target, 0);
      yield* self2.network.sendRequest(peer, request, {
        ...options,
        signal
      });
    }, "findProvidersQuery");
    const providers = new Set(provs.map((p) => p.toString()));
    for await (const event of this.queryManager.run(target, findProvidersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id.toString())) {
            continue;
          }
          providers.add(peer.id.toString());
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders }, options);
        }
        if (providers.size === toFind) {
          return;
        }
      }
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/network.js
var Network2 = class extends EventEmitter6 {
  static {
    __name(this, "Network");
  }
  log;
  protocol;
  running;
  components;
  /**
   * Create a new network
   */
  constructor(components, init) {
    super();
    const { protocol, lan } = init;
    this.components = components;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:network`);
    this.running = false;
    this.protocol = protocol;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
  }
  /**
   * Is the network online?
   */
  isStarted() {
    return this.running;
  }
  /**
   * Send a request and record RTT for latency measurements
   */
  async *sendRequest(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialPeerEvent({ peer: to }, options);
    yield sendQueryEvent({ to, type: msg.type }, options);
    let stream;
    try {
      const connection = await this.components.connectionManager.openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      const response = await this._writeReadMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closerPeers,
        providers: response.providerPeers,
        record: response.record
      }, options);
    } catch (err) {
      yield queryErrorEvent({ from: to, error: err }, options);
    } finally {
      if (stream != null) {
        stream.close();
      }
    }
  }
  /**
   * Sends a message without expecting an answer
   */
  async *sendMessage(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialPeerEvent({ peer: to }, options);
    yield sendQueryEvent({ to, type: msg.type }, options);
    let stream;
    try {
      const connection = await this.components.connectionManager.openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      await this._writeMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({ from: to, messageType: msg.type }, options);
    } catch (err) {
      yield queryErrorEvent({ from: to, error: err }, options);
    } finally {
      if (stream != null) {
        stream.close();
      }
    }
  }
  /**
   * Write a message to the given stream
   */
  async _writeMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    await pipe([msg], (source) => encode16(source), stream, src_default2);
  }
  /**
   * Write a message and read its response.
   * If no response is received after the specified timeout
   * this will error out.
   */
  async _writeReadMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    const res = await pipe([msg], (source) => encode16(source), stream, (source) => decode21(source), async (source) => {
      const buf3 = await src_default12(source);
      if (buf3 != null) {
        return buf3;
      }
      throw new CodeError("No message received", "ERR_NO_MESSAGE_RECEIVED");
    });
    const message2 = Message3.deserialize(res);
    message2.closerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    message2.providerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    return message2;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js
var PeerDistanceList = class {
  static {
    __name(this, "PeerDistanceList");
  }
  /**
   * The DHT key from which distance is calculated
   */
  originDhtKey;
  /**
   * The maximum size of the list
   */
  capacity;
  peerDistances;
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  /**
   * The length of the list
   */
  get length() {
    return this.peerDistances.length;
  }
  /**
   * The peerIds in the list, in order of distance from the origin key
   */
  get peers() {
    return this.peerDistances.map((pd) => pd.peerId);
  }
  /**
   * Add a peerId to the list.
   */
  async add(peerId) {
    if (this.peerDistances.find((pd) => pd.peerId.equals(peerId)) != null) {
      return;
    }
    const dhtKey = await convertPeerId(peerId);
    const el = {
      peerId,
      distance: xor(this.originDhtKey, dhtKey)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b) => compare2(a.distance, b.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    if (this.length === 0) {
      return true;
    }
    const dhtKeys = await Promise.all(peerIds.map(convertPeerId));
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    for (const dhtKey of dhtKeys) {
      const keyDistance = xor(this.originDhtKey, dhtKey);
      if (compare2(keyDistance, furthestDistance) < 0) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  static {
    __name(this, "PeerRouting");
  }
  components;
  log;
  routingTable;
  network;
  validators;
  queryManager;
  constructor(components, init) {
    const { routingTable, network, validators: validators2, queryManager, lan } = init;
    this.components = components;
    this.routingTable = routingTable;
    this.network = network;
    this.validators = validators2;
    this.queryManager = queryManager;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:peer-routing`);
  }
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   */
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.peerStore.get(p);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.peerStore.get(peer);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr),
        protocols: []
      };
    }
    return void 0;
  }
  /**
   * Get a value via rpc call for the given parameters
   */
  async *_getValueSingle(peer, key, options = {}) {
    const msg = new Message3(MESSAGE_TYPE.GET_VALUE, key, 0);
    yield* this.network.sendRequest(peer, msg, options);
  }
  /**
   * Get the public key directly from a node
   */
  async *getPublicKeyFromNode(peer, options = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const recPeer = await peerIdFromKeys(keys_exports2.marshalPublicKey({ bytes: event.record.value }));
        if (!recPeer.equals(peer)) {
          throw new CodeError("public key does not match id", "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        if (recPeer.publicKey == null) {
          throw new CodeError("public key missing", "ERR_PUBLIC_KEY_MISSING");
        }
        yield valueEvent({ from: peer, value: recPeer.publicKey }, options);
      }
    }
    throw new CodeError(`Node not responding with its public key: ${peer.toString()}`, "ERR_INVALID_RECORD");
  }
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options = {}) {
    this.log("findPeer %p", id);
    const pi = await this.findPeerLocal(id);
    if (pi != null) {
      this.log("found local");
      yield finalPeerEvent({
        from: this.components.peerId,
        peer: pi
      }, options);
      return;
    }
    const self2 = this;
    const findPeerQuery = /* @__PURE__ */ __name(async function* ({ peer, signal }) {
      const request = new Message3(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0);
      for await (const event of self2.network.sendRequest(peer, request, {
        ...options,
        signal
      })) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          const match = event.closer.find((p) => p.id.equals(id));
          if (match != null) {
            yield finalPeerEvent({ from: event.from, peer: match }, options);
          }
        }
      }
    }, "findPeerQuery");
    let foundPeer = false;
    for await (const event of this.queryManager.run(id.toBytes(), findPeerQuery, options)) {
      if (event.name === "FINAL_PEER") {
        foundPeer = true;
      }
      yield event;
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.components.peerId, error: new CodeError("Not found", "ERR_NOT_FOUND") }, options);
    }
  }
  /**
   * Kademlia 'node lookup' operation on a key, which could be a the
   * bytes from a multihash or a peer ID
   */
  async *getClosestPeers(key, options = {}) {
    this.log("getClosestPeers to %b", key);
    const id = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(id);
    const self2 = this;
    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => {
      await peers.add(peer);
    }));
    const getCloserPeersQuery = /* @__PURE__ */ __name(async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString5(key, "base32"), peer);
      const request = new Message3(MESSAGE_TYPE.FIND_NODE, key, 0);
      yield* self2.network.sendRequest(peer, request, {
        ...options,
        signal
      });
    }, "getCloserPeersQuery");
    for await (const event of this.queryManager.run(key, getCloserPeersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => {
          await peers.add(peerData.id);
        }));
      }
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peerId of peers.peers) {
      try {
        const peer = await this.components.peerStore.get(peerId);
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: {
            id: peerId,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
            protocols: peer.protocols
          }
        }, options);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
  }
  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerStore is updated with new addresses found for the given peer.
   */
  async *getValueOrPeers(peer, key, options = {}) {
    for await (const event of this._getValueSingle(peer, key, options)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: new CodeError(errMsg, "ERR_INVALID_RECORD") }, options);
            continue;
          }
        }
      }
      yield event;
    }
  }
  /**
   * Verify a record, fetching missing public keys from the network.
   * Throws an error if the record is invalid.
   */
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw new CodeError("invalid record received", "ERR_INVALID_RECORD");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  /**
   * Get the nearest peers to the given query, but if closer
   * than self
   */
  async getCloserPeersOffline(key, closerThan) {
    const id = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(id);
    const output3 = [];
    for (const peerId of ids) {
      if (peerId.equals(closerThan)) {
        continue;
      }
      try {
        const peer = await this.components.peerStore.get(peerId);
        output3.push({
          id: peerId,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        });
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    if (output3.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output3.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p", key, closerThan);
    }
    return output3;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/providers.js
var import_hashlru2 = __toESM(require_hashlru(), 1);

// node_modules/@libp2p/kad-dht/node_modules/eventemitter3/index.mjs
var import_index15 = __toESM(require_eventemitter35(), 1);

// node_modules/@libp2p/kad-dht/node_modules/p-timeout/index.js
var TimeoutError5 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError11 = class extends Error {
  static {
    __name(this, "AbortError");
  }
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException5 = /* @__PURE__ */ __name((errorMessage) => globalThis.DOMException === void 0 ? new AbortError11(errorMessage) : new DOMException(errorMessage), "getDOMException");
var getAbortedReason5 = /* @__PURE__ */ __name((signal) => {
  const reason = signal.reason === void 0 ? getDOMException5("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException5(reason);
}, "getAbortedReason");
function pTimeout5(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason5(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason5(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError5(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
__name(pTimeout5, "pTimeout");

// node_modules/@libp2p/kad-dht/node_modules/p-queue/dist/lower-bound.js
function lowerBound6(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
__name(lowerBound6, "lowerBound");

// node_modules/@libp2p/kad-dht/node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet7 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue4;
var PriorityQueue5 = class {
  static {
    __name(this, "PriorityQueue");
  }
  constructor() {
    _PriorityQueue_queue4.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet7(this, _PriorityQueue_queue4, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet7(this, _PriorityQueue_queue4, "f").push(element);
      return;
    }
    const index = lowerBound6(__classPrivateFieldGet7(this, _PriorityQueue_queue4, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet7(this, _PriorityQueue_queue4, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet7(this, _PriorityQueue_queue4, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet7(this, _PriorityQueue_queue4, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet7(this, _PriorityQueue_queue4, "f").length;
  }
};
_PriorityQueue_queue4 = /* @__PURE__ */ new WeakMap();
var priority_queue_default4 = PriorityQueue5;

// node_modules/@libp2p/kad-dht/node_modules/p-queue/dist/index.js
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet8 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances4;
var _PQueue_carryoverConcurrencyCount4;
var _PQueue_isIntervalIgnored4;
var _PQueue_intervalCount4;
var _PQueue_intervalCap4;
var _PQueue_interval4;
var _PQueue_intervalEnd4;
var _PQueue_intervalId4;
var _PQueue_timeoutId4;
var _PQueue_queue4;
var _PQueue_queueClass4;
var _PQueue_pending4;
var _PQueue_concurrency4;
var _PQueue_isPaused4;
var _PQueue_throwOnTimeout4;
var _PQueue_doesIntervalAllowAnother_get7;
var _PQueue_doesConcurrentAllowAnother_get7;
var _PQueue_next7;
var _PQueue_onResumeInterval7;
var _PQueue_isIntervalPaused_get7;
var _PQueue_tryToStartAnother7;
var _PQueue_initializeIntervalIfNeeded7;
var _PQueue_onInterval7;
var _PQueue_processQueue7;
var _PQueue_throwOnAbort7;
var _PQueue_onEvent7;
var AbortError12 = class extends Error {
  static {
    __name(this, "AbortError");
  }
};
var PQueue5 = class extends import_index15.default {
  static {
    __name(this, "PQueue");
  }
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    _PQueue_instances4.add(this);
    _PQueue_carryoverConcurrencyCount4.set(this, void 0);
    _PQueue_isIntervalIgnored4.set(this, void 0);
    _PQueue_intervalCount4.set(this, 0);
    _PQueue_intervalCap4.set(this, void 0);
    _PQueue_interval4.set(this, void 0);
    _PQueue_intervalEnd4.set(this, 0);
    _PQueue_intervalId4.set(this, void 0);
    _PQueue_timeoutId4.set(this, void 0);
    _PQueue_queue4.set(this, void 0);
    _PQueue_queueClass4.set(this, void 0);
    _PQueue_pending4.set(this, 0);
    _PQueue_concurrency4.set(this, void 0);
    _PQueue_isPaused4.set(this, void 0);
    _PQueue_throwOnTimeout4.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: priority_queue_default4,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet4(this, _PQueue_carryoverConcurrencyCount4, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet4(this, _PQueue_isIntervalIgnored4, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet4(this, _PQueue_intervalCap4, options.intervalCap, "f");
    __classPrivateFieldSet4(this, _PQueue_interval4, options.interval, "f");
    __classPrivateFieldSet4(this, _PQueue_queue4, new options.queueClass(), "f");
    __classPrivateFieldSet4(this, _PQueue_queueClass4, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet4(this, _PQueue_throwOnTimeout4, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet4(this, _PQueue_isPaused4, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet8(this, _PQueue_concurrency4, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet4(this, _PQueue_concurrency4, newConcurrency, "f");
    __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_processQueue7).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet8(this, _PQueue_throwOnTimeout4, "f"),
      ...options
    };
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet8(this, _PQueue_queue4, "f").enqueue(async () => {
        var _a;
        var _b, _c;
        __classPrivateFieldSet4(this, _PQueue_pending4, (_b = __classPrivateFieldGet8(this, _PQueue_pending4, "f"), _b++, _b), "f");
        __classPrivateFieldSet4(this, _PQueue_intervalCount4, (_c = __classPrivateFieldGet8(this, _PQueue_intervalCount4, "f"), _c++, _c), "f");
        try {
          if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
            throw new AbortError12("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout5(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_throwOnAbort7).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError5 && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_next7).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_tryToStartAnother7).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet8(this, _PQueue_isPaused4, "f")) {
      return this;
    }
    __classPrivateFieldSet4(this, _PQueue_isPaused4, false, "f");
    __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_processQueue7).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet4(this, _PQueue_isPaused4, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet4(this, _PQueue_queue4, new (__classPrivateFieldGet8(this, _PQueue_queueClass4, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet8(this, _PQueue_queue4, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_onEvent7).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet8(this, _PQueue_queue4, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_onEvent7).call(this, "next", () => __classPrivateFieldGet8(this, _PQueue_queue4, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet8(this, _PQueue_pending4, "f") === 0 && __classPrivateFieldGet8(this, _PQueue_queue4, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_onEvent7).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet8(this, _PQueue_queue4, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet8(this, _PQueue_queue4, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet8(this, _PQueue_pending4, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet8(this, _PQueue_isPaused4, "f");
  }
};
_PQueue_carryoverConcurrencyCount4 = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored4 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount4 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap4 = /* @__PURE__ */ new WeakMap(), _PQueue_interval4 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd4 = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId4 = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId4 = /* @__PURE__ */ new WeakMap(), _PQueue_queue4 = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass4 = /* @__PURE__ */ new WeakMap(), _PQueue_pending4 = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency4 = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused4 = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout4 = /* @__PURE__ */ new WeakMap(), _PQueue_instances4 = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get7 = /* @__PURE__ */ __name(function _PQueue_doesIntervalAllowAnother_get8() {
  return __classPrivateFieldGet8(this, _PQueue_isIntervalIgnored4, "f") || __classPrivateFieldGet8(this, _PQueue_intervalCount4, "f") < __classPrivateFieldGet8(this, _PQueue_intervalCap4, "f");
}, "_PQueue_doesIntervalAllowAnother_get"), _PQueue_doesConcurrentAllowAnother_get7 = /* @__PURE__ */ __name(function _PQueue_doesConcurrentAllowAnother_get8() {
  return __classPrivateFieldGet8(this, _PQueue_pending4, "f") < __classPrivateFieldGet8(this, _PQueue_concurrency4, "f");
}, "_PQueue_doesConcurrentAllowAnother_get"), _PQueue_next7 = /* @__PURE__ */ __name(function _PQueue_next8() {
  var _a;
  __classPrivateFieldSet4(this, _PQueue_pending4, (_a = __classPrivateFieldGet8(this, _PQueue_pending4, "f"), _a--, _a), "f");
  __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_tryToStartAnother7).call(this);
  this.emit("next");
}, "_PQueue_next"), _PQueue_onResumeInterval7 = /* @__PURE__ */ __name(function _PQueue_onResumeInterval8() {
  __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_onInterval7).call(this);
  __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_initializeIntervalIfNeeded7).call(this);
  __classPrivateFieldSet4(this, _PQueue_timeoutId4, void 0, "f");
}, "_PQueue_onResumeInterval"), _PQueue_isIntervalPaused_get7 = /* @__PURE__ */ __name(function _PQueue_isIntervalPaused_get8() {
  const now = Date.now();
  if (__classPrivateFieldGet8(this, _PQueue_intervalId4, "f") === void 0) {
    const delay = __classPrivateFieldGet8(this, _PQueue_intervalEnd4, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet4(this, _PQueue_intervalCount4, __classPrivateFieldGet8(this, _PQueue_carryoverConcurrencyCount4, "f") ? __classPrivateFieldGet8(this, _PQueue_pending4, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet8(this, _PQueue_timeoutId4, "f") === void 0) {
        __classPrivateFieldSet4(this, _PQueue_timeoutId4, setTimeout(() => {
          __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_onResumeInterval7).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, "_PQueue_isIntervalPaused_get"), _PQueue_tryToStartAnother7 = /* @__PURE__ */ __name(function _PQueue_tryToStartAnother8() {
  if (__classPrivateFieldGet8(this, _PQueue_queue4, "f").size === 0) {
    if (__classPrivateFieldGet8(this, _PQueue_intervalId4, "f")) {
      clearInterval(__classPrivateFieldGet8(this, _PQueue_intervalId4, "f"));
    }
    __classPrivateFieldSet4(this, _PQueue_intervalId4, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet8(this, _PQueue_pending4, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet8(this, _PQueue_isPaused4, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet8(this, _PQueue_instances4, "a", _PQueue_isIntervalPaused_get7);
    if (__classPrivateFieldGet8(this, _PQueue_instances4, "a", _PQueue_doesIntervalAllowAnother_get7) && __classPrivateFieldGet8(this, _PQueue_instances4, "a", _PQueue_doesConcurrentAllowAnother_get7)) {
      const job = __classPrivateFieldGet8(this, _PQueue_queue4, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_initializeIntervalIfNeeded7).call(this);
      }
      return true;
    }
  }
  return false;
}, "_PQueue_tryToStartAnother"), _PQueue_initializeIntervalIfNeeded7 = /* @__PURE__ */ __name(function _PQueue_initializeIntervalIfNeeded8() {
  if (__classPrivateFieldGet8(this, _PQueue_isIntervalIgnored4, "f") || __classPrivateFieldGet8(this, _PQueue_intervalId4, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet4(this, _PQueue_intervalId4, setInterval(() => {
    __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_onInterval7).call(this);
  }, __classPrivateFieldGet8(this, _PQueue_interval4, "f")), "f");
  __classPrivateFieldSet4(this, _PQueue_intervalEnd4, Date.now() + __classPrivateFieldGet8(this, _PQueue_interval4, "f"), "f");
}, "_PQueue_initializeIntervalIfNeeded"), _PQueue_onInterval7 = /* @__PURE__ */ __name(function _PQueue_onInterval8() {
  if (__classPrivateFieldGet8(this, _PQueue_intervalCount4, "f") === 0 && __classPrivateFieldGet8(this, _PQueue_pending4, "f") === 0 && __classPrivateFieldGet8(this, _PQueue_intervalId4, "f")) {
    clearInterval(__classPrivateFieldGet8(this, _PQueue_intervalId4, "f"));
    __classPrivateFieldSet4(this, _PQueue_intervalId4, void 0, "f");
  }
  __classPrivateFieldSet4(this, _PQueue_intervalCount4, __classPrivateFieldGet8(this, _PQueue_carryoverConcurrencyCount4, "f") ? __classPrivateFieldGet8(this, _PQueue_pending4, "f") : 0, "f");
  __classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_processQueue7).call(this);
}, "_PQueue_onInterval"), _PQueue_processQueue7 = /* @__PURE__ */ __name(function _PQueue_processQueue8() {
  while (__classPrivateFieldGet8(this, _PQueue_instances4, "m", _PQueue_tryToStartAnother7).call(this)) {
  }
}, "_PQueue_processQueue"), _PQueue_throwOnAbort7 = /* @__PURE__ */ __name(async function _PQueue_throwOnAbort8(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError12("The task was aborted."));
    }, { once: true });
  });
}, "_PQueue_throwOnAbort"), _PQueue_onEvent7 = /* @__PURE__ */ __name(async function _PQueue_onEvent8(event, filter2) {
  return new Promise((resolve) => {
    const listener = /* @__PURE__ */ __name(() => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    }, "listener");
    this.on(event, listener);
  });
}, "_PQueue_onEvent");
var dist_default5 = PQueue5;

// node_modules/@libp2p/kad-dht/dist/src/providers.js
var import_varint14 = __toESM(require_varint2(), 1);
var log27 = logger14("libp2p:kad-dht:providers");
var Providers = class {
  static {
    __name(this, "Providers");
  }
  components;
  cache;
  cleanupInterval;
  provideValidity;
  syncQueue;
  started;
  cleaner;
  constructor(components, init = {}) {
    const { cacheSize, cleanupInterval, provideValidity } = init;
    this.components = components;
    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
    this.cache = (0, import_hashlru2.default)(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
    this.syncQueue = new dist_default5({ concurrency: 1 });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start the provider cleanup service
   */
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.cleaner = setInterval(() => {
      this._cleanup().catch((err) => {
        log27.error(err);
      });
    }, this.cleanupInterval);
  }
  /**
   * Release any resources.
   */
  async stop() {
    this.started = false;
    if (this.cleaner != null) {
      clearInterval(this.cleaner);
      this.cleaner = void 0;
    }
  }
  /**
   * Check all providers if they are still valid, and if not delete them
   */
  async _cleanup() {
    await this.syncQueue.add(async () => {
      const start = Date.now();
      let count = 0;
      let deleteCount = 0;
      const deleted = /* @__PURE__ */ new Map();
      const batch = this.components.datastore.batch();
      const query = this.components.datastore.query({ prefix: PROVIDER_KEY_PREFIX });
      for await (const entry of query) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const time = readTime(entry.value).getTime();
          const now = Date.now();
          const delta = now - time;
          const expired = delta > this.provideValidity;
          log27("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
          if (expired) {
            deleteCount++;
            batch.delete(entry.key);
            const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
            peers.add(peerId);
            deleted.set(cid, peers);
          }
          count++;
        } catch (err) {
          log27.error(err.message);
        }
      }
      if (deleted.size > 0) {
        log27("deleting %d / %d entries", deleteCount, count);
        await batch.commit();
      } else {
        log27("nothing to delete");
      }
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid);
        const provs = this.cache.get(key);
        if (provs != null) {
          for (const peerId of peers) {
            provs.delete(peerId);
          }
          if (provs.size === 0) {
            this.cache.remove(key);
          } else {
            this.cache.set(key, provs);
          }
        }
      }
      log27("Cleanup successful (%dms)", Date.now() - start);
    });
  }
  /**
   * Get the currently known provider peer ids for a given CID
   */
  async _getProvidersMap(cid) {
    const cacheKey = makeProviderKey(cid);
    let provs = this.cache.get(cacheKey);
    if (provs == null) {
      provs = await loadProviders(this.components.datastore, cid);
      this.cache.set(cacheKey, provs);
    }
    return provs;
  }
  /**
   * Add a new provider for the given CID
   */
  async addProvider(cid, provider) {
    await this.syncQueue.add(async () => {
      log27("%p provides %s", provider, cid);
      const provs = await this._getProvidersMap(cid);
      log27("loaded %s provs", provs.size);
      const now = /* @__PURE__ */ new Date();
      provs.set(provider.toString(), now);
      const dsKey = makeProviderKey(cid);
      this.cache.set(dsKey, provs);
      await writeProviderEntry(this.components.datastore, cid, provider, now);
    });
  }
  /**
   * Get a list of providers for the given CID
   */
  async getProviders(cid) {
    return this.syncQueue.add(async () => {
      log27("get providers for %s", cid);
      const provs = await this._getProvidersMap(cid);
      return [...provs.keys()].map((peerIdStr) => {
        return peerIdFromString(peerIdStr);
      });
    }, {
      // no timeout is specified for this queue so it will not
      // throw, but this is required to get the right return
      // type since p-queue@7.3.4
      throwOnTimeout: true
    });
  }
};
function makeProviderKey(cid) {
  const cidStr = typeof cid === "string" ? cid : toString5(cid.multihash.bytes, "base32");
  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
}
__name(makeProviderKey, "makeProviderKey");
async function writeProviderEntry(store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    "/",
    peer.toString()
  ].join("");
  const key = new Key(dsKey);
  const buffer3 = Uint8Array.from(import_varint14.default.encode(time.getTime()));
  await store.put(key, buffer3);
}
__name(writeProviderEntry, "writeProviderEntry");
function parseProviderKey(key) {
  const parts = key.toString().split("/");
  if (parts.length !== 5) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: parts[3],
    peerId: parts[4]
  };
}
__name(parseProviderKey, "parseProviderKey");
async function loadProviders(store, cid) {
  const providers = /* @__PURE__ */ new Map();
  const query = store.query({ prefix: makeProviderKey(cid) });
  for await (const entry of query) {
    const { peerId } = parseProviderKey(entry.key);
    providers.set(peerId, readTime(entry.value));
  }
  return providers;
}
__name(loadProviders, "loadProviders");
function readTime(buf3) {
  return new Date(import_varint14.default.decode(buf3));
}
__name(readTime, "readTime");

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var import_events18 = __toESM(require_events(), 1);

// node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
var MAX_XOR = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
async function* queryPath(options) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log: log59, peersSeen } = options;
  const queue = new dist_default5({
    concurrency: alpha
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = BigInt("0x" + toString5(xor(peerKadId, kadId), "base16"));
    queue.add(async () => {
      const signals = [signal];
      if (queryFuncTimeout != null) {
        signals.push(AbortSignal.timeout(queryFuncTimeout));
      }
      const compoundSignal = anySignal(signals);
      try {
        for await (const event of query({
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log59("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log59("not querying ourselves");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = BigInt("0x" + toString5(xor(closerPeerKadId, kadId), "base16"));
              if (closerPeerXor > peerXor) {
                log59("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log59("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.emit("completed", event);
        }
      } catch (err) {
        if (!signal.aborted) {
          return queryErrorEvent({
            from: peer,
            error: err
          }, options);
        }
      } finally {
        compoundSignal.clear();
      }
    }, {
      // use xor value as the queue priority - closer peers should execute first
      // subtract it from MAX_XOR because higher priority values execute sooner
      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts
      // as long as all priorities are BigInts since we won't mix BigInts and Number
      // values in arithmetic operations
      priority: MAX_XOR - peerXor
    }).catch((err) => {
      log59.error(err);
    });
  }
  __name(queryPeer, "queryPeer");
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  yield* toGenerator(queue, signal, cleanUp, log59);
}
__name(queryPath, "queryPath");
async function* toGenerator(queue, signal, cleanUp, log59) {
  let deferred = pDefer();
  let running = true;
  const results = [];
  const cleanup = /* @__PURE__ */ __name(() => {
    if (!running) {
      return;
    }
    log59("clean up queue, results %d, queue size %d, pending tasks %d", results.length, queue.size, queue.pending);
    running = false;
    queue.clear();
    results.splice(0, results.length);
  }, "cleanup");
  queue.on("completed", (result) => {
    results.push(result);
    deferred.resolve();
  });
  queue.on("error", (err) => {
    log59("queue error", err);
    cleanup();
    deferred.reject(err);
  });
  queue.on("idle", () => {
    log59("queue idle");
    running = false;
    deferred.resolve();
  });
  signal.addEventListener("abort", () => {
    log59("abort queue");
    const wasRunning = running;
    cleanup();
    if (wasRunning) {
      deferred.reject(new CodeError("Query aborted", "ERR_QUERY_ABORTED"));
    }
  });
  cleanUp.addEventListener("cleanup", () => {
    cleanup();
    deferred.resolve();
  });
  while (running) {
    await deferred.promise;
    deferred = pDefer();
    while (results.length > 0) {
      const result = results.shift();
      if (result != null) {
        yield result;
      }
    }
  }
  yield* results;
}
__name(toGenerator, "toGenerator");

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var QueryManager = class {
  static {
    __name(this, "QueryManager");
  }
  components;
  lan;
  disjointPaths;
  alpha;
  shutDownController;
  running;
  queries;
  metrics;
  routingTable;
  initialQuerySelfHasRun;
  constructor(components, init) {
    const { lan = false, disjointPaths = K, alpha = ALPHA } = init;
    this.components = components;
    this.disjointPaths = disjointPaths ?? K;
    this.running = false;
    this.alpha = alpha ?? ALPHA;
    this.lan = lan;
    this.queries = 0;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.routingTable = init.routingTable;
    this.shutDownController = new AbortController();
    try {
      if (import_events18.setMaxListeners != null) {
        (0, import_events18.setMaxListeners)(Infinity, this.shutDownController.signal);
      }
    } catch {
    }
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the query manager
   */
  async start() {
    this.running = true;
    if (this.components.metrics != null && this.metrics == null) {
      this.metrics = {
        runningQueries: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_running_queries`),
        queryTime: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_query_time_seconds`)
      };
    }
  }
  /**
   * Stops all queries
   */
  async stop() {
    this.running = false;
    this.shutDownController.abort();
  }
  async *run(key, queryFunc, options = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    const stopQueryTimer = this.metrics?.queryTime.timer();
    if (options.signal == null) {
      options.signal = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
      try {
        if (import_events18.setMaxListeners != null) {
          (0, import_events18.setMaxListeners)(Infinity, options.signal);
        }
      } catch {
      }
    }
    const signal = anySignal([this.shutDownController.signal, options.signal]);
    try {
      if (import_events18.setMaxListeners != null) {
        (0, import_events18.setMaxListeners)(Infinity, signal);
      }
    } catch {
    }
    const log59 = logger14(`libp2p:kad-dht:${this.lan ? "lan" : "wan"}:query:` + toString5(key, "base58btc"));
    const startTime = Date.now();
    const cleanUp = new EventEmitter6();
    try {
      if (options.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
        log59("waiting for initial query-self query before continuing");
        await Promise.race([
          new Promise((resolve, reject) => {
            signal.addEventListener("abort", () => {
              reject(new AbortError2("Query was aborted before self-query ran"));
            });
          }),
          this.initialQuerySelfHasRun.promise
        ]);
        this.initialQuerySelfHasRun = void 0;
      }
      log59("query:start");
      this.queries++;
      this.metrics?.runningQueries.update(this.queries);
      const id = await convertBuffer(key);
      const peers = this.routingTable.closestPeers(id);
      const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
      if (peers.length === 0) {
        log59.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          key,
          startingPeer: peer,
          ourPeerId: this.components.peerId,
          signal,
          query: queryFunc,
          pathIndex: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          cleanUp,
          queryFuncTimeout: options.queryFuncTimeout,
          log: log59,
          peersSeen,
          onProgress: options.onProgress
        });
      });
      for await (const event of src_default5(...paths)) {
        yield event;
        if (event.name === "QUERY_ERROR") {
          log59("error", event.error);
        }
      }
    } catch (err) {
      if (!this.running && err.code === "ERR_QUERY_ABORTED") {
      } else {
        throw err;
      }
    } finally {
      signal.clear();
      this.queries--;
      this.metrics?.runningQueries.update(this.queries);
      if (stopQueryTimer != null) {
        stopQueryTimer();
      }
      cleanUp.dispatchEvent(new CustomEvent("cleanup"));
      log59("query:done in %dms", Date.now() - startTime);
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/query-self.js
var import_events20 = __toESM(require_events(), 1);

// node_modules/it-length/dist/src/index.js
function isAsyncIterable12(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable12, "isAsyncIterable");
function length15(source) {
  if (isAsyncIterable12(source)) {
    return (async () => {
      let count = 0;
      for await (const _ of source) {
        count++;
      }
      return count;
    })();
  } else {
    let count = 0;
    for (const _ of source) {
      count++;
    }
    return count;
  }
}
__name(length15, "length");
var src_default13 = length15;

// node_modules/p-event/index.js
var normalizeEmitter = /* @__PURE__ */ __name((emitter) => {
  const addListener = emitter.addEventListener || emitter.on || emitter.addListener;
  const removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
}, "normalizeEmitter");
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    options.signal?.throwIfAborted();
    const events2 = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = /* @__PURE__ */ __name((...arguments_) => {
      const value = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter && !options.filter(value)) {
        return;
      }
      items.push(value);
      if (options.count === items.length) {
        cancel();
        resolve(items);
      }
    }, "onItem");
    const rejectHandler = /* @__PURE__ */ __name((error) => {
      cancel();
      reject(error);
    }, "rejectHandler");
    cancel = /* @__PURE__ */ __name(() => {
      for (const event2 of events2) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    }, "cancel");
    for (const event2 of events2) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        rejectHandler(options.signal.reason);
      }, { once: true });
    }
    if (options.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout = pTimeout2(returnValue, { milliseconds: options.timeout });
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
__name(pEventMultiple, "pEventMultiple");
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}
__name(pEvent, "pEvent");

// node_modules/@libp2p/kad-dht/dist/src/query-self.js
var QuerySelf = class {
  static {
    __name(this, "QuerySelf");
  }
  log;
  components;
  peerRouting;
  routingTable;
  count;
  interval;
  initialInterval;
  queryTimeout;
  started;
  timeoutId;
  controller;
  initialQuerySelfHasRun;
  querySelfPromise;
  constructor(components, init) {
    const { peerRouting: peerRouting2, lan, count, interval, queryTimeout, routingTable } = init;
    this.components = components;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:query-self`);
    this.started = false;
    this.peerRouting = peerRouting2;
    this.routingTable = routingTable;
    this.count = count ?? K;
    this.interval = interval ?? QUERY_SELF_INTERVAL;
    this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
    this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
  }
  isStarted() {
    return this.started;
  }
  start() {
    if (this.started) {
      return;
    }
    this.started = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.initialInterval);
  }
  stop() {
    this.started = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  async querySelf() {
    if (!this.started) {
      this.log("skip self-query because we are not started");
      return;
    }
    if (this.querySelfPromise != null) {
      this.log("joining existing self query");
      return this.querySelfPromise.promise;
    }
    this.querySelfPromise = pDefer();
    if (this.routingTable.size === 0) {
      await pEvent(this.routingTable, "peer:add");
    }
    if (this.started) {
      this.controller = new AbortController();
      const signal = anySignal([this.controller.signal, AbortSignal.timeout(this.queryTimeout)]);
      try {
        if (import_events20.setMaxListeners != null) {
          (0, import_events20.setMaxListeners)(Infinity, signal);
        }
      } catch {
      }
      try {
        this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
        const found = await pipe(this.peerRouting.getClosestPeers(this.components.peerId.toBytes(), {
          signal,
          isSelfQuery: true
        }), (source) => src_default8(source, this.count), async (source) => src_default13(source));
        this.log("self-query ran successfully - found %d peers", found);
        if (this.initialQuerySelfHasRun != null) {
          this.initialQuerySelfHasRun.resolve();
          this.initialQuerySelfHasRun = void 0;
        }
      } catch (err) {
        this.log.error("self-query error", err);
      } finally {
        signal.clear();
      }
    }
    this.querySelfPromise.resolve();
    this.querySelfPromise = void 0;
    if (!this.started) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.interval);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
function arrayEquals2(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0, length21 = array1.length; i < length21; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
__name(arrayEquals2, "arrayEquals");
function createNode2() {
  return { contacts: [], dontSplit: false, left: null, right: null };
}
__name(createNode2, "createNode");
function ensureInt8(name14, val) {
  if (!(val instanceof Uint8Array)) {
    throw new TypeError(name14 + " is not a Uint8Array");
  }
}
__name(ensureInt8, "ensureInt8");
var KBucket = class _KBucket extends EventEmitter6 {
  static {
    __name(this, "KBucket");
  }
  localNodeId;
  root;
  numberOfNodesPerKBucket;
  numberOfNodesToPing;
  distance;
  arbiter;
  constructor(options) {
    super();
    this.localNodeId = options.localNodeId;
    this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket ?? 20;
    this.numberOfNodesToPing = options.numberOfNodesToPing ?? 3;
    this.distance = options.distance ?? _KBucket.distance;
    this.arbiter = options.arbiter ?? _KBucket.arbiter;
    ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
    this.root = createNode2();
  }
  /**
   * Default arbiter function for contacts with the same id. Uses
   * contact.vectorClock to select which contact to update the k-bucket with.
   * Contact with larger vectorClock field will be selected. If vectorClock is
   * the same, candidate will be selected.
   *
   * @param {object} incumbent - Contact currently stored in the k-bucket.
   * @param {object} candidate - Contact being added to the k-bucket.
   * @returns {object} Contact to updated the k-bucket with.
   */
  static arbiter(incumbent, candidate) {
    return (incumbent.vectorClock ?? 0) > (candidate.vectorClock ?? 0) ? incumbent : candidate;
  }
  /**
   * Default distance function. Finds the XOR
   * distance between firstId and secondId.
   *
   * @param  {Uint8Array} firstId -  Uint8Array containing first id.
   * @param  {Uint8Array} secondId -  Uint8Array containing second id.
   * @returns {number} Integer The XOR distance between firstId and secondId.
   */
  static distance(firstId, secondId) {
    let distance = 0;
    let i = 0;
    const min = Math.min(firstId.length, secondId.length);
    const max = Math.max(firstId.length, secondId.length);
    for (; i < min; ++i) {
      distance = distance * 256 + (firstId[i] ^ secondId[i]);
    }
    for (; i < max; ++i)
      distance = distance * 256 + 255;
    return distance;
  }
  /**
   * Adds a contact to the k-bucket.
   *
   * @param {object} contact - the contact object to add
   */
  add(contact) {
    ensureInt8("contact.id", contact?.id);
    let bitIndex = 0;
    let node = this.root;
    while (node.contacts === null) {
      node = this._determineNode(node, contact.id, bitIndex++);
    }
    const index = this._indexOf(node, contact.id);
    if (index >= 0) {
      this._update(node, index, contact);
      return this;
    }
    if (node.contacts.length < this.numberOfNodesPerKBucket) {
      node.contacts.push(contact);
      this.safeDispatchEvent("added", { detail: contact });
      return this;
    }
    if (node.dontSplit) {
      this.safeDispatchEvent("ping", {
        detail: {
          oldContacts: node.contacts.slice(0, this.numberOfNodesToPing),
          newContact: contact
        }
      });
      return this;
    }
    this._split(node, bitIndex);
    return this.add(contact);
  }
  /**
   * Get the n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param {Uint8Array} id - Contact node id
   * @param {number} n - Integer (Default: Infinity) The maximum number of closest contacts to return
   * @returns {Array} Array Maximum of n closest contacts to the node id
   */
  closest(id, n = Infinity) {
    ensureInt8("id", id);
    if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
      throw new TypeError("n is not positive number");
    }
    let contacts = [];
    for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
      const node = nodes.pop();
      if (node == null) {
        continue;
      }
      if (node.contacts === null) {
        const detNode = this._determineNode(node, id, bitIndex++);
        nodes.push(node.left === detNode ? node.right : node.left);
        nodes.push(detNode);
      } else {
        contacts = contacts.concat(node.contacts);
      }
    }
    return contacts.map((a) => ({
      distance: this.distance(a.id, id),
      contact: a
    })).sort((a, b) => a.distance - b.distance).slice(0, n).map((a) => a.contact);
  }
  /**
   * Counts the total number of contacts in the tree.
   *
   * @returns {number} The number of contacts held in the tree
   */
  count() {
    let count = 0;
    for (const nodes = [this.root]; nodes.length > 0; ) {
      const node = nodes.pop();
      if (node == null) {
        continue;
      }
      if (node.contacts === null) {
        nodes.push(node.right, node.left);
      } else {
        count += node.contacts.length;
      }
    }
    return count;
  }
  /**
   * Determines whether the id at the bitIndex is 0 or 1.
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param {object} node - internal object that has 2 leafs: left and right
   * @param {Uint8Array} id - Id to compare localNodeId with.
   * @param {number} bitIndex - Integer (Default: 0) The bit index to which bit to check in the id Uint8Array.
   * @returns {object} left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineNode(node, id, bitIndex) {
    const bytesDescribedByBitIndex = bitIndex >> 3;
    const bitIndexWithinByte = bitIndex % 8;
    if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
      return node.left;
    }
    const byteUnderConsideration = id[bytesDescribedByBitIndex];
    if ((byteUnderConsideration & 1 << 7 - bitIndexWithinByte) !== 0) {
      return node.right;
    }
    return node.left;
  }
  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param {Uint8Array} id - The ID of the contact to fetch.
   * @returns {object | null} The contact if available, otherwise null
   */
  get(id) {
    ensureInt8("id", id);
    let bitIndex = 0;
    let node = this.root;
    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++);
    }
    const index = this._indexOf(node, id);
    return index >= 0 ? node.contacts[index] : void 0;
  }
  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param {object} node - internal object that has 2 leafs: left and right
   * @param {Uint8Array} id - Contact node id.
   * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
   */
  _indexOf(node, id) {
    for (let i = 0; i < node.contacts.length; ++i) {
      if (arrayEquals2(node.contacts[i].id, id))
        return i;
    }
    return -1;
  }
  /**
   * Removes contact with the provided id.
   *
   * @param {Uint8Array} id - The ID of the contact to remove
   * @returns {object} The k-bucket itself
   */
  remove(id) {
    ensureInt8("the id as parameter 1", id);
    let bitIndex = 0;
    let node = this.root;
    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++);
    }
    const index = this._indexOf(node, id);
    if (index >= 0) {
      const contact = node.contacts.splice(index, 1)[0];
      this.safeDispatchEvent("removed", {
        detail: contact
      });
    }
    return this;
  }
  /**
   * Splits the node, redistributes contacts to the new nodes, and marks the
   * node that was split as an inner node of the binary tree of nodes by
   * setting this.root.contacts = null
   *
   * @param {object} node - node for splitting
   * @param {number} bitIndex - the bitIndex to which byte to check in the Uint8Array for navigating the binary tree
   */
  _split(node, bitIndex) {
    node.left = createNode2();
    node.right = createNode2();
    for (const contact of node.contacts) {
      this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
    }
    node.contacts = null;
    const detNode = this._determineNode(node, this.localNodeId, bitIndex);
    const otherNode = node.left === detNode ? node.right : node.left;
    otherNode.dontSplit = true;
  }
  /**
   * Returns all the contacts contained in the tree as an array.
   * If this is a leaf, return a copy of the bucket. If this is not a leaf,
   * return the union of the low and high branches (themselves also as arrays).
   *
   * @returns {Array} All of the contacts in the tree, as an array
   */
  toArray() {
    let result = [];
    for (const nodes = [this.root]; nodes.length > 0; ) {
      const node = nodes.pop();
      if (node == null) {
        continue;
      }
      if (node.contacts === null) {
        nodes.push(node.right, node.left);
      } else {
        result = result.concat(node.contacts);
      }
    }
    return result;
  }
  /**
   * Similar to `toArray()` but instead of buffering everything up into an
   * array before returning it, yields contacts as they are encountered while
   * walking the tree.
   *
   * @returns {Iterable} All of the contacts in the tree, as an iterable
   */
  *toIterable() {
    for (const nodes = [this.root]; nodes.length > 0; ) {
      const node = nodes.pop();
      if (node == null) {
        continue;
      }
      if (node.contacts === null) {
        nodes.push(node.right, node.left);
      } else {
        yield* node.contacts;
      }
    }
  }
  /**
   * Updates the contact selected by the arbiter.
   * If the selection is our old contact and the candidate is some new contact
   * then the new contact is abandoned (not added).
   * If the selection is our old contact and the candidate is our old contact
   * then we are refreshing the contact and it is marked as most recently
   * contacted (by being moved to the right/end of the bucket array).
   * If the selection is our new contact, the old contact is removed and the new
   * contact is marked as most recently contacted.
   *
   * @param {object} node - internal object that has 2 leafs: left and right
   * @param {number} index - the index in the bucket where contact exists (index has already been computed in a previous calculation)
   * @param {object} contact - The contact object to update
   */
  _update(node, index, contact) {
    if (!arrayEquals2(node.contacts[index].id, contact.id)) {
      throw new Error("wrong index for _update");
    }
    const incumbent = node.contacts[index];
    const selection = this.arbiter(incumbent, contact);
    if (selection === incumbent && incumbent !== contact)
      return;
    node.contacts.splice(index, 1);
    node.contacts.push(selection);
    this.safeDispatchEvent("updated", {
      detail: {
        incumbent,
        selection
      }
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var KBUCKET_SIZE = 20;
var PING_TIMEOUT = 1e4;
var PING_CONCURRENCY = 10;
var RoutingTable = class extends EventEmitter6 {
  static {
    __name(this, "RoutingTable");
  }
  kBucketSize;
  kb;
  pingQueue;
  log;
  components;
  lan;
  pingTimeout;
  pingConcurrency;
  running;
  protocol;
  tagName;
  tagValue;
  metrics;
  constructor(components, init) {
    super();
    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol, tagName, tagValue } = init;
    this.components = components;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table`);
    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE;
    this.pingTimeout = pingTimeout ?? PING_TIMEOUT;
    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY;
    this.lan = lan;
    this.running = false;
    this.protocol = protocol;
    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME;
    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE;
    const updatePingQueueSizeMetric = /* @__PURE__ */ __name(() => {
      this.metrics?.pingQueueSize.update(this.pingQueue.size);
      this.metrics?.pingRunning.update(this.pingQueue.pending);
    }, "updatePingQueueSizeMetric");
    this.pingQueue = new dist_default5({ concurrency: this.pingConcurrency });
    this.pingQueue.addListener("add", updatePingQueueSizeMetric);
    this.pingQueue.addListener("next", updatePingQueueSizeMetric);
    this._onPing = this._onPing.bind(this);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
    if (this.components.metrics != null) {
      this.metrics = {
        routingTableSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_routing_table_size`),
        pingQueueSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_ping_queue_size`),
        pingRunning: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_ping_running`)
      };
    }
    const kBuck = new KBucket({
      localNodeId: await convertPeerId(this.components.peerId),
      numberOfNodesPerKBucket: this.kBucketSize,
      numberOfNodesToPing: 1
    });
    this.kb = kBuck;
    kBuck.addEventListener("ping", this._onPing);
    this._tagPeers(kBuck);
  }
  async stop() {
    this.running = false;
    this.pingQueue.clear();
    this.kb = void 0;
  }
  /**
   * Keep track of our k-closest peers and tag them in the peer store as such
   * - this will lower the chances that connections to them get closed when
   * we reach connection limits
   */
  _tagPeers(kBuck) {
    let kClosest = new PeerSet();
    const updatePeerTags = debounce3(() => {
      const newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map((contact) => contact.peer));
      const addedPeers = newClosest.difference(kClosest);
      const removedPeers = kClosest.difference(newClosest);
      Promise.resolve().then(async () => {
        for (const peer of addedPeers) {
          await this.components.peerStore.merge(peer, {
            tags: {
              [this.tagName]: {
                value: this.tagValue
              }
            }
          });
        }
        for (const peer of removedPeers) {
          await this.components.peerStore.merge(peer, {
            tags: {
              [this.tagName]: void 0
            }
          });
        }
      }).catch((err) => {
        this.log.error("Could not update peer tags", err);
      });
      kClosest = newClosest;
    });
    kBuck.addEventListener("added", (evt) => {
      updatePeerTags();
      this.safeDispatchEvent("peer:add", { detail: evt.detail.peer });
    });
    kBuck.addEventListener("removed", (evt) => {
      updatePeerTags();
      this.safeDispatchEvent("peer:remove", { detail: evt.detail.peer });
    });
  }
  /**
   * Called on the `ping` event from `k-bucket` when a bucket is full
   * and cannot split.
   *
   * `oldContacts.length` is defined by the `numberOfNodesToPing` param
   * passed to the `k-bucket` constructor.
   *
   * `oldContacts` will not be empty and is the list of contacts that
   * have not been contacted for the longest.
   */
  _onPing(evt) {
    const { oldContacts, newContact } = evt.detail;
    this.pingQueue.add(async () => {
      if (!this.running) {
        return;
      }
      let responded = 0;
      try {
        await Promise.all(oldContacts.map(async (oldContact) => {
          try {
            const options = {
              signal: AbortSignal.timeout(this.pingTimeout)
            };
            this.log("pinging old contact %p", oldContact.peer);
            const connection = await this.components.connectionManager.openConnection(oldContact.peer, options);
            const stream = await connection.newStream(this.protocol, options);
            stream.close();
            responded++;
          } catch (err) {
            if (this.running && this.kb != null) {
              this.log.error("could not ping peer %p", oldContact.peer, err);
              this.log("evicting old contact after ping failed %p", oldContact.peer);
              this.kb.remove(oldContact.id);
            }
          } finally {
            this.metrics?.routingTableSize.update(this.size);
          }
        }));
        if (this.running && responded < oldContacts.length && this.kb != null) {
          this.log("adding new contact %p", newContact.peer);
          this.kb.add(newContact);
        }
      } catch (err) {
        this.log.error("could not process k-bucket ping event", err);
      }
    }).catch((err) => {
      this.log.error("could not process k-bucket ping event", err);
    });
  }
  // -- Public Interface
  /**
   * Amount of currently stored peers
   */
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  /**
   * Find a specific peer by id
   */
  async find(peer) {
    const key = await convertPeerId(peer);
    const closest = this.closestPeer(key);
    if (closest != null && peer.equals(closest)) {
      return closest;
    }
    return void 0;
  }
  /**
   * Retrieve the closest peers to the given key
   */
  closestPeer(key) {
    const res = this.closestPeers(key, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  /**
   * Retrieve the `count`-closest peers to the given key
   */
  closestPeers(key, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    const closest = this.kb.closest(key, count);
    return closest.map((p) => p.peer);
  }
  /**
   * Add or update the routing table with the given peer
   */
  async add(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.add({ id, peer });
    this.log("added %p with kad id %b", peer, id);
    this.metrics?.routingTableSize.update(this.size);
  }
  /**
   * Remove a given peer from the table
   */
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.remove(id);
    this.metrics?.routingTableSize.update(this.size);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  static {
    __name(this, "RoutingTableRefresh");
  }
  log;
  peerRouting;
  routingTable;
  refreshInterval;
  refreshQueryTimeout;
  commonPrefixLengthRefreshedAt;
  refreshTimeoutId;
  constructor(init) {
    const { peerRouting: peerRouting2, routingTable, refreshInterval, refreshQueryTimeout, lan } = init;
    this.log = logger14(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table:refresh`);
    this.peerRouting = peerRouting2;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async start() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  /**
   * To speed lookups, we seed the table with random PeerIds. This means
   * when we are asked to locate a peer on the network, we can find a KadId
   * that is close to the requested peer ID and query that, then network
   * peers will tell us who they know who is close to the fake ID
   */
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err) {
              this.log.error(err);
            }
          }
        }
      } catch (err) {
        this.log.error(err);
      }
    })).catch((err) => {
      this.log.error(err);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err) => {
      this.log.error(err);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const peers = await src_default13(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: AbortSignal.timeout(this.refreshQueryTimeout) }));
    this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
    this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i = 0; i <= maxCommonPrefix; i++) {
      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? /* @__PURE__ */ new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    const randomData = randomBytes(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);
    return peerIdFromBytes(key);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha2564.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  /**
   * returns the maximum common prefix length between any peer in the table
   * and the current peer
   */
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length21 of this._prefixLengths()) {
      if (length21 > prefixLength) {
        prefixLength = length21;
      }
    }
    return prefixLength;
  }
  /**
   * Returns the number of peers in the table with a given prefix length
   */
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length21 of this._prefixLengths()) {
      if (length21 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  /**
   * Yields the common prefix length of every peer in the table
   */
  *_prefixLengths() {
    if (this.routingTable.kb == null) {
      return;
    }
    for (const { id } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localNodeId, id);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
var log28 = logger14("libp2p:kad-dht:rpc:handlers:add-provider");
var AddProviderHandler = class {
  static {
    __name(this, "AddProviderHandler");
  }
  providers;
  constructor(init) {
    const { providers } = init;
    this.providers = providers;
  }
  async handle(peerId, msg) {
    log28("start");
    if (msg.key == null || msg.key.length === 0) {
      throw new CodeError("Missing key", "ERR_MISSING_KEY");
    }
    let cid;
    try {
      cid = CID5.decode(msg.key);
    } catch (err) {
      throw new CodeError("Invalid CID", "ERR_INVALID_CID");
    }
    if (msg.providerPeers == null || msg.providerPeers.length === 0) {
      log28.error("no providers found in message");
    }
    await Promise.all(msg.providerPeers.map(async (pi) => {
      if (!pi.id.equals(peerId)) {
        log28("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        log28("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      log28("received provider %p for %s (addrs %s)", peerId, cid, pi.multiaddrs.map((m2) => m2.toString()));
      await this.providers.addProvider(cid, pi.id);
    }));
    return void 0;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
var log29 = logger14("libp2p:kad-dht:rpc:handlers:find-node");
var FindNodeHandler = class {
  static {
    __name(this, "FindNodeHandler");
  }
  peerRouting;
  lan;
  components;
  constructor(components, init) {
    const { peerRouting: peerRouting2, lan } = init;
    this.components = components;
    this.peerRouting = peerRouting2;
    this.lan = Boolean(lan);
  }
  /**
   * Process `FindNode` DHT messages
   */
  async handle(peerId, msg) {
    log29("incoming request from %p for peers closer to %b", peerId, msg.key);
    let closer = [];
    if (equals7(this.components.peerId.toBytes(), msg.key)) {
      closer = [{
        id: this.components.peerId,
        multiaddrs: this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code)),
        protocols: []
      }];
    } else {
      closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
    }
    closer = closer.map(this.lan ? removePublicAddresses : removePrivateAddresses).filter(({ multiaddrs }) => multiaddrs.length);
    const response = new Message3(msg.type, new Uint8Array(0), msg.clusterLevel);
    if (closer.length > 0) {
      response.closerPeers = closer;
    } else {
      log29("could not find any peers closer to %b than %p", msg.key, peerId);
    }
    return response;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
var log30 = logger14("libp2p:kad-dht:rpc:handlers:get-providers");
var GetProvidersHandler = class {
  static {
    __name(this, "GetProvidersHandler");
  }
  components;
  peerRouting;
  providers;
  lan;
  constructor(components, init) {
    const { peerRouting: peerRouting2, providers, lan } = init;
    this.components = components;
    this.peerRouting = peerRouting2;
    this.providers = providers;
    this.lan = Boolean(lan);
  }
  async handle(peerId, msg) {
    let cid;
    try {
      cid = CID5.decode(msg.key);
    } catch (err) {
      throw new CodeError("Invalid CID", "ERR_INVALID_CID");
    }
    log30("%p asking for providers for %s", peerId, cid);
    const [peers, closer] = await Promise.all([
      this.providers.getProviders(cid),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    const providerPeers = await this._getPeers(peers);
    const closerPeers = await this._getPeers(closer.map(({ id }) => id));
    const response = new Message3(msg.type, msg.key, msg.clusterLevel);
    if (providerPeers.length > 0) {
      response.providerPeers = providerPeers;
    }
    if (closerPeers.length > 0) {
      response.closerPeers = closerPeers;
    }
    log30("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
    return response;
  }
  async _getAddresses(peerId) {
    return [];
  }
  async _getPeers(peerIds) {
    const output3 = [];
    const addrFilter = this.lan ? removePublicAddresses : removePrivateAddresses;
    for (const peerId of peerIds) {
      try {
        const peer = await this.components.peerStore.get(peerId);
        const peerAfterFilter = addrFilter({
          id: peerId,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        });
        if (peerAfterFilter.multiaddrs.length > 0) {
          output3.push(peerAfterFilter);
        }
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    return output3;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
var log31 = logger14("libp2p:kad-dht:rpc:handlers:get-value");
var GetValueHandler = class {
  static {
    __name(this, "GetValueHandler");
  }
  components;
  peerRouting;
  constructor(components, init) {
    const { peerRouting: peerRouting2 } = init;
    this.components = components;
    this.peerRouting = peerRouting2;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    log31("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw new CodeError("Invalid key", "ERR_INVALID_KEY");
    }
    const response = new Message3(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);
    if (isPublicKeyKey(key)) {
      log31("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const peer = await this.components.peerStore.get(idFromKey);
        if (peer.id.publicKey == null) {
          throw new CodeError("No public key found in key book", "ERR_NOT_FOUND");
        }
        pubKey = peer.id.publicKey;
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (pubKey != null) {
        log31("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date());
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    if (record != null) {
      log31("had record for %b in local datastore", key);
      response.record = record;
    }
    if (closer.length > 0) {
      log31("had %s closer peers in routing table", closer.length);
      response.closerPeers = closer;
    }
    return response;
  }
  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record if it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `MAX_RECORD_AGE` ago.
   */
  async _checkLocalDatastore(key) {
    log31("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(key);
    let rawRecord;
    try {
      rawRecord = await this.components.datastore.get(dsKey);
    } catch (err) {
      if (err.code === "ERR_NOT_FOUND") {
        return void 0;
      }
      throw err;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record == null) {
      throw new CodeError("Invalid record", "ERR_INVALID_RECORD");
    }
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.components.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
var log32 = logger14("libp2p:kad-dht:rpc:handlers:ping");
var PingHandler = class {
  static {
    __name(this, "PingHandler");
  }
  async handle(peerId, msg) {
    log32("ping from %p", peerId);
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
var PutValueHandler = class {
  static {
    __name(this, "PutValueHandler");
  }
  log;
  components;
  validators;
  constructor(components, init) {
    const { validators: validators2 } = init;
    this.components = components;
    this.log = logger14("libp2p:kad-dht:rpc:handlers:put-value");
    this.validators = validators2;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    const record = msg.record;
    if (record == null) {
      const errMsg = `Empty record from: ${peerId.toString()}`;
      this.log.error(errMsg);
      throw new CodeError(errMsg, "ERR_EMPTY_RECORD");
    }
    try {
      await verifyRecord(this.validators, record);
      record.timeReceived = /* @__PURE__ */ new Date();
      const recordKey = bufferToRecordKey(record.key);
      await this.components.datastore.put(recordKey, record.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err) {
      this.log("did not put record for key %b into datastore %o", key, err);
    }
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC2 = class {
  static {
    __name(this, "RPC");
  }
  handlers;
  routingTable;
  log;
  constructor(components, init) {
    const { providers, peerRouting: peerRouting2, validators: validators2, lan } = init;
    this.log = logger14("libp2p:kad-dht:rpc");
    this.routingTable = init.routingTable;
    this.handlers = {
      [MESSAGE_TYPE.GET_VALUE]: new GetValueHandler(components, { peerRouting: peerRouting2 }),
      [MESSAGE_TYPE.PUT_VALUE]: new PutValueHandler(components, { validators: validators2 }),
      [MESSAGE_TYPE.FIND_NODE]: new FindNodeHandler(components, { peerRouting: peerRouting2, lan }),
      [MESSAGE_TYPE.ADD_PROVIDER]: new AddProviderHandler({ providers }),
      [MESSAGE_TYPE.GET_PROVIDERS]: new GetProvidersHandler(components, { peerRouting: peerRouting2, providers, lan }),
      [MESSAGE_TYPE.PING]: new PingHandler()
    };
  }
  /**
   * Process incoming DHT messages
   */
  async handleMessage(peerId, msg) {
    try {
      await this.routingTable.add(peerId);
    } catch (err) {
      this.log.error("Failed to update the kbucket store", err);
    }
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    return handler.handle(peerId, msg);
  }
  /**
   * Handle incoming streams on the dht protocol
   */
  onIncomingStream(data) {
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const peerId = connection.remotePeer;
      try {
        await this.routingTable.add(peerId);
      } catch (err) {
        this.log.error(err);
      }
      const self2 = this;
      await pipe(stream, (source) => decode21(source), async function* (source) {
        for await (const msg of source) {
          const desMessage = Message3.deserialize(msg);
          self2.log("incoming %s from %p", desMessage.type, peerId);
          const res = await self2.handleMessage(peerId, desMessage);
          if (res != null) {
            yield res.serialize();
          }
        }
      }, (source) => encode16(source), stream);
    }).catch((err) => {
      this.log.error(err);
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
var TopologyListener = class extends EventEmitter6 {
  static {
    __name(this, "TopologyListener");
  }
  log;
  components;
  protocol;
  running;
  registrarId;
  constructor(components, init) {
    super();
    const { protocol, lan } = init;
    this.components = components;
    this.log = logger14(`libp2p:kad-dht:topology-listener:${lan ? "lan" : "wan"}`);
    this.running = false;
    this.protocol = protocol;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const topology = createTopology({
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId
        }));
      }
    });
    this.registrarId = await this.components.registrar.register(this.protocol, topology);
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS3 = 64;
var DefaultKadDHT = class extends EventEmitter6 {
  static {
    __name(this, "DefaultKadDHT");
  }
  protocol;
  routingTable;
  providers;
  network;
  peerRouting;
  components;
  log;
  running;
  kBucketSize;
  clientMode;
  lan;
  validators;
  selectors;
  queryManager;
  contentFetching;
  contentRouting;
  routingTableRefresh;
  rpc;
  topologyListener;
  querySelf;
  maxInboundStreams;
  maxOutboundStreams;
  /**
   * Create a new KadDHT
   */
  constructor(components, init) {
    super();
    const { kBucketSize, clientMode, validators: validators2, selectors: selectors2, querySelfInterval, lan, protocolPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams, providers: providersInit } = init;
    this.running = false;
    this.components = components;
    this.lan = Boolean(lan);
    this.log = logger14(`libp2p:kad-dht:${lan === true ? "lan" : "wan"}`);
    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ""}${PROTOCOL_DHT}`;
    this.kBucketSize = kBucketSize ?? 20;
    this.clientMode = clientMode ?? true;
    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS3;
    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
    this.routingTable = new RoutingTable(components, {
      kBucketSize,
      lan: this.lan,
      pingTimeout,
      pingConcurrency,
      protocol: this.protocol
    });
    this.providers = new Providers(components, providersInit ?? {});
    this.validators = {
      ...validators,
      ...validators2
    };
    this.selectors = {
      ...selectors,
      ...selectors2
    };
    this.network = new Network2(components, {
      protocol: this.protocol,
      lan: this.lan
    });
    const initialQuerySelfHasRun = pDefer();
    if (init.allowQueryWithZeroPeers === true) {
      initialQuerySelfHasRun.resolve();
    }
    this.queryManager = new QueryManager(components, {
      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      lan,
      initialQuerySelfHasRun,
      routingTable: this.routingTable
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      lan: this.lan
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      network: this.network,
      lan: this.lan
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      lan: this.lan
    });
    this.routingTableRefresh = new RoutingTableRefresh({
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      lan: this.lan
    });
    this.rpc = new RPC2(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      lan: this.lan
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      lan: this.lan
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: querySelfInterval,
      initialInterval: init.initialQuerySelfInterval,
      lan: this.lan,
      initialQuerySelfHasRun,
      routingTable: this.routingTable
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err) => {
        this.log.error("could not add %p to routing table", peerData.id, err);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const peer = await this.components.peerStore.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        };
        await this.onPeerConnect(peerData);
      }).catch((err) => {
        this.log.error("could not add %p to routing table", peerId, err);
      });
    });
  }
  async onPeerConnect(peerData) {
    this.log("peer %p connected with protocols", peerData.id, peerData.protocols);
    if (this.lan) {
      peerData = removePublicAddresses(peerData);
    } else {
      peerData = removePrivateAddresses(peerData);
    }
    if (peerData.multiaddrs.length === 0) {
      this.log("ignoring %p as they do not have any %s addresses in %s", peerData.id, this.lan ? "private" : "public", peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err) {
      this.log.error("could not add %p to routing table", peerData.id, err);
    }
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.running;
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async getMode() {
    return this.clientMode ? "client" : "server";
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode) {
    await this.components.registrar.unhandle(this.protocol);
    if (mode === "client") {
      this.log("enabling client mode");
      this.clientMode = true;
    } else {
      this.log("enabling server mode");
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server");
    await Promise.all([
      this.providers.start(),
      this.queryManager.start(),
      this.network.start(),
      this.routingTable.start(),
      this.topologyListener.start()
    ]);
    this.querySelf.start();
    await this.routingTableRefresh.start();
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    this.running = false;
    this.querySelf.stop();
    await Promise.all([
      this.providers.stop(),
      this.queryManager.stop(),
      this.network.stop(),
      this.routingTable.stop(),
      this.routingTableRefresh.stop(),
      this.topologyListener.stop()
    ]);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options = {}) {
    yield* this.contentFetching.put(key, value, options);
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options = {}) {
    yield* this.contentFetching.get(key, options);
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options);
  }
  /**
   * Search the dht for providers of the given CID
   */
  async *findProviders(key, options = {}) {
    yield* this.contentRouting.findProviders(key, options);
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options = {}) {
    yield* this.peerRouting.findPeer(id, options);
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options = {}) {
    yield* this.peerRouting.getClosestPeers(key, options);
  }
  async refreshRoutingTable() {
    this.routingTableRefresh.refreshTable(true);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/dual-kad-dht.js
var log33 = logger14("libp2p:kad-dht");
var DHTContentRouting = class {
  static {
    __name(this, "DHTContentRouting");
  }
  dht;
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid, options = {}) {
    await src_default2(this.dht.provide(cid, options));
  }
  async *findProviders(cid, options = {}) {
    for await (const event of this.dht.findProviders(cid, options)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value, options) {
    await src_default2(this.dht.put(key, value, options));
  }
  async get(key, options) {
    for await (const event of this.dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
};
var DHTPeerRouting = class {
  static {
    __name(this, "DHTPeerRouting");
  }
  dht;
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId, options = {}) {
    for await (const event of this.dht.findPeer(peerId, options)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options = {}) {
    for await (const event of this.dht.getClosestPeers(key, options)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};
var P2P_CIRCUIT_CODE = 290;
var DNS4_CODE = 54;
var DNS6_CODE = 55;
var DNSADDR_CODE = 56;
var IP4_CODE = 4;
var IP6_CODE = 41;
function multiaddrIsPublic(multiaddr2) {
  const tuples = multiaddr2.stringTuples();
  for (const tuple of tuples) {
    if (tuple[0] === P2P_CIRCUIT_CODE) {
      return false;
    }
  }
  if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {
    log33("%m is public %s", multiaddr2, true);
    return true;
  }
  if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {
    const result = private_ip_default(`${tuples[0][1]}`);
    const isPublic = result == null || !result;
    log33("%m is public %s", multiaddr2, isPublic);
    return isPublic;
  }
  return false;
}
__name(multiaddrIsPublic, "multiaddrIsPublic");
var DefaultDualKadDHT = class extends EventEmitter6 {
  static {
    __name(this, "DefaultDualKadDHT");
  }
  wan;
  lan;
  components;
  contentRouting;
  peerRouting;
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.wan = new DefaultKadDHT(components, {
      protocolPrefix: "/ipfs",
      ...init,
      lan: false
    });
    this.lan = new DefaultKadDHT(components, {
      protocolPrefix: "/ipfs",
      ...init,
      clientMode: false,
      lan: true
    });
    this.contentRouting = new DHTContentRouting(this);
    this.peerRouting = new DHTPeerRouting(this);
    this.wan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
    this.lan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
    if (init.clientMode == null) {
      components.events.addEventListener("self:peer:update", (evt) => {
        log33("received update of self-peer info");
        const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => {
          const isPublic = multiaddrIsPublic(multiaddr2);
          log33("%m is public %s", multiaddr2, isPublic);
          return isPublic;
        });
        this.getMode().then(async (mode) => {
          if (hasPublicAddress && mode === "client") {
            await this.setMode("server");
          } else if (mode === "server" && !hasPublicAddress) {
            await this.setMode("client");
          }
        }).catch((err) => {
          log33.error("error setting dht server mode", err);
        });
      });
    }
  }
  [Symbol.toStringTag] = "@libp2p/dual-kad-dht";
  get [contentRouting]() {
    return this.contentRouting;
  }
  get [peerRouting]() {
    return this.peerRouting;
  }
  get [peerDiscovery]() {
    return this;
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.wan.isStarted() && this.lan.isStarted();
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async getMode() {
    return this.wan.getMode();
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode) {
    await this.wan.setMode(mode);
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    await Promise.all([
      this.lan.start(),
      this.wan.start()
    ]);
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    await Promise.all([
      this.lan.stop(),
      this.wan.stop()
    ]);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options = {}) {
    for await (const event of src_default5(this.lan.put(key, value, options), this.wan.put(key, value, options))) {
      yield event;
    }
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options = {}) {
    let queriedPeers = false;
    let foundValue = false;
    for await (const event of src_default5(this.lan.get(key, options), this.wan.get(key, options))) {
      yield event;
      if (event.name === "DIAL_PEER") {
        queriedPeers = true;
      }
      if (event.name === "VALUE") {
        queriedPeers = true;
        if (event.value != null) {
          foundValue = true;
        }
      }
      if (event.name === "SEND_QUERY") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw new CodeError("No peers found in routing table!", "ERR_NO_PEERS_IN_ROUTING_TABLE");
    }
    if (!foundValue) {
      yield queryErrorEvent({
        from: this.components.peerId,
        error: new CodeError("Not found", "ERR_NOT_FOUND")
      }, options);
    }
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options = {}) {
    let sent = 0;
    let success = 0;
    const errors = [];
    const dhts = [this.lan];
    if (await this.wan.getMode() === "server") {
      dhts.push(this.wan);
    }
    for await (const event of src_default5(...dhts.map((dht) => dht.provide(key, options)))) {
      yield event;
      if (event.name === "SEND_QUERY") {
        sent++;
      }
      if (event.name === "QUERY_ERROR") {
        errors.push(event.error);
      }
      if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
        log33("sent provider record for %s to %p", key, event.from);
        success++;
      }
    }
    if (success === 0) {
      if (errors.length > 0) {
        throw new CodeError(`Failed to provide to ${errors.length} of ${sent} peers`, "ERR_PROVIDES_FAILED", { errors });
      }
      throw new CodeError("Failed to provide - no peers found", "ERR_PROVIDES_FAILED");
    }
  }
  /**
   * Search the dht for up to `K` providers of the given CID
   */
  async *findProviders(key, options = {}) {
    yield* src_default5(this.lan.findProviders(key, options), this.wan.findProviders(key, options));
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options = {}) {
    let queriedPeers = false;
    for await (const event of src_default5(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {
      yield event;
      if (event.name === "SEND_QUERY" || event.name === "FINAL_PEER") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw new CodeError("Peer lookup failed", "ERR_LOOKUP_FAILED");
    }
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options = {}) {
    yield* src_default5(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));
  }
  async refreshRoutingTable() {
    await Promise.all([
      this.lan.refreshRoutingTable(),
      this.wan.refreshRoutingTable()
    ]);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/index.js
var EventTypes;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
  EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
})(EventTypes || (EventTypes = {}));
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["PUT_VALUE"] = 0] = "PUT_VALUE";
  MessageType2[MessageType2["GET_VALUE"] = 1] = "GET_VALUE";
  MessageType2[MessageType2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  MessageType2[MessageType2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  MessageType2[MessageType2["FIND_NODE"] = 4] = "FIND_NODE";
  MessageType2[MessageType2["PING"] = 5] = "PING";
})(MessageType || (MessageType = {}));
function kadDHT(init) {
  return (components) => new DefaultDualKadDHT(components, init);
}
__name(kadDHT, "kadDHT");

// node_modules/@libp2p/mplex/node_modules/@libp2p/logger/dist/src/index.js
var import_debug12 = __toESM(require_browser(), 1);

// node_modules/@libp2p/mplex/node_modules/multiformats/vendor/base-x.js
function base33(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base33, "base");
var src22 = base33;
var _brrp__multiformats_scope_baseX22 = src22;
var base_x_default22 = _brrp__multiformats_scope_baseX22;

// node_modules/@libp2p/mplex/node_modules/multiformats/src/bytes.js
var empty24 = new Uint8Array(0);
var coerce24 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/mplex/node_modules/multiformats/src/bases/base.js
var Encoder22 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder23 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or23(this, decoder);
  }
};
var ComposedDecoder22 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or23(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or23 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder22(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec22 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder22(name14, prefix, baseEncode);
    this.decoder = new Decoder23(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from33 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec22(name14, prefix, encode79, decode97), "from");
var baseX22 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default22(alphabet11, name14);
  return from33({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce24(decode97(text))
  });
}, "baseX");
var decode68 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode55 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464822 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from33({
    prefix,
    name: name14,
    encode(input) {
      return encode55(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode68(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/mplex/node_modules/multiformats/src/bases/base58.js
var base58btc22 = baseX22({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr22 = baseX22({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/mplex/node_modules/multiformats/src/bases/base32.js
var base3221 = rfc464822({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper21 = rfc464822({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad21 = rfc464822({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper21 = rfc464822({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex21 = rfc464822({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper21 = rfc464822({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad21 = rfc464822({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper21 = rfc464822({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z21 = rfc464822({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/mplex/node_modules/multiformats/src/bases/base64.js
var base6421 = rfc464822({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad21 = rfc464822({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url21 = rfc464822({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad21 = rfc464822({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/mplex/node_modules/@libp2p/logger/dist/src/index.js
import_debug12.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc22.baseEncode(v);
};
import_debug12.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3221.baseEncode(v);
};
import_debug12.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6421.baseEncode(v);
};
import_debug12.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug12.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug12.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug12.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger14(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger14, "createDisabledLogger");
function logger15(name14) {
  let trace = createDisabledLogger14(`${name14}:trace`);
  if (import_debug12.default.enabled(`${name14}:trace`) && import_debug12.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug12.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug12.default)(name14), {
    error: (0, import_debug12.default)(`${name14}:error`),
    trace
  });
}
__name(logger15, "logger");

// node_modules/@libp2p/mplex/dist/src/mplex.js
var import_rate_limiter_flexible2 = __toESM(require_rate_limiter_flexible(), 1);

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/decode.js
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder24 = class {
  static {
    __name(this, "Decoder");
  }
  _buffer;
  _headerInfo;
  _maxMessageSize;
  _maxUnprocessedMessageQueueSize;
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw Object.assign(new Error("unprocessed message queue size too large!"), { code: "ERR_MSG_QUEUE_TOO_BIG" });
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err) {
          if (err.code === "ERR_MSG_TOO_BIG") {
            throw err;
          }
          break;
        }
      }
      const { id, type, length: length21, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length21) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length21);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length21);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h2, offset } = readVarInt(data);
    const { value: length21, offset: end } = readVarInt(data, offset);
    const type = h2 & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length21 > this._maxMessageSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
    return { id: h2 >> 3, type, offset: offset + end, length: length21 };
  }
};
var MSB15 = 128;
var REST15 = 127;
function readVarInt(buf3, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf3.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3.get(counter++);
    res += shift < 28 ? (b & REST15) << shift : (b & REST15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB15);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}
__name(readVarInt, "readVarInt");

// node_modules/it-batched-bytes/dist/src/index.js
function isAsyncIterable13(thing) {
  return thing[Symbol.asyncIterator] != null;
}
__name(isAsyncIterable13, "isAsyncIterable");
var DEFAULT_BATCH_SIZE = 1024 * 1024;
var DEFAULT_SERIALIZE = /* @__PURE__ */ __name((buf3, list) => {
  list.append(buf3);
}, "DEFAULT_SERIALIZE");
function batchedBytes(source, options) {
  if (isAsyncIterable13(source)) {
    return async function* () {
      let buffer3 = new Uint8ArrayList();
      let ended = false;
      let deferred = pDefer();
      let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);
      if (isNaN(size) || size === 0 || size < 0) {
        size = DEFAULT_BATCH_SIZE;
      }
      if (size !== Math.round(size)) {
        throw new Error("Batch size must be an integer");
      }
      const yieldAfter = options?.yieldAfter ?? 0;
      const serialize = options?.serialize ?? DEFAULT_SERIALIZE;
      void Promise.resolve().then(async () => {
        try {
          let timeout;
          for await (const buf3 of source) {
            serialize(buf3, buffer3);
            if (buffer3.byteLength >= size) {
              clearTimeout(timeout);
              deferred.resolve();
              continue;
            }
            timeout = setTimeout(() => {
              deferred.resolve();
            }, yieldAfter);
          }
          clearTimeout(timeout);
          deferred.resolve();
        } catch (err) {
          deferred.reject(err);
        } finally {
          ended = true;
        }
      });
      while (!ended) {
        await deferred.promise;
        deferred = pDefer();
        if (buffer3.byteLength > 0) {
          const b = buffer3;
          buffer3 = new Uint8ArrayList();
          yield b.subarray();
        }
      }
    }();
  }
  return function* () {
    const buffer3 = new Uint8ArrayList();
    let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);
    if (isNaN(size) || size === 0 || size < 0) {
      size = DEFAULT_BATCH_SIZE;
    }
    if (size !== Math.round(size)) {
      throw new Error("Batch size must be an integer");
    }
    const serialize = options?.serialize ?? DEFAULT_SERIALIZE;
    for (const buf3 of source) {
      serialize(buf3, buffer3);
      if (buffer3.byteLength >= size) {
        yield buffer3.subarray(0, size);
        buffer3.consume(size);
      }
    }
    if (buffer3.byteLength > 0) {
      yield buffer3.subarray();
    }
  }();
}
__name(batchedBytes, "batchedBytes");
var src_default14 = batchedBytes;

// node_modules/@libp2p/mplex/dist/src/encode.js
var import_varint15 = __toESM(require_varint2(), 1);

// node_modules/@libp2p/mplex/dist/src/alloc-unsafe-browser.js
function allocUnsafe10(size) {
  return new Uint8Array(size);
}
__name(allocUnsafe10, "allocUnsafe");

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder23 = class {
  static {
    __name(this, "Encoder");
  }
  _pool;
  _poolOffset;
  constructor() {
    this._pool = allocUnsafe10(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool2 = this._pool;
    let offset = this._poolOffset;
    import_varint15.default.encode(msg.id << 3 | msg.type, pool2, offset);
    offset += import_varint15.default.encode.bytes ?? 0;
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      import_varint15.default.encode(msg.data.length, pool2, offset);
    } else {
      import_varint15.default.encode(0, pool2, offset);
    }
    offset += import_varint15.default.encode.bytes ?? 0;
    const header = pool2.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe10(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder23();
async function* encode56(source, minSendBytes = 0) {
  if (minSendBytes == null || minSendBytes === 0) {
    for await (const messages2 of source) {
      const list = new Uint8ArrayList();
      for (const msg of messages2) {
        encoder.write(msg, list);
      }
      yield list.subarray();
    }
    return;
  }
  yield* src_default14(source, {
    size: minSendBytes,
    serialize: (obj, list) => {
      for (const m2 of obj) {
        encoder.write(m2, list);
      }
    }
  });
}
__name(encode56, "encode");

// node_modules/@libp2p/interface-stream-muxer/node_modules/@libp2p/logger/dist/src/index.js
var import_debug13 = __toESM(require_browser(), 1);

// node_modules/@libp2p/interface-stream-muxer/node_modules/multiformats/vendor/base-x.js
function base34(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base34, "base");
var src23 = base34;
var _brrp__multiformats_scope_baseX23 = src23;
var base_x_default23 = _brrp__multiformats_scope_baseX23;

// node_modules/@libp2p/interface-stream-muxer/node_modules/multiformats/src/bytes.js
var empty25 = new Uint8Array(0);
var coerce25 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/interface-stream-muxer/node_modules/multiformats/src/bases/base.js
var Encoder24 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder25 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or24(this, decoder);
  }
};
var ComposedDecoder23 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or24(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or24 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder23(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec23 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder24(name14, prefix, baseEncode);
    this.decoder = new Decoder25(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from34 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec23(name14, prefix, encode79, decode97), "from");
var baseX23 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default23(alphabet11, name14);
  return from34({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce25(decode97(text))
  });
}, "baseX");
var decode69 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode57 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464823 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from34({
    prefix,
    name: name14,
    encode(input) {
      return encode57(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode69(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/interface-stream-muxer/node_modules/multiformats/src/bases/base58.js
var base58btc23 = baseX23({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr23 = baseX23({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/interface-stream-muxer/node_modules/multiformats/src/bases/base32.js
var base3222 = rfc464823({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper22 = rfc464823({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad22 = rfc464823({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper22 = rfc464823({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex22 = rfc464823({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper22 = rfc464823({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad22 = rfc464823({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper22 = rfc464823({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z22 = rfc464823({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/interface-stream-muxer/node_modules/multiformats/src/bases/base64.js
var base6422 = rfc464823({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad22 = rfc464823({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url22 = rfc464823({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad22 = rfc464823({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/interface-stream-muxer/node_modules/@libp2p/logger/dist/src/index.js
import_debug13.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc23.baseEncode(v);
};
import_debug13.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3222.baseEncode(v);
};
import_debug13.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6422.baseEncode(v);
};
import_debug13.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug13.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug13.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug13.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger15(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger15, "createDisabledLogger");
function logger16(name14) {
  let trace = createDisabledLogger15(`${name14}:trace`);
  if (import_debug13.default.enabled(`${name14}:trace`) && import_debug13.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug13.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug13.default)(name14), {
    error: (0, import_debug13.default)(`${name14}:error`),
    trace
  });
}
__name(logger16, "logger");

// node_modules/@libp2p/interface-stream-muxer/dist/src/stream.js
var log34 = logger16("libp2p:stream");
var ERR_STREAM_RESET2 = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT2 = "ERR_STREAM_ABORT";
var ERR_SINK_ENDED = "ERR_SINK_ENDED";
var ERR_DOUBLE_SINK = "ERR_DOUBLE_SINK";
function isPromise2(res) {
  return res != null && typeof res.then === "function";
}
__name(isPromise2, "isPromise");
var AbstractStream = class {
  static {
    __name(this, "AbstractStream");
  }
  id;
  stat;
  metadata;
  source;
  abortController;
  resetController;
  closeController;
  sourceEnded;
  sinkEnded;
  sinkSunk;
  endErr;
  streamSource;
  onEnd;
  maxDataSize;
  constructor(init) {
    this.abortController = new AbortController();
    this.resetController = new AbortController();
    this.closeController = new AbortController();
    this.sourceEnded = false;
    this.sinkEnded = false;
    this.sinkSunk = false;
    this.id = init.id;
    this.metadata = init.metadata ?? {};
    this.stat = {
      direction: init.direction,
      timeline: {
        open: Date.now()
      }
    };
    this.maxDataSize = init.maxDataSize;
    this.onEnd = init.onEnd;
    this.source = this.streamSource = pushable({
      onEnd: () => {
        if (this.stat.timeline.reset !== null) {
          const res = this.sendCloseRead();
          if (isPromise2(res)) {
            res.catch((err) => {
              log34.error("error while sending close read", err);
            });
          }
        }
        this.onSourceEnd();
      }
    });
    this.sink = this.sink.bind(this);
  }
  onSourceEnd(err) {
    if (this.sourceEnded) {
      return;
    }
    this.stat.timeline.closeRead = Date.now();
    this.sourceEnded = true;
    log34.trace("%s stream %s source end - err: %o", this.stat.direction, this.id, err);
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    if (this.sinkEnded) {
      this.stat.timeline.close = Date.now();
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
    }
  }
  onSinkEnd(err) {
    if (this.sinkEnded) {
      return;
    }
    this.stat.timeline.closeWrite = Date.now();
    this.sinkEnded = true;
    log34.trace("%s stream %s sink end - err: %o", this.stat.direction, this.id, err);
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    if (this.sourceEnded) {
      this.stat.timeline.close = Date.now();
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
    }
  }
  // Close for both Reading and Writing
  close() {
    log34.trace("%s stream %s close", this.stat.direction, this.id);
    this.closeRead();
    this.closeWrite();
  }
  // Close for reading
  closeRead() {
    log34.trace("%s stream %s closeRead", this.stat.direction, this.id);
    if (this.sourceEnded) {
      return;
    }
    this.streamSource.end();
  }
  // Close for writing
  closeWrite() {
    log34.trace("%s stream %s closeWrite", this.stat.direction, this.id);
    if (this.sinkEnded) {
      return;
    }
    this.closeController.abort();
    try {
      const res = this.sendCloseWrite();
      if (isPromise2(res)) {
        res.catch((err) => {
          log34.error("error while sending close write", err);
        });
      }
    } catch (err) {
      log34.trace("%s stream %s error sending close", this.stat.direction, this.id, err);
    }
    this.onSinkEnd();
  }
  // Close for reading and writing (local error)
  abort(err) {
    log34.trace("%s stream %s abort", this.stat.direction, this.id, err);
    this.streamSource.end(err);
    this.abortController.abort();
    this.onSinkEnd(err);
  }
  // Close immediately for reading and writing (remote error)
  reset() {
    const err = new CodeError("stream reset", ERR_STREAM_RESET2);
    this.resetController.abort();
    this.streamSource.end(err);
    this.onSinkEnd(err);
  }
  async sink(source) {
    if (this.sinkSunk) {
      throw new CodeError("sink already called on stream", ERR_DOUBLE_SINK);
    }
    this.sinkSunk = true;
    if (this.sinkEnded) {
      throw new CodeError("stream closed for writing", ERR_SINK_ENDED);
    }
    const signal = anySignal([
      this.abortController.signal,
      this.resetController.signal,
      this.closeController.signal
    ]);
    try {
      source = abortableSource(source, signal);
      if (this.stat.direction === "outbound") {
        const res = this.sendNewStream();
        if (isPromise2(res)) {
          await res;
        }
      }
      for await (let data of source) {
        while (data.length > 0) {
          if (data.length <= this.maxDataSize) {
            const res2 = this.sendData(data instanceof Uint8Array ? new Uint8ArrayList(data) : data);
            if (isPromise2(res2)) {
              await res2;
            }
            break;
          }
          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
          const res = this.sendData(data.sublist(0, this.maxDataSize));
          if (isPromise2(res)) {
            await res;
          }
          data.consume(this.maxDataSize);
        }
      }
    } catch (err) {
      if (err.type === "aborted" && err.message === "The operation was aborted") {
        if (this.closeController.signal.aborted) {
          return;
        }
        if (this.resetController.signal.aborted) {
          err.message = "stream reset";
          err.code = ERR_STREAM_RESET2;
        }
        if (this.abortController.signal.aborted) {
          err.message = "stream aborted";
          err.code = ERR_STREAM_ABORT2;
        }
      }
      if (err.code === ERR_STREAM_RESET2) {
        log34.trace("%s stream %s reset", this.stat.direction, this.id);
      } else {
        log34.trace("%s stream %s error", this.stat.direction, this.id, err);
        try {
          const res = this.sendReset();
          if (isPromise2(res)) {
            await res;
          }
          this.stat.timeline.reset = Date.now();
        } catch (err2) {
          log34.trace("%s stream %s error sending reset", this.stat.direction, this.id, err2);
        }
      }
      this.streamSource.end(err);
      this.onSinkEnd(err);
      throw err;
    } finally {
      signal.clear();
    }
    try {
      const res = this.sendCloseWrite();
      if (isPromise2(res)) {
        await res;
      }
    } catch (err) {
      log34.trace("%s stream %s error sending close", this.stat.direction, this.id, err);
    }
    this.onSinkEnd();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(data) {
    this.streamSource.push(data);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
};

// node_modules/@libp2p/mplex/dist/src/stream.js
var MplexStream = class extends AbstractStream {
  static {
    __name(this, "MplexStream");
  }
  name;
  streamId;
  send;
  types;
  constructor(init) {
    super(init);
    this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
    this.send = init.send;
    this.name = init.name;
    this.streamId = init.streamId;
  }
  sendNewStream() {
    this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString7(this.name)) });
  }
  sendData(data) {
    this.send({ id: this.streamId, type: this.types.MESSAGE, data });
  }
  sendReset() {
    this.send({ id: this.streamId, type: this.types.RESET });
  }
  sendCloseWrite() {
    this.send({ id: this.streamId, type: this.types.CLOSE });
  }
  sendCloseRead() {
  }
};
function createStream(options) {
  const { id, name: name14, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  return new MplexStream({
    id: type === "initiator" ? `i${id}` : `r${id}`,
    streamId: id,
    name: `${name14 == null ? id : name14}`,
    direction: type === "initiator" ? "outbound" : "inbound",
    maxDataSize: maxMsgSize,
    onEnd,
    send
  });
}
__name(createStream, "createStream");

// node_modules/@libp2p/mplex/dist/src/mplex.js
var log35 = logger15("libp2p:mplex");
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
function printMessage(msg) {
  const output3 = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output3.data = toString5(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output3.data = toString5(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output3;
}
__name(printMessage, "printMessage");
var MplexStreamMuxer = class {
  static {
    __name(this, "MplexStreamMuxer");
  }
  protocol = "/mplex/6.7.0";
  sink;
  source;
  _streamId;
  _streams;
  _init;
  _source;
  closeController;
  rateLimiter;
  constructor(init) {
    init = init ?? {};
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.sink = this._createSink();
    const source = this._createSource();
    this._source = source;
    this.source = source;
    this.closeController = new AbortController();
    this.rateLimiter = new import_rate_limiter_flexible2.RateLimiterMemory({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name14) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name14 = name14 == null ? id.toString() : name14.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name14, type: "initiator", registry });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  close(err) {
    if (this.closeController.signal.aborted)
      return;
    if (err != null) {
      this.streams.forEach((s2) => {
        s2.abort(err);
      });
    } else {
      this.streams.forEach((s2) => {
        s2.close();
      });
    }
    this.closeController.abort();
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options) {
    const { id, name: name14 } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name14, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name: name14, type, registry } = options;
    log35("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw new CodeError("Too many outbound streams open", "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = /* @__PURE__ */ __name((msg) => {
      if (log35.enabled) {
        log35.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    }, "send");
    const onEnd = /* @__PURE__ */ __name(() => {
      log35("%s stream with id %s and protocol %s ended", type, id, stream.stat.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    }, "onEnd");
    const stream = createStream({ id, name: name14, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = /* @__PURE__ */ __name(async (source) => {
      const signal = anySignal([this.closeController.signal, this._init.signal]);
      try {
        source = abortableSource(source, signal);
        const decoder = new Decoder24(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err) {
        log35("error in sink", err);
        this._source.end(err);
      } finally {
        signal.clear();
      }
    }, "sink");
    return sink;
  }
  /**
   * Creates a source that restricts outgoing message sizes
   * and varint encodes them
   */
  _createSource() {
    const onEnd = /* @__PURE__ */ __name((err) => {
      this.close(err);
    }, "onEnd");
    const source = pushableV({
      objectMode: true,
      onEnd
    });
    return Object.assign(encode56(source, this._init.minSendBytes), {
      push: source.push,
      end: source.end,
      return: source.return
    });
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (log35.enabled) {
      log35.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log35("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log35("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this._source.end(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString5(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      log35("missing stream %s for message type %s", id, MessageTypeNames[type]);
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        if (stream.sourceReadableLength() > maxBufferSize) {
          this._source.push({
            id: message2.id,
            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
          });
          const error = new CodeError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers", "ERR_STREAM_INPUT_BUFFER_FULL");
          stream.abort(error);
          return;
        }
        stream.sourcePush(message2.data);
        break;
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream.closeRead();
        break;
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream.reset();
        break;
      default:
        log35("unknown message type %s", type);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  static {
    __name(this, "Mplex");
  }
  protocol = "/mplex/6.7.0";
  _init;
  constructor(init = {}) {
    this._init = init;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer({
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return () => new Mplex(init);
}
__name(mplex, "mplex");

// node_modules/@libp2p/webrtc/node_modules/@libp2p/logger/dist/src/index.js
var import_debug14 = __toESM(require_browser(), 1);

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base58.js
var base58_exports7 = {};
__export(base58_exports7, {
  base58btc: () => base58btc24,
  base58flickr: () => base58flickr24
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/vendor/base-x.js
function base35(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base35, "base");
var src24 = base35;
var _brrp__multiformats_scope_baseX24 = src24;
var base_x_default24 = _brrp__multiformats_scope_baseX24;

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bytes.js
var empty26 = new Uint8Array(0);
var equals27 = /* @__PURE__ */ __name((aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}, "equals");
var coerce26 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");
var fromString12 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString");
var toString13 = /* @__PURE__ */ __name((b) => new TextDecoder().decode(b), "toString");

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base.js
var Encoder25 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder26 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or25(this, decoder);
  }
};
var ComposedDecoder24 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or25(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or25 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder24(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec24 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder25(name14, prefix, baseEncode);
    this.decoder = new Decoder26(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from35 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec24(name14, prefix, encode79, decode97), "from");
var baseX24 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default24(alphabet11, name14);
  return from35({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce26(decode97(text))
  });
}, "baseX");
var decode70 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode58 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464824 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from35({
    prefix,
    name: name14,
    encode(input) {
      return encode58(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode70(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base58.js
var base58btc24 = baseX24({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr24 = baseX24({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base32.js
var base32_exports7 = {};
__export(base32_exports7, {
  base32: () => base3223,
  base32hex: () => base32hex23,
  base32hexpad: () => base32hexpad23,
  base32hexpadupper: () => base32hexpadupper23,
  base32hexupper: () => base32hexupper23,
  base32pad: () => base32pad23,
  base32padupper: () => base32padupper23,
  base32upper: () => base32upper23,
  base32z: () => base32z23
});
var base3223 = rfc464824({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper23 = rfc464824({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad23 = rfc464824({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper23 = rfc464824({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex23 = rfc464824({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper23 = rfc464824({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad23 = rfc464824({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper23 = rfc464824({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z23 = rfc464824({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base64.js
var base64_exports7 = {};
__export(base64_exports7, {
  base64: () => base6423,
  base64pad: () => base64pad23,
  base64url: () => base64url23,
  base64urlpad: () => base64urlpad23
});
var base6423 = rfc464824({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad23 = rfc464824({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url23 = rfc464824({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad23 = rfc464824({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/webrtc/node_modules/@libp2p/logger/dist/src/index.js
import_debug14.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc24.baseEncode(v);
};
import_debug14.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3223.baseEncode(v);
};
import_debug14.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6423.baseEncode(v);
};
import_debug14.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug14.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug14.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug14.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger16(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger16, "createDisabledLogger");
function logger17(name14) {
  let trace = createDisabledLogger16(`${name14}:trace`);
  if (import_debug14.default.enabled(`${name14}:trace`) && import_debug14.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug14.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug14.default)(name14), {
    error: (0, import_debug14.default)(`${name14}:error`),
    trace
  });
}
__name(logger17, "logger");

// node_modules/@libp2p/webrtc/dist/src/error.js
var codes7;
(function(codes8) {
  codes8["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes8["ERR_DATA_CHANNEL"] = "ERR_DATA_CHANNEL";
  codes8["ERR_CONNECTION_CLOSED"] = "ERR_CONNECTION_CLOSED";
  codes8["ERR_HASH_NOT_SUPPORTED"] = "ERR_HASH_NOT_SUPPORTED";
  codes8["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes8["ERR_INVALID_FINGERPRINT"] = "ERR_INVALID_FINGERPRINT";
  codes8["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes8["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes8["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes8["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
})(codes7 || (codes7 = {}));
var WebRTCTransportError = class extends CodeError {
  static {
    __name(this, "WebRTCTransportError");
  }
  constructor(msg, code16) {
    super(`WebRTC transport error: ${msg}`, code16 ?? "");
    this.name = "WebRTCTransportError";
  }
};
var DataChannelError = class extends WebRTCTransportError {
  static {
    __name(this, "DataChannelError");
  }
  constructor(streamLabel, msg) {
    super(`[stream: ${streamLabel}] data channel error: ${msg}`, codes7.ERR_DATA_CHANNEL);
    this.name = "WebRTC/DataChannelError";
  }
};
function dataChannelError(streamLabel, msg) {
  return new DataChannelError(streamLabel, msg);
}
__name(dataChannelError, "dataChannelError");
var InappropriateMultiaddrError = class extends WebRTCTransportError {
  static {
    __name(this, "InappropriateMultiaddrError");
  }
  constructor(msg) {
    super(`There was a problem with the Multiaddr which was passed in: ${msg}`, codes7.ERR_INVALID_MULTIADDR);
    this.name = "WebRTC/InappropriateMultiaddrError";
  }
};
function inappropriateMultiaddr(msg) {
  return new InappropriateMultiaddrError(msg);
}
__name(inappropriateMultiaddr, "inappropriateMultiaddr");
var InvalidArgumentError = class extends WebRTCTransportError {
  static {
    __name(this, "InvalidArgumentError");
  }
  constructor(msg) {
    super(`There was a problem with a provided argument: ${msg}`, codes7.ERR_INVALID_PARAMETERS);
    this.name = "WebRTC/InvalidArgumentError";
  }
};
function invalidArgument(msg) {
  return new InvalidArgumentError(msg);
}
__name(invalidArgument, "invalidArgument");
var InvalidFingerprintError = class extends WebRTCTransportError {
  static {
    __name(this, "InvalidFingerprintError");
  }
  constructor(fingerprint, source) {
    super(`Invalid fingerprint "${fingerprint}" within ${source}`, codes7.ERR_INVALID_FINGERPRINT);
    this.name = "WebRTC/InvalidFingerprintError";
  }
};
function invalidFingerprint(fingerprint, source) {
  return new InvalidFingerprintError(fingerprint, source);
}
__name(invalidFingerprint, "invalidFingerprint");
var UnimplementedError = class extends WebRTCTransportError {
  static {
    __name(this, "UnimplementedError");
  }
  constructor(methodName) {
    super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`, codes7.ERR_NOT_IMPLEMENTED);
    this.name = "WebRTC/UnimplementedError";
  }
};
function unimplemented(methodName) {
  return new UnimplementedError(methodName);
}
__name(unimplemented, "unimplemented");
var UnsupportedHashAlgorithmError = class extends WebRTCTransportError {
  static {
    __name(this, "UnsupportedHashAlgorithmError");
  }
  constructor(algo) {
    super(`unsupported hash algorithm: ${algo}`, codes7.ERR_HASH_NOT_SUPPORTED);
    this.name = "WebRTC/UnsupportedHashAlgorithmError";
  }
};
function unsupportedHashAlgorithm(algorithm) {
  return new UnsupportedHashAlgorithmError(algorithm);
}
__name(unsupportedHashAlgorithm, "unsupportedHashAlgorithm");

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from46, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from46.length, ar; i < l; i++) {
      if (ar || !(i in from46)) {
        if (!ar)
          ar = Array.prototype.slice.call(from46, 0, i);
        ar[i] = from46[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from46));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name14, version4, os) {
      this.name = name14;
      this.version = version4;
      this.os = os;
      this.type = "browser";
    }
    __name(BrowserInfo2, "BrowserInfo");
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version4) {
      this.version = version4;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    __name(NodeInfo2, "NodeInfo");
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name14, version4, os, bot) {
      this.name = name14;
      this.version = version4;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    __name(SearchBotDeviceInfo2, "SearchBotDeviceInfo");
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    __name(BotInfo2, "BotInfo");
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    __name(ReactNativeInfo2, "ReactNativeInfo");
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
__name(detect, "detect");
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
__name(matchUserAgent, "matchUserAgent");
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name14 = matchedRule[0], match = matchedRule[1];
  if (name14 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version4 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name14, version4, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name14, version4, os);
}
__name(parseUserAgent, "parseUserAgent");
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
__name(detectOS, "detectOS");
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
__name(getNodeVersion, "getNodeVersion");
function createVersionParts(count) {
  var output3 = [];
  for (var ii = 0; ii < count; ii++) {
    output3.push("0");
  }
  return output3;
}
__name(createVersionParts, "createVersionParts");

// node_modules/@libp2p/webrtc/dist/src/util.js
var browser = detect();
var isFirefox = browser != null && browser.name === "firefox";
var nopSource = /* @__PURE__ */ __name(async function* nop() {
}, "nop");
var nopSink = /* @__PURE__ */ __name(async (_) => {
}, "nopSink");

// node_modules/@libp2p/webrtc/dist/src/maconn.js
var log36 = logger17("libp2p:webrtc:connection");
var WebRTCMultiaddrConnection = class {
  static {
    __name(this, "WebRTCMultiaddrConnection");
  }
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  /**
   * The multiaddr address used to communicate with the remote peer
   */
  remoteAddr;
  /**
   * Holds the lifecycle times of the connection
   */
  timeline;
  /**
   * Optional metrics counter group for this connection
   */
  metrics;
  /**
   * The stream source, a no-op as the transport natively supports multiplexing
   */
  source = nopSource();
  /**
   * The stream destination, a no-op as the transport natively supports multiplexing
   */
  sink = nopSink;
  constructor(init) {
    this.remoteAddr = init.remoteAddr;
    this.timeline = init.timeline;
    this.peerConnection = init.peerConnection;
    this.peerConnection.onconnectionstatechange = () => {
      if (this.peerConnection.connectionState === "closed" || this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed") {
        this.timeline.close = Date.now();
      }
    };
  }
  async close(err) {
    if (err !== void 0) {
      log36.error("error closing connection", err);
    }
    log36.trace("closing connection");
    this.timeline.close = Date.now();
    this.peerConnection.close();
    this.metrics?.increment({ close: true });
  }
};

// node_modules/@libp2p/webrtc/dist/src/pb/message.js
var Message4;
(function(Message7) {
  let Flag2;
  (function(Flag3) {
    Flag3["FIN"] = "FIN";
    Flag3["STOP_SENDING"] = "STOP_SENDING";
    Flag3["RESET"] = "RESET";
  })(Flag2 = Message7.Flag || (Message7.Flag = {}));
  let __FlagValues;
  (function(__FlagValues2) {
    __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
    __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
    __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
  })(__FlagValues || (__FlagValues = {}));
  (function(Flag3) {
    Flag3.codec = () => {
      return enumeration(__FlagValues);
    };
  })(Flag2 = Message7.Flag || (Message7.Flag = {}));
  let _codec;
  Message7.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.flag != null) {
          w2.uint32(8);
          Message7.Flag.codec().encode(obj.flag, w2);
        }
        if (obj.message != null) {
          w2.uint32(18);
          w2.bytes(obj.message);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.flag = Message7.Flag.codec().decode(reader2);
              break;
            case 2:
              obj.message = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message7.encode = (obj) => {
    return encodeMessage(obj, Message7.codec());
  };
  Message7.decode = (buf3) => {
    return decodeMessage(buf3, Message7.codec());
  };
})(Message4 || (Message4 = {}));

// node_modules/@libp2p/webrtc/dist/src/stream.js
var log37 = logger17("libp2p:webrtc:stream");
var MAX_MESSAGE_SIZE = 16 * 1024;
var MAX_BUFFERED_AMOUNT = 16 * 1024 * 1024;
var BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1e3;
var PROTOBUF_OVERHEAD = 3;
var WebRTCStream = class extends AbstractStream {
  static {
    __name(this, "WebRTCStream");
  }
  /**
   * The data channel used to send and receive data
   */
  channel;
  /**
   * Data channel options
   */
  dataChannelOptions;
  /**
   * push data from the underlying datachannel to the length prefix decoder
   * and then the protobuf decoder.
   */
  incomingData;
  messageQueue;
  constructor(init) {
    super(init);
    this.channel = init.channel;
    this.channel.binaryType = "arraybuffer";
    this.incomingData = pushable();
    this.messageQueue = new Uint8ArrayList();
    this.dataChannelOptions = {
      bufferedAmountLowEventTimeout: init.dataChannelOptions?.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT,
      maxBufferedAmount: init.dataChannelOptions?.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT,
      maxMessageSize: init.dataChannelOptions?.maxMessageSize ?? MAX_MESSAGE_SIZE
    };
    switch (this.channel.readyState) {
      case "open":
        break;
      case "closed":
      case "closing":
        if (this.stat.timeline.close === void 0 || this.stat.timeline.close === 0) {
          this.stat.timeline.close = Date.now();
        }
        break;
      case "connecting":
        break;
      default:
        log37.error("unknown datachannel state %s", this.channel.readyState);
        throw new CodeError("Unknown datachannel state", "ERR_INVALID_STATE");
    }
    this.channel.onopen = (_evt) => {
      this.stat.timeline.open = (/* @__PURE__ */ new Date()).getTime();
      if (this.messageQueue != null) {
        this._sendMessage(this.messageQueue).catch((err) => {
          this.abort(err);
        });
        this.messageQueue = void 0;
      }
    };
    this.channel.onclose = (_evt) => {
      this.close();
    };
    this.channel.onerror = (evt) => {
      const err = evt.error;
      this.abort(err);
    };
    const self2 = this;
    this.channel.onmessage = async (event) => {
      const { data } = event;
      if (data === null || data.byteLength === 0) {
        return;
      }
      this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
    };
    Promise.resolve().then(async () => {
      for await (const buf3 of decode21(this.incomingData)) {
        const message2 = self2.processIncomingProtobuf(buf3.subarray());
        if (message2 != null) {
          self2.sourcePush(new Uint8ArrayList(message2));
        }
      }
    }).catch((err) => {
      log37.error("error processing incoming data channel messages", err);
    });
  }
  sendNewStream() {
  }
  async _sendMessage(data, checkBuffer = true) {
    if (checkBuffer && this.channel.bufferedAmount > this.dataChannelOptions.maxBufferedAmount) {
      try {
        await pEvent(this.channel, "bufferedamountlow", { timeout: this.dataChannelOptions.bufferedAmountLowEventTimeout });
      } catch (err) {
        if (err instanceof TimeoutError2) {
          this.abort(err);
          throw new Error("Timed out waiting for DataChannel buffer to clear");
        }
        throw err;
      }
    }
    if (this.channel.readyState === "closed" || this.channel.readyState === "closing") {
      throw new CodeError("Invalid datachannel state - closed or closing", "ERR_INVALID_STATE");
    }
    if (this.channel.readyState === "open") {
      for (const buf3 of data) {
        this.channel.send(buf3);
      }
    } else if (this.channel.readyState === "connecting") {
      if (this.messageQueue == null) {
        this.messageQueue = new Uint8ArrayList();
      }
      this.messageQueue.append(data);
    } else {
      log37.error("unknown datachannel state %s", this.channel.readyState);
      throw new CodeError("Unknown datachannel state", "ERR_INVALID_STATE");
    }
  }
  async sendData(data) {
    const msgbuf = Message4.encode({ message: data.subarray() });
    const sendbuf = encode16.single(msgbuf);
    await this._sendMessage(sendbuf);
  }
  async sendReset() {
    await this._sendFlag(Message4.Flag.RESET);
  }
  async sendCloseWrite() {
    await this._sendFlag(Message4.Flag.FIN);
  }
  async sendCloseRead() {
    await this._sendFlag(Message4.Flag.STOP_SENDING);
  }
  /**
   * Handle incoming
   */
  processIncomingProtobuf(buffer3) {
    const message2 = Message4.decode(buffer3);
    if (message2.flag !== void 0) {
      if (message2.flag === Message4.Flag.FIN) {
        this.incomingData.end();
        this.closeRead();
      }
      if (message2.flag === Message4.Flag.RESET) {
        this.reset();
      }
      if (message2.flag === Message4.Flag.STOP_SENDING) {
        this.closeWrite();
      }
    }
    return message2.message;
  }
  async _sendFlag(flag) {
    log37.trace("Sending flag: %s", flag.toString());
    const msgbuf = Message4.encode({ flag });
    const prefixedBuf = encode16.single(msgbuf);
    await this._sendMessage(prefixedBuf, false);
  }
};
function createStream2(options) {
  const { channel, direction, onEnd, dataChannelOptions } = options;
  return new WebRTCStream({
    id: direction === "inbound" ? `i${channel.id}` : `r${channel.id}`,
    direction,
    maxDataSize: (dataChannelOptions?.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD,
    dataChannelOptions,
    onEnd,
    channel
  });
}
__name(createStream2, "createStream");

// node_modules/@libp2p/webrtc/dist/src/muxer.js
var PROTOCOL = "/webrtc";
var DataChannelMuxerFactory = class {
  static {
    __name(this, "DataChannelMuxerFactory");
  }
  protocol;
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  streamBuffer = [];
  metrics;
  dataChannelOptions;
  constructor(init) {
    this.peerConnection = init.peerConnection;
    this.metrics = init.metrics;
    this.protocol = init.protocol ?? PROTOCOL;
    this.dataChannelOptions = init.dataChannelOptions;
    this.peerConnection.ondatachannel = ({ channel }) => {
      const stream = createStream2({
        channel,
        direction: "inbound",
        dataChannelOptions: init.dataChannelOptions,
        onEnd: () => {
          this.streamBuffer = this.streamBuffer.filter((s2) => s2.id !== stream.id);
        }
      });
      this.streamBuffer.push(stream);
    };
  }
  createStreamMuxer(init) {
    return new DataChannelMuxer({
      ...init,
      peerConnection: this.peerConnection,
      dataChannelOptions: this.dataChannelOptions,
      metrics: this.metrics,
      streams: this.streamBuffer,
      protocol: this.protocol
    });
  }
};
var DataChannelMuxer = class {
  static {
    __name(this, "DataChannelMuxer");
  }
  init;
  /**
   * Array of streams in the data channel
   */
  streams;
  protocol;
  peerConnection;
  dataChannelOptions;
  metrics;
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  close = () => {
  };
  /**
   * The stream source, a no-op as the transport natively supports multiplexing
   */
  source = nopSource();
  /**
   * The stream destination, a no-op as the transport natively supports multiplexing
   */
  sink = nopSink;
  constructor(init) {
    this.init = init;
    this.streams = init.streams;
    this.peerConnection = init.peerConnection;
    this.protocol = init.protocol ?? PROTOCOL;
    this.metrics = init.metrics;
    this.peerConnection.ondatachannel = ({ channel }) => {
      const stream = createStream2({
        channel,
        direction: "inbound",
        dataChannelOptions: this.dataChannelOptions,
        onEnd: () => {
          this.streams = this.streams.filter((s2) => s2.id !== stream.id);
          this.metrics?.increment({ stream_end: true });
          init?.onStreamEnd?.(stream);
        }
      });
      this.streams.push(stream);
      if (init?.onIncomingStream != null) {
        this.metrics?.increment({ incoming_stream: true });
        init.onIncomingStream(stream);
      }
    };
    const onIncomingStream = init?.onIncomingStream;
    if (onIncomingStream != null) {
      this.streams.forEach((s2) => {
        onIncomingStream(s2);
      });
    }
  }
  newStream() {
    const channel = this.peerConnection.createDataChannel("");
    const stream = createStream2({
      channel,
      direction: "outbound",
      dataChannelOptions: this.dataChannelOptions,
      onEnd: () => {
        this.streams = this.streams.filter((s2) => s2.id !== stream.id);
        this.metrics?.increment({ stream_end: true });
        this.init?.onStreamEnd?.(stream);
      }
    });
    this.streams.push(stream);
    this.metrics?.increment({ outgoing_stream: true });
    return stream;
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
var Message5;
(function(Message7) {
  let Type3;
  (function(Type4) {
    Type4["SDP_OFFER"] = "SDP_OFFER";
    Type4["SDP_ANSWER"] = "SDP_ANSWER";
    Type4["ICE_CANDIDATE"] = "ICE_CANDIDATE";
  })(Type3 = Message7.Type || (Message7.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
    __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
    __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = Message7.Type || (Message7.Type = {}));
  let _codec;
  Message7.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          Message7.Type.codec().encode(obj.type, w2);
        }
        if (obj.data != null) {
          w2.uint32(18);
          w2.string(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message7.Type.codec().decode(reader2);
              break;
            case 2:
              obj.data = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message7.encode = (obj) => {
    return encodeMessage(obj, Message7.codec());
  };
  Message7.decode = (buf3) => {
    return decodeMessage(buf3, Message7.codec());
  };
})(Message5 || (Message5 = {}));

// node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
var log38 = logger17("libp2p:webrtc:peer:util");
var readCandidatesUntilConnected = /* @__PURE__ */ __name(async (connectedPromise, pc, stream) => {
  while (true) {
    const readResult = await Promise.race([connectedPromise.promise, stream.read()]);
    if (readResult instanceof Object) {
      const message2 = readResult;
      if (message2.type !== Message5.Type.ICE_CANDIDATE) {
        throw new Error("expected only ice candidates");
      }
      if (message2.data == null || message2.data === "") {
        log38.trace("end-of-candidates received");
        break;
      }
      log38.trace("received new ICE candidate: %s", message2.data);
      try {
        await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(message2.data)));
      } catch (err) {
        log38.error("bad candidate received: ", err);
        throw new Error("bad candidate received");
      }
    } else {
      break;
    }
  }
  await connectedPromise.promise;
}, "readCandidatesUntilConnected");
function resolveOnConnected(pc, promise) {
  pc[isFirefox ? "oniceconnectionstatechange" : "onconnectionstatechange"] = (_) => {
    log38.trace("receiver peerConnectionState state: ", pc.connectionState);
    switch (isFirefox ? pc.iceConnectionState : pc.connectionState) {
      case "connected":
        promise.resolve();
        break;
      case "failed":
      case "disconnected":
      case "closed":
        promise.reject(new Error("RTCPeerConnection was closed"));
        break;
      default:
        break;
    }
  };
}
__name(resolveOnConnected, "resolveOnConnected");

// node_modules/@libp2p/webrtc/dist/src/private-to-private/handler.js
var DEFAULT_TIMEOUT = 30 * 1e3;
var log39 = logger17("libp2p:webrtc:peer");
async function handleIncomingStream({ rtcConfiguration, dataChannelOptions, stream: rawStream }) {
  const signal = AbortSignal.timeout(DEFAULT_TIMEOUT);
  const stream = pbStream(abortableDuplex(rawStream, signal)).pb(Message5);
  const pc = new RTCPeerConnection(rtcConfiguration);
  const muxerFactory = new DataChannelMuxerFactory({ peerConnection: pc, dataChannelOptions });
  const connectedPromise = pDefer();
  const answerSentPromise = pDefer();
  signal.onabort = () => {
    connectedPromise.reject();
  };
  pc.onicecandidate = ({ candidate }) => {
    answerSentPromise.promise.then(() => {
      stream.write({
        type: Message5.Type.ICE_CANDIDATE,
        data: candidate != null ? JSON.stringify(candidate.toJSON()) : ""
      });
    }, (err) => {
      log39.error("cannot set candidate since sending answer failed", err);
    });
  };
  resolveOnConnected(pc, connectedPromise);
  const pbOffer = await stream.read();
  if (pbOffer.type !== Message5.Type.SDP_OFFER) {
    throw new Error(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
  }
  const offer = new RTCSessionDescription({
    type: "offer",
    sdp: pbOffer.data
  });
  await pc.setRemoteDescription(offer).catch((err) => {
    log39.error("could not execute setRemoteDescription", err);
    throw new Error("Failed to set remoteDescription");
  });
  const answer = await pc.createAnswer().catch((err) => {
    log39.error("could not execute createAnswer", err);
    answerSentPromise.reject(err);
    throw new Error("Failed to create answer");
  });
  stream.write({ type: Message5.Type.SDP_ANSWER, data: answer.sdp });
  await pc.setLocalDescription(answer).catch((err) => {
    log39.error("could not execute setLocalDescription", err);
    answerSentPromise.reject(err);
    throw new Error("Failed to set localDescription");
  });
  answerSentPromise.resolve();
  await readCandidatesUntilConnected(connectedPromise, pc, stream);
  const remoteAddress = parseRemoteAddress(pc.currentRemoteDescription?.sdp ?? "");
  return { pc, muxerFactory, remoteAddress };
}
__name(handleIncomingStream, "handleIncomingStream");
async function initiateConnection({ rtcConfiguration, dataChannelOptions, signal, stream: rawStream }) {
  const stream = pbStream(abortableDuplex(rawStream, signal)).pb(Message5);
  const pc = new RTCPeerConnection(rtcConfiguration);
  const muxerFactory = new DataChannelMuxerFactory({ peerConnection: pc, dataChannelOptions });
  const connectedPromise = pDefer();
  resolveOnConnected(pc, connectedPromise);
  signal.onabort = connectedPromise.reject;
  const channel = pc.createDataChannel("init");
  pc.onicecandidate = ({ candidate }) => {
    stream.write({
      type: Message5.Type.ICE_CANDIDATE,
      data: candidate != null ? JSON.stringify(candidate.toJSON()) : ""
    });
  };
  const offerSdp = await pc.createOffer();
  stream.write({ type: Message5.Type.SDP_OFFER, data: offerSdp.sdp });
  await pc.setLocalDescription(offerSdp).catch((err) => {
    log39.error("could not execute setLocalDescription", err);
    throw new Error("Failed to set localDescription");
  });
  const answerMessage = await stream.read();
  if (answerMessage.type !== Message5.Type.SDP_ANSWER) {
    throw new Error("remote should send an SDP answer");
  }
  const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
  await pc.setRemoteDescription(answerSdp).catch((err) => {
    log39.error("could not execute setRemoteDescription", err);
    throw new Error("Failed to set remoteDescription");
  });
  await readCandidatesUntilConnected(connectedPromise, pc, stream);
  channel.close();
  const remoteAddress = parseRemoteAddress(pc.currentRemoteDescription?.sdp ?? "");
  return { pc, muxerFactory, remoteAddress };
}
__name(initiateConnection, "initiateConnection");
function parseRemoteAddress(sdp) {
  const candidateLine = sdp.split("\r\n").filter((line) => line.startsWith("a=candidate")).pop();
  const candidateParts = candidateLine?.split(" ");
  if (candidateLine == null || candidateParts == null || candidateParts.length < 5) {
    log39("could not parse remote address from", candidateLine);
    return "/webrtc";
  }
  return `/dnsaddr/${candidateParts[4]}/${candidateParts[2].toLowerCase()}/${candidateParts[3]}/webrtc`;
}
__name(parseRemoteAddress, "parseRemoteAddress");

// node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
var WebRTCPeerListener = class extends EventEmitter6 {
  static {
    __name(this, "WebRTCPeerListener");
  }
  peerId;
  transportManager;
  constructor(opts) {
    super();
    this.peerId = opts.peerId;
    this.transportManager = opts.transportManager;
  }
  async listen() {
    this.safeDispatchEvent("listening", {});
  }
  getAddrs() {
    return this.transportManager.getListeners().filter((l) => l !== this).map((l) => l.getAddrs().filter((ma) => Circuit.matches(ma)).map((ma) => {
      return ma.encapsulate(`/webrtc/p2p/${this.peerId}`);
    })).flat();
  }
  async close() {
    this.safeDispatchEvent("close", {});
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
var log40 = logger17("libp2p:webrtc:peer");
var WEBRTC_TRANSPORT = "/webrtc";
var CIRCUIT_RELAY_TRANSPORT = "/p2p-circuit";
var SIGNALING_PROTO_ID = "/webrtc-signaling/0.0.1";
var WEBRTC_CODE = getProtocol("webrtc").code;
var WebRTCTransport = class {
  static {
    __name(this, "WebRTCTransport");
  }
  components;
  init;
  _started = false;
  constructor(components, init = {}) {
    this.components = components;
    this.init = init;
  }
  isStarted() {
    return this._started;
  }
  async start() {
    await this.components.registrar.handle(SIGNALING_PROTO_ID, (data) => {
      this._onProtocol(data).catch((err) => {
        log40.error("failed to handle incoming connect from %p", data.connection.remotePeer, err);
      });
    });
    this._started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(SIGNALING_PROTO_ID);
    this._started = false;
  }
  createListener(options) {
    return new WebRTCPeerListener(this.components);
  }
  [Symbol.toStringTag] = "@libp2p/webrtc";
  [symbol4] = true;
  filter(multiaddrs) {
    return multiaddrs.filter((ma) => {
      const codes8 = ma.protoCodes();
      return codes8.includes(WEBRTC_CODE);
    });
  }
  /*
   * dial connects to a remote via the circuit relay or any other protocol
   * and proceeds to upgrade to a webrtc connection.
   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
   * For a circuit relay, this will be of the form
   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
  */
  async dial(ma, options) {
    log40.trace("dialing address: ", ma);
    const { baseAddr, peerId } = splitAddr(ma);
    if (options.signal == null) {
      const controller = new AbortController();
      options.signal = controller.signal;
    }
    const connection = await this.components.transportManager.dial(baseAddr, options);
    const signalingStream = await connection.newStream([SIGNALING_PROTO_ID], options);
    try {
      const { pc, muxerFactory, remoteAddress } = await initiateConnection({
        stream: signalingStream,
        rtcConfiguration: this.init.rtcConfiguration,
        dataChannelOptions: this.init.dataChannel,
        signal: options.signal
      });
      const result = await options.upgrader.upgradeOutbound(new WebRTCMultiaddrConnection({
        peerConnection: pc,
        timeline: { open: Date.now() },
        remoteAddr: multiaddr(remoteAddress).encapsulate(`/p2p/${peerId.toString()}`)
      }), {
        skipProtection: true,
        skipEncryption: true,
        muxerFactory
      });
      signalingStream.close();
      return result;
    } catch (err) {
      signalingStream.reset();
      throw err;
    } finally {
      await connection.close();
    }
  }
  async _onProtocol({ connection, stream }) {
    try {
      const { pc, muxerFactory, remoteAddress } = await handleIncomingStream({
        rtcConfiguration: this.init.rtcConfiguration,
        connection,
        stream,
        dataChannelOptions: this.init.dataChannel
      });
      await this.components.upgrader.upgradeInbound(new WebRTCMultiaddrConnection({
        peerConnection: pc,
        timeline: { open: (/* @__PURE__ */ new Date()).getTime() },
        remoteAddr: multiaddr(remoteAddress).encapsulate(`/p2p/${connection.remotePeer.toString()}`)
      }), {
        skipEncryption: true,
        skipProtection: true,
        muxerFactory
      });
    } catch (err) {
      stream.reset();
      throw err;
    } finally {
      await connection.close();
    }
  }
};
function splitAddr(ma) {
  const addrs = ma.toString().split(WEBRTC_TRANSPORT + "/");
  if (addrs.length !== 2) {
    throw new CodeError("webrtc protocol was not present in multiaddr", codes7.ERR_INVALID_MULTIADDR);
  }
  if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) {
    throw new CodeError("p2p-circuit protocol was not present in multiaddr", codes7.ERR_INVALID_MULTIADDR);
  }
  let remoteAddr = multiaddr(addrs[0]);
  const destination = multiaddr("/" + addrs[1]);
  const destinationIdString = destination.getPeerId();
  if (destinationIdString == null) {
    throw new CodeError("destination peer id was missing", codes7.ERR_INVALID_MULTIADDR);
  }
  const lastProtoInRemote = remoteAddr.protos().pop();
  if (lastProtoInRemote === void 0) {
    throw new CodeError("invalid multiaddr", codes7.ERR_INVALID_MULTIADDR);
  }
  if (lastProtoInRemote.name !== "p2p") {
    remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);
  }
  return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) };
}
__name(splitAddr, "splitAddr");

// node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js
var multihashes2 = __toESM(require_src4(), 1);

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/identity.js
var identity_exports15 = {};
__export(identity_exports15, {
  identity: () => identity17
});
var identity17 = from35({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString13(buf3),
  decode: (str) => fromString12(str)
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base2.js
var base2_exports8 = {};
__export(base2_exports8, {
  base2: () => base211
});
var base211 = rfc464824({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base8.js
var base8_exports8 = {};
__export(base8_exports8, {
  base8: () => base88
});
var base88 = rfc464824({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base10.js
var base10_exports8 = {};
__export(base10_exports8, {
  base10: () => base108
});
var base108 = baseX24({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base16.js
var base16_exports8 = {};
__export(base16_exports8, {
  base16: () => base168,
  base16upper: () => base16upper8
});
var base168 = rfc464824({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper8 = rfc464824({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base36.js
var base36_exports8 = {};
__export(base36_exports8, {
  base36: () => base369,
  base36upper: () => base36upper9
});
var base369 = baseX24({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper9 = baseX24({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports8 = {};
__export(base256emoji_exports8, {
  base256emoji: () => base256emoji8
});
var alphabet8 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars8 = (
  /** @type {string[]} */
  alphabet8.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes8 = (
  /** @type {number[]} */
  alphabet8.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode63(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars8[c];
    return p;
  }, "");
}
__name(encode63, "encode");
function decode76(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes8[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode76, "decode");
var base256emoji8 = from35({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode63,
  decode: decode76
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports8 = {};
__export(sha2_browser_exports8, {
  sha256: () => sha25614,
  sha512: () => sha51214
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/vendor/varint.js
var encode_115 = encode64;
var MSB17 = 128;
var REST17 = 127;
var MSBALL15 = ~REST17;
var INT15 = Math.pow(2, 31);
function encode64(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT15) {
    out[offset++] = num & 255 | MSB17;
    num /= 128;
  }
  while (num & MSBALL15) {
    out[offset++] = num & 255 | MSB17;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode64.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode64, "encode");
var decode77 = read17;
var MSB$115 = 128;
var REST$115 = 127;
function read17(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read17.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$115) << shift : (b & REST$115) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$115);
  read17.bytes = counter - offset;
  return res;
}
__name(read17, "read");
var N118 = Math.pow(2, 7);
var N218 = Math.pow(2, 14);
var N318 = Math.pow(2, 21);
var N418 = Math.pow(2, 28);
var N518 = Math.pow(2, 35);
var N618 = Math.pow(2, 42);
var N718 = Math.pow(2, 49);
var N817 = Math.pow(2, 56);
var N917 = Math.pow(2, 63);
var length17 = /* @__PURE__ */ __name(function(value) {
  return value < N118 ? 1 : value < N218 ? 2 : value < N318 ? 3 : value < N418 ? 4 : value < N518 ? 5 : value < N618 ? 6 : value < N718 ? 7 : value < N817 ? 8 : value < N917 ? 9 : 10;
}, "length");
var varint18 = {
  encode: encode_115,
  decode: decode77,
  encodingLength: length17
};
var _brrp_varint15 = varint18;
var varint_default15 = _brrp_varint15;

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/varint.js
var decode78 = /* @__PURE__ */ __name((data, offset = 0) => {
  const code16 = varint_default15.decode(data, offset);
  return [code16, varint_default15.decode.bytes];
}, "decode");
var encodeTo15 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default15.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength16 = /* @__PURE__ */ __name((int) => {
  return varint_default15.encodingLength(int);
}, "encodingLength");

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/digest.js
var create17 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength16(code16);
  const digestOffset = sizeOffset + encodingLength16(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo15(code16, bytes3, 0);
  encodeTo15(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest15(code16, size, digest13, bytes3);
}, "create");
var decode79 = /* @__PURE__ */ __name((multihash) => {
  const bytes3 = coerce26(multihash);
  const [code16, sizeOffset] = decode78(bytes3);
  const [size, digestOffset] = decode78(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest15(code16, size, digest13, bytes3);
}, "decode");
var equals30 = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals27(a.bytes, data.bytes);
  }
}, "equals");
var Digest15 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/hasher.js
var from38 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher13(name14, code16, encode79), "from");
var Hasher13 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create17(this.code, result) : result.then((digest13) => create17(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/sha2-browser.js
var sha13 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha25614 = from38({
  name: "sha2-256",
  code: 18,
  encode: sha13("SHA-256")
});
var sha51214 = from38({
  name: "sha2-512",
  code: 19,
  encode: sha13("SHA-512")
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/hashes/identity.js
var identity_exports16 = {};
__export(identity_exports16, {
  identity: () => identity18
});
var code13 = 0;
var name10 = "identity";
var encode65 = coerce26;
var digest10 = /* @__PURE__ */ __name((input) => create17(code13, encode65(input)), "digest");
var identity18 = { code: code13, name: name10, encode: encode65, digest: digest10 };

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/codecs/json.js
var textEncoder11 = new TextEncoder();
var textDecoder10 = new TextDecoder();

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/cid.js
var format10 = /* @__PURE__ */ __name((link, base42) => {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV011(
        bytes3,
        baseCache10(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base42 || base58btc24.encoder
      );
    default:
      return toStringV111(
        bytes3,
        baseCache10(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base42 || base3223.encoder
      );
  }
}, "format");
var cache12 = /* @__PURE__ */ new WeakMap();
var baseCache10 = /* @__PURE__ */ __name((cid) => {
  const baseCache14 = cache12.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache12.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}, "baseCache");
var CID11 = class _CID {
  static {
    __name(this, "CID");
  }
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE11) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE11) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create17(code16, digest13);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals30(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base42) {
    return format10(this, base42);
  }
  toJSON() {
    return { "/": format10(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(
        version4,
        code16,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes3 || encodeCID11(version4, code16, multihash.bytes)
      );
    } else if (value[cidSymbol11] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode79(multihash)
      );
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE11) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE11}) block encoding`
          );
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID11(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE11, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce26(
      bytes3.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest13 = new Digest15(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest13
    ) : _CID.createV1(specs.codec, digest13);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode78(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE11
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes11(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache10(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes11 = /* @__PURE__ */ __name((source, base42) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 || base58btc24;
      return [
        /** @type {Prefix} */
        base58btc24.prefix,
        decoder.decode(`${base58btc24.prefix}${source}`)
      ];
    }
    case base58btc24.prefix: {
      const decoder = base42 || base58btc24;
      return [
        /** @type {Prefix} */
        base58btc24.prefix,
        decoder.decode(source)
      ];
    }
    case base3223.prefix: {
      const decoder = base42 || base3223;
      return [
        /** @type {Prefix} */
        base3223.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base42 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base42.decode(source)
      ];
    }
  }
}, "parseCIDtoBytes");
var toStringV011 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  if (prefix !== base58btc24.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV0");
var toStringV111 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV1");
var DAG_PB_CODE11 = 112;
var SHA_256_CODE11 = 18;
var encodeCID11 = /* @__PURE__ */ __name((version4, code16, multihash) => {
  const codeOffset = encodingLength16(version4);
  const hashOffset = codeOffset + encodingLength16(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo15(version4, bytes3, 0);
  encodeTo15(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}, "encodeCID");
var cidSymbol11 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/webrtc/node_modules/multiformats/src/basics.js
var bases8 = { ...identity_exports15, ...base2_exports8, ...base8_exports8, ...base10_exports8, ...base16_exports8, ...base32_exports7, ...base36_exports8, ...base58_exports7, ...base64_exports7, ...base256emoji_exports8 };
var hashes8 = { ...sha2_browser_exports8, ...identity_exports16 };

// node_modules/@libp2p/webrtc/dist/src/private-to-public/sdp.js
var multihashes = __toESM(require_src4(), 1);
var log41 = logger17("libp2p:webrtc:sdp");
var mbdecoder = Object.values(bases8).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
function getLocalFingerprint(pc) {
  const localCert = pc.getConfiguration().certificates?.at(0);
  if (localCert == null || localCert.getFingerprints == null) {
    log41.trace("fetching fingerprint from local SDP");
    const localDescription = pc.localDescription;
    if (localDescription == null) {
      return void 0;
    }
    return getFingerprintFromSdp(localDescription.sdp);
  }
  log41.trace("fetching fingerprint from local certificate");
  if (localCert.getFingerprints().length === 0) {
    return void 0;
  }
  const fingerprint = localCert.getFingerprints()[0].value;
  if (fingerprint == null) {
    throw invalidFingerprint("", "no fingerprint on local certificate");
  }
  return fingerprint;
}
__name(getLocalFingerprint, "getLocalFingerprint");
var fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
function getFingerprintFromSdp(sdp) {
  const searchResult = sdp.match(fingerprintRegex);
  return searchResult?.groups?.fingerprint;
}
__name(getFingerprintFromSdp, "getFingerprintFromSdp");
function ipv(ma) {
  for (const proto of ma.protoNames()) {
    if (proto.startsWith("ip")) {
      return proto.toUpperCase();
    }
  }
  log41("Warning: multiaddr does not appear to contain IP4 or IP6, defaulting to IP6", ma);
  return "IP6";
}
__name(ipv, "ipv");
function certhash(ma) {
  const tups = ma.stringTuples();
  const certhash2 = tups.filter((tup) => tup[0] === CERTHASH_CODE).map((tup) => tup[1])[0];
  if (certhash2 === void 0 || certhash2 === "") {
    throw inappropriateMultiaddr(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
  }
  return certhash2;
}
__name(certhash, "certhash");
function decodeCerthash(certhash2) {
  const mbdecoded = mbdecoder.decode(certhash2);
  return multihashes.decode(mbdecoded);
}
__name(decodeCerthash, "decodeCerthash");
function ma2Fingerprint(ma) {
  const mhdecoded = decodeCerthash(certhash(ma));
  const prefix = toSupportedHashFunction(mhdecoded.name);
  const fingerprint = mhdecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  const sdp = fingerprint.match(/.{1,2}/g);
  if (sdp == null) {
    throw invalidFingerprint(fingerprint, ma.toString());
  }
  return [`${prefix.toUpperCase()} ${sdp.join(":").toUpperCase()}`, fingerprint];
}
__name(ma2Fingerprint, "ma2Fingerprint");
function toSupportedHashFunction(name14) {
  switch (name14) {
    case "sha1":
      return "sha-1";
    case "sha2-256":
      return "sha-256";
    case "sha2-512":
      return "sha-512";
    default:
      throw unsupportedHashAlgorithm(name14);
  }
}
__name(toSupportedHashFunction, "toSupportedHashFunction");
function ma2sdp(ma, ufrag) {
  const { host, port } = ma.toOptions();
  const ipVersion = ipv(ma);
  const [CERTFP] = ma2Fingerprint(ma);
  return `v=0
o=- 0 0 IN ${ipVersion} ${host}
s=-
c=IN ${ipVersion} ${host}
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${CERTFP}
a=sctp-port:5000
a=max-message-size:100000
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host\r
`;
}
__name(ma2sdp, "ma2sdp");
function fromMultiAddr(ma, ufrag) {
  return {
    type: "answer",
    sdp: ma2sdp(ma, ufrag)
  };
}
__name(fromMultiAddr, "fromMultiAddr");
function munge(desc, ufrag) {
  if (desc.sdp === void 0) {
    throw invalidArgument("Can't munge a missing SDP");
  }
  desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + "\n").replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + "\n");
  return desc;
}
__name(munge, "munge");

// node_modules/@libp2p/webrtc/dist/src/private-to-public/util.js
var charset = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var genUfrag = /* @__PURE__ */ __name((len) => [...Array(len)].map(() => charset.at(Math.floor(Math.random() * charset.length))).join(""), "genUfrag");

// node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js
var log42 = logger17("libp2p:webrtc:transport");
var HANDSHAKE_TIMEOUT_MS = 1e4;
var WEBRTC_CODE2 = getProtocol("webrtc-direct").code;
var CERTHASH_CODE = getProtocol("certhash").code;
var WebRTCDirectTransport = class {
  static {
    __name(this, "WebRTCDirectTransport");
  }
  metrics;
  components;
  init;
  constructor(components, init = {}) {
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC dial events by type"
        })
      };
    }
  }
  /**
   * Dial a given multiaddr
   */
  async dial(ma, options) {
    const rawConn = await this._connect(ma, options);
    log42(`dialing address - ${ma.toString()}`);
    return rawConn;
  }
  /**
   * Create transport listeners no supported by browsers
   */
  createListener(options) {
    throw unimplemented("WebRTCTransport.createListener");
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid addresses for the transport
   */
  filter(multiaddrs) {
    return multiaddrs.filter(validMa);
  }
  /**
   * Implement toString() for WebRTCTransport
   */
  [Symbol.toStringTag] = "@libp2p/webrtc-direct";
  /**
   * Symbol.for('@libp2p/transport')
   */
  [symbol4] = true;
  /**
   * Connect to a peer using a multiaddr
   */
  async _connect(ma, options) {
    const controller = new AbortController();
    const signal = controller.signal;
    const remotePeerString = ma.getPeerId();
    if (remotePeerString === null) {
      throw inappropriateMultiaddr("we need to have the remote's PeerId");
    }
    const theirPeerId = peerIdFromString(remotePeerString);
    const remoteCerthash = decodeCerthash(certhash(ma));
    const certificate = await RTCPeerConnection.generateCertificate({
      name: "ECDSA",
      namedCurve: "P-256",
      hash: toSupportedHashFunction(remoteCerthash.name)
    });
    const peerConnection = new RTCPeerConnection({ certificates: [certificate] });
    const dataChannelOpenPromise = new Promise((resolve, reject) => {
      const handshakeDataChannel2 = peerConnection.createDataChannel("", { negotiated: true, id: 0 });
      const handshakeTimeout = setTimeout(() => {
        const error = `Data channel was never opened: state: ${handshakeDataChannel2.readyState}`;
        log42.error(error);
        this.metrics?.dialerEvents.increment({ open_error: true });
        reject(dataChannelError("data", error));
      }, HANDSHAKE_TIMEOUT_MS);
      handshakeDataChannel2.onopen = (_) => {
        clearTimeout(handshakeTimeout);
        resolve(handshakeDataChannel2);
      };
      handshakeDataChannel2.onerror = (event) => {
        clearTimeout(handshakeTimeout);
        const errorTarget = event.target?.toString() ?? "not specified";
        const error = `Error opening a data channel for handshaking: ${errorTarget}`;
        log42.error(error);
        this.metrics?.dialerEvents.increment({ unknown_error: true });
        reject(dataChannelError("data", error));
      };
    });
    const ufrag = "libp2p+webrtc+v1/" + genUfrag(32);
    const offerSdp = await peerConnection.createOffer();
    const mungedOfferSdp = munge(offerSdp, ufrag);
    await peerConnection.setLocalDescription(mungedOfferSdp);
    const answerSdp = fromMultiAddr(ma, ufrag);
    await peerConnection.setRemoteDescription(answerSdp);
    const handshakeDataChannel = await dataChannelOpenPromise;
    const myPeerId = this.components.peerId;
    const fingerprintsPrologue = this.generateNoisePrologue(peerConnection, remoteCerthash.code, ma);
    const noise2 = noise({ prologueBytes: fingerprintsPrologue })();
    const wrappedChannel = createStream2({ channel: handshakeDataChannel, direction: "inbound", dataChannelOptions: this.init.dataChannel });
    const wrappedDuplex = {
      ...wrappedChannel,
      sink: wrappedChannel.sink.bind(wrappedChannel),
      source: async function* () {
        for await (const list of wrappedChannel.source) {
          for (const buf3 of list) {
            yield buf3;
          }
        }
      }()
    };
    const maConn = new WebRTCMultiaddrConnection({
      peerConnection,
      remoteAddr: ma,
      timeline: {
        open: Date.now()
      },
      metrics: this.metrics?.dialerEvents
    });
    const eventListeningName = isFirefox ? "iceconnectionstatechange" : "connectionstatechange";
    peerConnection.addEventListener(eventListeningName, () => {
      switch (peerConnection.connectionState) {
        case "failed":
        case "disconnected":
        case "closed":
          maConn.close().catch((err) => {
            log42.error("error closing connection", err);
          }).finally(() => {
            controller.abort();
          });
          break;
        default:
          break;
      }
    }, { signal });
    this.metrics?.dialerEvents.increment({ peer_connection: true });
    const muxerFactory = new DataChannelMuxerFactory({ peerConnection, metrics: this.metrics?.dialerEvents, dataChannelOptions: this.init.dataChannel });
    await noise2.secureInbound(myPeerId, wrappedDuplex, theirPeerId);
    return options.upgrader.upgradeOutbound(maConn, { skipProtection: true, skipEncryption: true, muxerFactory });
  }
  /**
   * Generate a noise prologue from the peer connection's certificate.
   * noise prologue = bytes('libp2p-webrtc-noise:') + noise-responder fingerprint + noise-initiator fingerprint
   */
  generateNoisePrologue(pc, hashCode, ma) {
    if (pc.getConfiguration().certificates?.length === 0) {
      throw invalidArgument("no local certificate");
    }
    const localFingerprint = getLocalFingerprint(pc);
    if (localFingerprint == null) {
      throw invalidArgument("no local fingerprint found");
    }
    const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
    const localFpArray = fromString7(localFpString, "hex");
    const local = multihashes2.encode(localFpArray, hashCode);
    const remote = mbdecoder.decode(certhash(ma));
    const prefix = fromString7("libp2p-webrtc-noise:");
    return concat3([prefix, local, remote]);
  }
};
function validMa(ma) {
  const codes8 = ma.protoCodes();
  return codes8.includes(WEBRTC_CODE2) && codes8.includes(CERTHASH_CODE) && ma.getPeerId() != null && !codes8.includes(getProtocol("p2p-circuit").code);
}
__name(validMa, "validMa");

// node_modules/@libp2p/webrtc/dist/src/index.js
function webRTCDirect(init) {
  return (components) => new WebRTCDirectTransport(components, init);
}
__name(webRTCDirect, "webRTCDirect");
function webRTC(init) {
  return (components) => new WebRTCTransport(components, init);
}
__name(webRTC, "webRTC");

// node_modules/@libp2p/websockets/node_modules/@libp2p/logger/dist/src/index.js
var import_debug15 = __toESM(require_browser(), 1);

// node_modules/@libp2p/websockets/node_modules/multiformats/vendor/base-x.js
function base38(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base38, "base");
var src26 = base38;
var _brrp__multiformats_scope_baseX26 = src26;
var base_x_default26 = _brrp__multiformats_scope_baseX26;

// node_modules/@libp2p/websockets/node_modules/multiformats/src/bytes.js
var empty28 = new Uint8Array(0);
var coerce28 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/websockets/node_modules/multiformats/src/bases/base.js
var Encoder27 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder28 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or27(this, decoder);
  }
};
var ComposedDecoder26 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or27(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or27 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder26(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec26 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder27(name14, prefix, baseEncode);
    this.decoder = new Decoder28(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from39 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec26(name14, prefix, encode79, decode97), "from");
var baseX26 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default26(alphabet11, name14);
  return from39({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce28(decode97(text))
  });
}, "baseX");
var decode81 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode67 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464826 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from39({
    prefix,
    name: name14,
    encode(input) {
      return encode67(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode81(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/websockets/node_modules/multiformats/src/bases/base58.js
var base58btc26 = baseX26({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr26 = baseX26({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/websockets/node_modules/multiformats/src/bases/base32.js
var base3225 = rfc464826({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper25 = rfc464826({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad25 = rfc464826({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper25 = rfc464826({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex25 = rfc464826({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper25 = rfc464826({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad25 = rfc464826({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper25 = rfc464826({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z25 = rfc464826({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/websockets/node_modules/multiformats/src/bases/base64.js
var base6425 = rfc464826({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad25 = rfc464826({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url25 = rfc464826({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad25 = rfc464826({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/websockets/node_modules/@libp2p/logger/dist/src/index.js
import_debug15.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc26.baseEncode(v);
};
import_debug15.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3225.baseEncode(v);
};
import_debug15.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6425.baseEncode(v);
};
import_debug15.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug15.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug15.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug15.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger17(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger17, "createDisabledLogger");
function logger18(name14) {
  let trace = createDisabledLogger17(`${name14}:trace`);
  if (import_debug15.default.enabled(`${name14}:trace`) && import_debug15.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug15.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug15.default)(name14), {
    error: (0, import_debug15.default)(`${name14}:error`),
    trace
  });
}
__name(logger18, "logger");

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
function extractSNI(ma) {
  let sniProtoCode;
  try {
    sniProtoCode = getProtocol("sni").code;
  } catch (e) {
    return null;
  }
  for (const [proto, value] of ma) {
    if (proto === sniProtoCode && value !== void 0) {
      return value;
    }
  }
  return null;
}
__name(extractSNI, "extractSNI");
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === getProtocol("tls").code);
}
__name(hasTLS, "hasTLS");
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[getProtocol(headProtoCode).name];
  if (interpreter === void 0) {
    throw new Error(`Can't interpret protocol ${getProtocol(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === getProtocol("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
__name(interpretNext, "interpretNext");
var interpreters = {
  ip4: (value, restMa) => value,
  ip6: (value, restMa) => {
    if (restMa.length === 0) {
      return value;
    }
    return `[${value}]`;
  },
  tcp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  udp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  dnsaddr: (value, restMa) => value,
  dns4: (value, restMa) => value,
  dns6: (value, restMa) => value,
  dns: (value, restMa) => value,
  ipfs: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/ipfs/${value}`;
  },
  p2p: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p/${value}`;
  },
  http: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `https://${sni}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  tls: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `wss://${sni}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  },
  "p2p-websocket-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head === void 0) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = getProtocol(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if (opts?.assumeHttp !== false && head[0] === getProtocol("tcp").code) {
    uri = uri.replace("tcp://", "http://");
    if (head[1] === "443" || head[1] === "80") {
      if (head[1] === "443") {
        uri = uri.replace("http://", "https://");
      }
      uri = uri.substring(0, uri.lastIndexOf(":"));
    }
  }
  return uri;
}
__name(multiaddrToUri, "multiaddrToUri");

// node_modules/it-ws/dist/src/ready.js
var ready_default = /* @__PURE__ */ __name(async (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  await new Promise((resolve, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    __name(cleanup, "cleanup");
    function handleOpen() {
      cleanup();
      resolve();
    }
    __name(handleOpen, "handleOpen");
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    __name(handleErr, "handleErr");
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
}, "default");

// node_modules/it-ws/dist/src/sink.js
var sink_default = /* @__PURE__ */ __name((socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = /* @__PURE__ */ __name(async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err) {
        if (err.message === "socket closed")
          break;
        throw err;
      }
      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
        break;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      await new Promise((resolve, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve();
          } else {
            const err = Object.assign(new Error("ws error"), { event });
            reject(err);
          }
        });
        setTimeout(() => {
          socket.close();
        });
      });
    }
  }, "sink");
  return sink;
}, "default");

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports9 = {};
__export(base10_exports9, {
  base10: () => base109
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bytes.js
var empty29 = new Uint8Array(0);
function equals31(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
__name(equals31, "equals");
function coerce29(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
__name(coerce29, "coerce");
function fromString15(str) {
  return new TextEncoder().encode(str);
}
__name(fromString15, "fromString");
function toString16(b) {
  return new TextDecoder().decode(b);
}
__name(toString16, "toString");

// node_modules/it-ws/node_modules/multiformats/dist/src/vendor/base-x.js
function base39(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base39, "base");
var src27 = base39;
var _brrp__multiformats_scope_baseX27 = src27;
var base_x_default27 = _brrp__multiformats_scope_baseX27;

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base.js
var Encoder28 = class {
  static {
    __name(this, "Encoder");
  }
  name;
  prefix;
  baseEncode;
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder29 = class {
  static {
    __name(this, "Decoder");
  }
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or28(this, decoder);
  }
};
var ComposedDecoder27 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or28(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or28(left, right) {
  return new ComposedDecoder27({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
__name(or28, "or");
var Codec27 = class {
  static {
    __name(this, "Codec");
  }
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder28(name14, prefix, baseEncode);
    this.decoder = new Decoder29(name14, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from40({ name: name14, prefix, encode: encode79, decode: decode97 }) {
  return new Codec27(name14, prefix, encode79, decode97);
}
__name(from40, "from");
function baseX27({ name: name14, prefix, alphabet: alphabet11 }) {
  const { encode: encode79, decode: decode97 } = base_x_default27(alphabet11, name14);
  return from40({
    prefix,
    name: name14,
    encode: encode79,
    decode: (text) => coerce29(decode97(text))
  });
}
__name(baseX27, "baseX");
function decode82(string8, alphabet11, bitsPerChar, name14) {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || (255 & buffer3 << 8 - bits3) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(decode82, "decode");
function encode68(data, alphabet11, bitsPerChar) {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3 !== 0) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
__name(encode68, "encode");
function rfc464827({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) {
  return from40({
    prefix,
    name: name14,
    encode(input) {
      return encode68(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode82(input, alphabet11, bitsPerChar, name14);
    }
  });
}
__name(rfc464827, "rfc4648");

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base10.js
var base109 = baseX27({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports9 = {};
__export(base16_exports9, {
  base16: () => base169,
  base16upper: () => base16upper9
});
var base169 = rfc464827({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper9 = rfc464827({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports9 = {};
__export(base2_exports9, {
  base2: () => base212
});
var base212 = rfc464827({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports9 = {};
__export(base256emoji_exports9, {
  base256emoji: () => base256emoji9
});
var alphabet9 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars9 = alphabet9.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes9 = alphabet9.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode69(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars9[c];
    return p;
  }, "");
}
__name(encode69, "encode");
function decode83(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes9[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode83, "decode");
var base256emoji9 = from40({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode69,
  decode: decode83
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports9 = {};
__export(base32_exports9, {
  base32: () => base3226,
  base32hex: () => base32hex26,
  base32hexpad: () => base32hexpad26,
  base32hexpadupper: () => base32hexpadupper26,
  base32hexupper: () => base32hexupper26,
  base32pad: () => base32pad26,
  base32padupper: () => base32padupper26,
  base32upper: () => base32upper26,
  base32z: () => base32z26
});
var base3226 = rfc464827({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper26 = rfc464827({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad26 = rfc464827({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper26 = rfc464827({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex26 = rfc464827({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper26 = rfc464827({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad26 = rfc464827({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper26 = rfc464827({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z26 = rfc464827({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports9 = {};
__export(base36_exports9, {
  base36: () => base3610,
  base36upper: () => base36upper10
});
var base3610 = baseX27({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper10 = baseX27({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports9 = {};
__export(base58_exports9, {
  base58btc: () => base58btc27,
  base58flickr: () => base58flickr27
});
var base58btc27 = baseX27({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr27 = baseX27({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports9 = {};
__export(base64_exports9, {
  base64: () => base6426,
  base64pad: () => base64pad26,
  base64url: () => base64url26,
  base64urlpad: () => base64urlpad26
});
var base6426 = rfc464827({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad26 = rfc464827({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url26 = rfc464827({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad26 = rfc464827({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports9 = {};
__export(base8_exports9, {
  base8: () => base89
});
var base89 = rfc464827({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports17 = {};
__export(identity_exports17, {
  identity: () => identity19
});
var identity19 = from40({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString16(buf3),
  decode: (str) => fromString15(str)
});

// node_modules/it-ws/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder12 = new TextEncoder();
var textDecoder11 = new TextDecoder();

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports18 = {};
__export(identity_exports18, {
  identity: () => identity20
});

// node_modules/it-ws/node_modules/multiformats/dist/src/vendor/varint.js
var encode_116 = encode70;
var MSB18 = 128;
var REST18 = 127;
var MSBALL16 = ~REST18;
var INT16 = Math.pow(2, 31);
function encode70(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT16) {
    out[offset++] = num & 255 | MSB18;
    num /= 128;
  }
  while (num & MSBALL16) {
    out[offset++] = num & 255 | MSB18;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode70.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode70, "encode");
var decode84 = read18;
var MSB$116 = 128;
var REST$116 = 127;
function read18(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read18.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$116) << shift : (b & REST$116) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$116);
  read18.bytes = counter - offset;
  return res;
}
__name(read18, "read");
var N119 = Math.pow(2, 7);
var N219 = Math.pow(2, 14);
var N319 = Math.pow(2, 21);
var N419 = Math.pow(2, 28);
var N519 = Math.pow(2, 35);
var N619 = Math.pow(2, 42);
var N719 = Math.pow(2, 49);
var N818 = Math.pow(2, 56);
var N918 = Math.pow(2, 63);
var length18 = /* @__PURE__ */ __name(function(value) {
  return value < N119 ? 1 : value < N219 ? 2 : value < N319 ? 3 : value < N419 ? 4 : value < N519 ? 5 : value < N619 ? 6 : value < N719 ? 7 : value < N818 ? 8 : value < N918 ? 9 : 10;
}, "length");
var varint19 = {
  encode: encode_116,
  decode: decode84,
  encodingLength: length18
};
var _brrp_varint16 = varint19;
var varint_default16 = _brrp_varint16;

// node_modules/it-ws/node_modules/multiformats/dist/src/varint.js
function decode85(data, offset = 0) {
  const code16 = varint_default16.decode(data, offset);
  return [code16, varint_default16.decode.bytes];
}
__name(decode85, "decode");
function encodeTo16(int, target, offset = 0) {
  varint_default16.encode(int, target, offset);
  return target;
}
__name(encodeTo16, "encodeTo");
function encodingLength17(int) {
  return varint_default16.encodingLength(int);
}
__name(encodingLength17, "encodingLength");

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/digest.js
function create18(code16, digest13) {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength17(code16);
  const digestOffset = sizeOffset + encodingLength17(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo16(code16, bytes3, 0);
  encodeTo16(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest16(code16, size, digest13, bytes3);
}
__name(create18, "create");
function decode86(multihash) {
  const bytes3 = coerce29(multihash);
  const [code16, sizeOffset] = decode85(bytes3);
  const [size, digestOffset] = decode85(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest16(code16, size, digest13, bytes3);
}
__name(decode86, "decode");
function equals32(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals31(a.bytes, data.bytes);
  }
}
__name(equals32, "equals");
var Digest16 = class {
  static {
    __name(this, "Digest");
  }
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/identity.js
var code14 = 0;
var name11 = "identity";
var encode71 = coerce29;
function digest11(input) {
  return create18(code14, encode71(input));
}
__name(digest11, "digest");
var identity20 = { code: code14, name: name11, encode: encode71, digest: digest11 };

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports9 = {};
__export(sha2_browser_exports9, {
  sha256: () => sha25615,
  sha512: () => sha51215
});

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/hasher.js
function from41({ name: name14, code: code16, encode: encode79 }) {
  return new Hasher14(name14, code16, encode79);
}
__name(from41, "from");
var Hasher14 = class {
  static {
    __name(this, "Hasher");
  }
  name;
  code;
  encode;
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create18(this.code, result) : result.then((digest13) => create18(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha14(name14) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name14, data));
}
__name(sha14, "sha");
var sha25615 = from41({
  name: "sha2-256",
  code: 18,
  encode: sha14("SHA-256")
});
var sha51215 = from41({
  name: "sha2-512",
  code: 19,
  encode: sha14("SHA-512")
});

// node_modules/it-ws/node_modules/multiformats/dist/src/cid.js
function format11(link, base42) {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV012(bytes3, baseCache11(link), base42 ?? base58btc27.encoder);
    default:
      return toStringV112(bytes3, baseCache11(link), base42 ?? base3226.encoder);
  }
}
__name(format11, "format");
var cache13 = /* @__PURE__ */ new WeakMap();
function baseCache11(cid) {
  const baseCache14 = cache13.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache13.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}
__name(baseCache11, "baseCache");
var CID12 = class _CID {
  static {
    __name(this, "CID");
  }
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE12) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE12) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create18(code16, digest13);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals32(self2.multihash, unknown.multihash);
  }
  toString(base42) {
    return format11(this, base42);
  }
  toJSON() {
    return { "/": format11(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(version4, code16, multihash, bytes3 ?? encodeCID12(version4, code16, multihash.bytes));
    } else if (value[cidSymbol12] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = decode86(multihash);
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE12) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE12}) block encoding`);
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID12(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE12, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce29(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest13 = new Digest16(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest13) : _CID.createV1(specs.codec, digest13);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode85(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = next();
    let codec = DAG_PB_CODE12;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes12(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache11(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes12(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 ?? base58btc27;
      return [
        base58btc27.prefix,
        decoder.decode(`${base58btc27.prefix}${source}`)
      ];
    }
    case base58btc27.prefix: {
      const decoder = base42 ?? base58btc27;
      return [base58btc27.prefix, decoder.decode(source)];
    }
    case base3226.prefix: {
      const decoder = base42 ?? base3226;
      return [base3226.prefix, decoder.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
__name(parseCIDtoBytes12, "parseCIDtoBytes");
function toStringV012(bytes3, cache16, base42) {
  const { prefix } = base42;
  if (prefix !== base58btc27.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV012, "toStringV0");
function toStringV112(bytes3, cache16, base42) {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
__name(toStringV112, "toStringV1");
var DAG_PB_CODE12 = 112;
var SHA_256_CODE12 = 18;
function encodeCID12(version4, code16, multihash) {
  const codeOffset = encodingLength17(version4);
  const hashOffset = codeOffset + encodingLength17(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo16(version4, bytes3, 0);
  encodeTo16(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
__name(encodeCID12, "encodeCID");
var cidSymbol12 = Symbol.for("@ipld/js-cid/CID");

// node_modules/it-ws/node_modules/multiformats/dist/src/basics.js
var bases9 = { ...identity_exports17, ...base2_exports9, ...base8_exports9, ...base10_exports9, ...base16_exports9, ...base32_exports9, ...base36_exports9, ...base58_exports9, ...base64_exports9, ...base256emoji_exports9 };
var hashes9 = { ...sha2_browser_exports9, ...identity_exports18 };

// node_modules/it-ws/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe12(size = 0) {
  return new Uint8Array(size);
}
__name(allocUnsafe12, "allocUnsafe");

// node_modules/it-ws/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec8(name14, prefix, encode79, decode97) {
  return {
    name: name14,
    prefix,
    encoder: {
      name: name14,
      prefix,
      encode: encode79
    },
    decoder: {
      decode: decode97
    }
  };
}
__name(createCodec8, "createCodec");
var string7 = createCodec8("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii7 = createCodec8("ascii", "a", (buf3) => {
  let string8 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string8 += String.fromCharCode(buf3[i]);
  }
  return string8;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe12(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES7 = {
  utf8: string7,
  "utf-8": string7,
  hex: bases9.base16,
  latin1: ascii7,
  ascii: ascii7,
  binary: ascii7,
  ...bases9
};
var bases_default7 = BASES7;

// node_modules/it-ws/node_modules/uint8arrays/dist/src/from-string.js
function fromString16(string8, encoding = "utf8") {
  const base42 = bases_default7[encoding];
  if (base42 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base42.decoder.decode(`${base42.prefix}${string8}`);
}
__name(fromString16, "fromString");

// node_modules/it-ws/dist/src/source.js
function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
__name(isArrayBuffer, "isArrayBuffer");
var source_default = /* @__PURE__ */ __name((socket) => {
  socket.binaryType = "arraybuffer";
  const connected = /* @__PURE__ */ __name(async () => {
    await new Promise((resolve, reject) => {
      if (isConnected) {
        resolve();
        return;
      }
      if (connError != null) {
        reject(connError);
        return;
      }
      const cleanUp = /* @__PURE__ */ __name((cont) => {
        socket.removeEventListener("open", onOpen);
        socket.removeEventListener("error", onError);
        cont();
      }, "cleanUp");
      const onOpen = /* @__PURE__ */ __name(() => {
        cleanUp(resolve);
      }, "onOpen");
      const onError = /* @__PURE__ */ __name((event) => {
        cleanUp(() => {
          reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
        });
      }, "onError");
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
  }, "connected");
  const source = async function* () {
    const messages2 = new import_event_iterator.EventIterator(({ push, stop, fail }) => {
      const onMessage = /* @__PURE__ */ __name((event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString16(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      }, "onMessage");
      const onError = /* @__PURE__ */ __name((event) => {
        fail(event.error ?? new Error("Socket error"));
      }, "onError");
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages2) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
}, "default");

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = /* @__PURE__ */ __name((socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => {
      await connectedSource.connected();
    },
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve) => {
          socket.addEventListener("close", () => {
            resolve();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
}, "default");

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/ws-url.js
var map2 = { "http:": "ws:", "https:": "wss:" };
var defaultProtocol = "ws:";
var ws_url_default = /* @__PURE__ */ __name((url, location) => {
  if (url.startsWith("//")) {
    url = `${location?.protocol ?? defaultProtocol}${url}`;
  }
  if (url.startsWith("/") && location != null) {
    const proto = location.protocol ?? defaultProtocol;
    const host = location.host;
    const port = location.port != null && host?.endsWith(`:${location.port}`) !== true ? `:${location.port}` : "";
    url = `${proto}//${host}${port}${url}`;
  }
  const wsUrl = new URL(url);
  for (const [httpProto, wsProto] of Object.entries(map2)) {
    if (wsUrl.protocol === httpProto) {
      wsUrl.protocol = wsProto;
    }
  }
  return wsUrl;
}, "default");

// node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location = typeof window === "undefined" ? void 0 : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location);
  const socket = new web_socket_browser_default(url.toString(), opts.websocket);
  return duplex_default(socket, opts);
}
__name(connect, "connect");

// node_modules/wherearewe/src/index.js
var import_is_electron = __toESM(require_is_electron(), 1);
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// node_modules/@libp2p/websockets/dist/src/constants.js
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CLOSE_TIMEOUT = 2e3;

// node_modules/@libp2p/websockets/dist/src/filters.js
function all2(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSockets.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
__name(all2, "all");
function wss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(testMa);
  });
}
__name(wss, "wss");

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}
__name(createListener, "createListener");

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
var log43 = logger18("libp2p:websockets:socket");
function socketToMaConn(stream, remoteAddr, options) {
  options = options ?? {};
  const maConn = {
    async sink(source) {
      if (options?.signal != null) {
        source = abortableSource(source, options.signal);
      }
      try {
        await stream.sink(source);
      } catch (err) {
        if (err.type !== "aborted") {
          log43.error(err);
        }
      }
    },
    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close() {
      const start = Date.now();
      try {
        await pTimeout2(stream.close(), {
          milliseconds: CLOSE_TIMEOUT
        });
      } catch (err) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log43("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        stream.destroy();
      } finally {
        maConn.timeline.close = Date.now();
      }
    }
  };
  stream.socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}
__name(socketToMaConn, "socketToMaConn");

// node_modules/@libp2p/websockets/dist/src/index.js
var log44 = logger18("libp2p:websockets");
var WebSockets2 = class {
  static {
    __name(this, "WebSockets");
  }
  init;
  constructor(init) {
    this.init = init;
  }
  [Symbol.toStringTag] = "@libp2p/websockets";
  [symbol4] = true;
  async dial(ma, options) {
    log44("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma);
    log44("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log44("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options?.signal?.aborted === true) {
      throw new AbortError2();
    }
    const cOpts = ma.toOptions();
    log44("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const errfn = /* @__PURE__ */ __name((err) => {
      log44.error("connection error:", err);
      errorPromise.reject(err);
    }, "errfn");
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    if (rawSocket.socket.on != null) {
      rawSocket.socket.on("error", errfn);
    } else {
      rawSocket.socket.onerror = errfn;
    }
    if (options.signal == null) {
      await Promise.race([rawSocket.connected(), errorPromise.promise]);
      log44("connected %s", ma);
      return rawSocket;
    }
    let onAbort;
    const abort = new Promise((resolve, reject) => {
      onAbort = /* @__PURE__ */ __name(() => {
        reject(new AbortError2());
        rawSocket.close().catch((err) => {
          log44.error("error closing raw socket", err);
        });
      }, "onAbort");
      if (options?.signal?.aborted === true) {
        onAbort();
        return;
      }
      options?.signal?.addEventListener("abort", onAbort);
    });
    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
    } finally {
      if (onAbort != null) {
        options?.signal?.removeEventListener("abort", onAbort);
      }
    }
    log44("connected %s", ma);
    return rawSocket;
  }
  /**
   * Creates a Websockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener({ ...this.init, ...options });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    if (isBrowser || isWebWorker) {
      return wss(multiaddrs);
    }
    return all2(multiaddrs);
  }
};
function webSockets(init = {}) {
  return () => {
    return new WebSockets2(init);
  };
}
__name(webSockets, "webSockets");

// node_modules/@libp2p/webtransport/node_modules/@libp2p/logger/dist/src/index.js
var import_debug16 = __toESM(require_browser(), 1);

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base58.js
var base58_exports10 = {};
__export(base58_exports10, {
  base58btc: () => base58btc28,
  base58flickr: () => base58flickr28
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/vendor/base-x.js
function base40(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base40, "base");
var src28 = base40;
var _brrp__multiformats_scope_baseX28 = src28;
var base_x_default28 = _brrp__multiformats_scope_baseX28;

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bytes.js
var empty30 = new Uint8Array(0);
var equals33 = /* @__PURE__ */ __name((aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}, "equals");
var coerce30 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");
var fromString17 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString");
var toString17 = /* @__PURE__ */ __name((b) => new TextDecoder().decode(b), "toString");

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base.js
var Encoder29 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder30 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or29(this, decoder);
  }
};
var ComposedDecoder28 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or29(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or29 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder28(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec28 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder29(name14, prefix, baseEncode);
    this.decoder = new Decoder30(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from42 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec28(name14, prefix, encode79, decode97), "from");
var baseX28 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default28(alphabet11, name14);
  return from42({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce30(decode97(text))
  });
}, "baseX");
var decode87 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode72 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464828 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from42({
    prefix,
    name: name14,
    encode(input) {
      return encode72(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode87(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base58.js
var base58btc28 = baseX28({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr28 = baseX28({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base32.js
var base32_exports10 = {};
__export(base32_exports10, {
  base32: () => base3227,
  base32hex: () => base32hex27,
  base32hexpad: () => base32hexpad27,
  base32hexpadupper: () => base32hexpadupper27,
  base32hexupper: () => base32hexupper27,
  base32pad: () => base32pad27,
  base32padupper: () => base32padupper27,
  base32upper: () => base32upper27,
  base32z: () => base32z27
});
var base3227 = rfc464828({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper27 = rfc464828({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad27 = rfc464828({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper27 = rfc464828({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex27 = rfc464828({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper27 = rfc464828({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad27 = rfc464828({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper27 = rfc464828({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z27 = rfc464828({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base64.js
var base64_exports10 = {};
__export(base64_exports10, {
  base64: () => base6427,
  base64pad: () => base64pad27,
  base64url: () => base64url27,
  base64urlpad: () => base64urlpad27
});
var base6427 = rfc464828({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad27 = rfc464828({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url27 = rfc464828({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad27 = rfc464828({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/webtransport/node_modules/@libp2p/logger/dist/src/index.js
import_debug16.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc28.baseEncode(v);
};
import_debug16.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3227.baseEncode(v);
};
import_debug16.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6427.baseEncode(v);
};
import_debug16.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug16.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug16.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug16.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger18(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger18, "createDisabledLogger");
function logger19(name14) {
  let trace = createDisabledLogger18(`${name14}:trace`);
  if (import_debug16.default.enabled(`${name14}:trace`) && import_debug16.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug16.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug16.default)(name14), {
    error: (0, import_debug16.default)(`${name14}:error`),
    trace
  });
}
__name(logger19, "logger");

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/identity.js
var identity_exports19 = {};
__export(identity_exports19, {
  identity: () => identity21
});
var identity21 = from42({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString17(buf3),
  decode: (str) => fromString17(str)
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base2.js
var base2_exports10 = {};
__export(base2_exports10, {
  base2: () => base213
});
var base213 = rfc464828({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base8.js
var base8_exports10 = {};
__export(base8_exports10, {
  base8: () => base810
});
var base810 = rfc464828({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base10.js
var base10_exports10 = {};
__export(base10_exports10, {
  base10: () => base1010
});
var base1010 = baseX28({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base16.js
var base16_exports10 = {};
__export(base16_exports10, {
  base16: () => base1610,
  base16upper: () => base16upper10
});
var base1610 = rfc464828({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper10 = rfc464828({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base36.js
var base36_exports10 = {};
__export(base36_exports10, {
  base36: () => base3611,
  base36upper: () => base36upper11
});
var base3611 = baseX28({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper11 = baseX28({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports10 = {};
__export(base256emoji_exports10, {
  base256emoji: () => base256emoji10
});
var alphabet10 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars10 = (
  /** @type {string[]} */
  alphabet10.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes10 = (
  /** @type {number[]} */
  alphabet10.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode73(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars10[c];
    return p;
  }, "");
}
__name(encode73, "encode");
function decode88(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes10[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode88, "decode");
var base256emoji10 = from42({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode73,
  decode: decode88
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports10 = {};
__export(sha2_browser_exports10, {
  sha256: () => sha25616,
  sha512: () => sha51216
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/digest.js
var digest_exports17 = {};
__export(digest_exports17, {
  Digest: () => Digest17,
  create: () => create19,
  decode: () => decode91,
  equals: () => equals34
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/vendor/varint.js
var encode_117 = encode74;
var MSB19 = 128;
var REST19 = 127;
var MSBALL17 = ~REST19;
var INT17 = Math.pow(2, 31);
function encode74(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT17) {
    out[offset++] = num & 255 | MSB19;
    num /= 128;
  }
  while (num & MSBALL17) {
    out[offset++] = num & 255 | MSB19;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode74.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode74, "encode");
var decode89 = read19;
var MSB$117 = 128;
var REST$117 = 127;
function read19(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read19.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$117) << shift : (b & REST$117) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$117);
  read19.bytes = counter - offset;
  return res;
}
__name(read19, "read");
var N120 = Math.pow(2, 7);
var N220 = Math.pow(2, 14);
var N320 = Math.pow(2, 21);
var N420 = Math.pow(2, 28);
var N520 = Math.pow(2, 35);
var N620 = Math.pow(2, 42);
var N720 = Math.pow(2, 49);
var N819 = Math.pow(2, 56);
var N919 = Math.pow(2, 63);
var length19 = /* @__PURE__ */ __name(function(value) {
  return value < N120 ? 1 : value < N220 ? 2 : value < N320 ? 3 : value < N420 ? 4 : value < N520 ? 5 : value < N620 ? 6 : value < N720 ? 7 : value < N819 ? 8 : value < N919 ? 9 : 10;
}, "length");
var varint20 = {
  encode: encode_117,
  decode: decode89,
  encodingLength: length19
};
var _brrp_varint17 = varint20;
var varint_default17 = _brrp_varint17;

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/varint.js
var decode90 = /* @__PURE__ */ __name((data, offset = 0) => {
  const code16 = varint_default17.decode(data, offset);
  return [code16, varint_default17.decode.bytes];
}, "decode");
var encodeTo17 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default17.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength18 = /* @__PURE__ */ __name((int) => {
  return varint_default17.encodingLength(int);
}, "encodingLength");

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/digest.js
var create19 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength18(code16);
  const digestOffset = sizeOffset + encodingLength18(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo17(code16, bytes3, 0);
  encodeTo17(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest17(code16, size, digest13, bytes3);
}, "create");
var decode91 = /* @__PURE__ */ __name((multihash) => {
  const bytes3 = coerce30(multihash);
  const [code16, sizeOffset] = decode90(bytes3);
  const [size, digestOffset] = decode90(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest17(code16, size, digest13, bytes3);
}, "decode");
var equals34 = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals33(a.bytes, data.bytes);
  }
}, "equals");
var Digest17 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/hasher.js
var from43 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher15(name14, code16, encode79), "from");
var Hasher15 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create19(this.code, result) : result.then((digest13) => create19(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/sha2-browser.js
var sha15 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha25616 = from43({
  name: "sha2-256",
  code: 18,
  encode: sha15("SHA-256")
});
var sha51216 = from43({
  name: "sha2-512",
  code: 19,
  encode: sha15("SHA-512")
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/identity.js
var identity_exports20 = {};
__export(identity_exports20, {
  identity: () => identity22
});
var code15 = 0;
var name12 = "identity";
var encode75 = coerce30;
var digest12 = /* @__PURE__ */ __name((input) => create19(code15, encode75(input)), "digest");
var identity22 = { code: code15, name: name12, encode: encode75, digest: digest12 };

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/codecs/json.js
var textEncoder13 = new TextEncoder();
var textDecoder12 = new TextDecoder();

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/cid.js
var format12 = /* @__PURE__ */ __name((link, base42) => {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV013(
        bytes3,
        baseCache12(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base42 || base58btc28.encoder
      );
    default:
      return toStringV113(
        bytes3,
        baseCache12(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base42 || base3227.encoder
      );
  }
}, "format");
var cache14 = /* @__PURE__ */ new WeakMap();
var baseCache12 = /* @__PURE__ */ __name((cid) => {
  const baseCache14 = cache14.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache14.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}, "baseCache");
var CID13 = class _CID {
  static {
    __name(this, "CID");
  }
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE13) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE13) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create19(code16, digest13);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals34(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base42) {
    return format12(this, base42);
  }
  toJSON() {
    return { "/": format12(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(
        version4,
        code16,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes3 || encodeCID13(version4, code16, multihash.bytes)
      );
    } else if (value[cidSymbol13] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode91(multihash)
      );
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE13) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE13}) block encoding`
          );
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID13(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE13, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce30(
      bytes3.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest13 = new Digest17(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest13
    ) : _CID.createV1(specs.codec, digest13);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode90(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE13
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes13(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache12(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes13 = /* @__PURE__ */ __name((source, base42) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 || base58btc28;
      return [
        /** @type {Prefix} */
        base58btc28.prefix,
        decoder.decode(`${base58btc28.prefix}${source}`)
      ];
    }
    case base58btc28.prefix: {
      const decoder = base42 || base58btc28;
      return [
        /** @type {Prefix} */
        base58btc28.prefix,
        decoder.decode(source)
      ];
    }
    case base3227.prefix: {
      const decoder = base42 || base3227;
      return [
        /** @type {Prefix} */
        base3227.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base42 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base42.decode(source)
      ];
    }
  }
}, "parseCIDtoBytes");
var toStringV013 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  if (prefix !== base58btc28.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV0");
var toStringV113 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV1");
var DAG_PB_CODE13 = 112;
var SHA_256_CODE13 = 18;
var encodeCID13 = /* @__PURE__ */ __name((version4, code16, multihash) => {
  const codeOffset = encodingLength18(version4);
  const hashOffset = codeOffset + encodingLength18(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo17(version4, bytes3, 0);
  encodeTo17(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}, "encodeCID");
var cidSymbol13 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/webtransport/node_modules/multiformats/src/basics.js
var bases10 = { ...identity_exports19, ...base2_exports10, ...base8_exports10, ...base10_exports10, ...base16_exports10, ...base32_exports10, ...base36_exports10, ...base58_exports10, ...base64_exports10, ...base256emoji_exports10 };
var hashes10 = { ...sha2_browser_exports10, ...identity_exports20 };

// node_modules/@libp2p/webtransport/dist/src/index.js
var log45 = logger19("libp2p:webtransport");
var multibaseDecoder = Object.values(bases10).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
function decodeCerthashStr(s2) {
  return digest_exports17.decode(multibaseDecoder.decode(s2));
}
__name(decodeCerthashStr, "decodeCerthashStr");
function inertDuplex() {
  return {
    source: {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            return new Promise(() => {
            });
          }
        };
      }
    },
    sink: async (source) => {
      return new Promise(() => {
      });
    }
  };
}
__name(inertDuplex, "inertDuplex");
async function webtransportBiDiStreamToStream(bidiStream, streamId, direction, activeStreams, onStreamEnd) {
  const writer = bidiStream.writable.getWriter();
  const reader2 = bidiStream.readable.getReader();
  await writer.ready;
  function cleanupStreamFromActiveStreams() {
    const index = activeStreams.findIndex((s2) => s2 === stream);
    if (index !== -1) {
      activeStreams.splice(index, 1);
      stream.stat.timeline.close = Date.now();
      onStreamEnd?.(stream);
    }
  }
  __name(cleanupStreamFromActiveStreams, "cleanupStreamFromActiveStreams");
  let writerClosed = false;
  let readerClosed = false;
  (async function() {
    const err = await writer.closed.catch((err2) => err2);
    if (err != null) {
      const msg = err.message;
      if (!(msg.includes("aborted by the remote server") || msg.includes("STOP_SENDING"))) {
        log45.error(`WebTransport writer closed unexpectedly: streamId=${streamId} err=${err.message}`);
      }
    }
    writerClosed = true;
    if (writerClosed && readerClosed) {
      cleanupStreamFromActiveStreams();
    }
  })().catch(() => {
    log45.error("WebTransport failed to cleanup closed stream");
  });
  (async function() {
    const err = await reader2.closed.catch((err2) => err2);
    if (err != null) {
      log45.error(`WebTransport reader closed unexpectedly: streamId=${streamId} err=${err.message}`);
    }
    readerClosed = true;
    if (writerClosed && readerClosed) {
      cleanupStreamFromActiveStreams();
    }
  })().catch(() => {
    log45.error("WebTransport failed to cleanup closed stream");
  });
  let sinkSunk = false;
  const stream = {
    id: streamId,
    abort(_err) {
      if (!writerClosed) {
        writer.abort();
        writerClosed = true;
      }
      stream.closeRead();
      readerClosed = true;
      cleanupStreamFromActiveStreams();
    },
    close() {
      stream.closeRead();
      stream.closeWrite();
      cleanupStreamFromActiveStreams();
    },
    closeRead() {
      if (!readerClosed) {
        reader2.cancel().catch((err) => {
          if (err.toString().includes("RESET_STREAM") === true) {
            writerClosed = true;
          }
        });
        readerClosed = true;
      }
      if (writerClosed) {
        cleanupStreamFromActiveStreams();
      }
    },
    closeWrite() {
      if (!writerClosed) {
        writerClosed = true;
        writer.close().catch((err) => {
          if (err.toString().includes("RESET_STREAM") === true) {
            readerClosed = true;
          }
        });
      }
      if (readerClosed) {
        cleanupStreamFromActiveStreams();
      }
    },
    reset() {
      stream.close();
    },
    stat: {
      direction,
      timeline: { open: Date.now() }
    },
    metadata: {},
    source: async function* () {
      while (true) {
        const val = await reader2.read();
        if (val.done === true) {
          readerClosed = true;
          if (writerClosed) {
            cleanupStreamFromActiveStreams();
          }
          return;
        }
        yield new Uint8ArrayList(val.value);
      }
    }(),
    sink: async function(source) {
      if (sinkSunk) {
        throw new Error("sink already called on stream");
      }
      sinkSunk = true;
      try {
        for await (const chunks of source) {
          if (chunks instanceof Uint8Array) {
            await writer.write(chunks);
          } else {
            for (const buf3 of chunks) {
              await writer.write(buf3);
            }
          }
        }
      } finally {
        stream.closeWrite();
      }
    }
  };
  return stream;
}
__name(webtransportBiDiStreamToStream, "webtransportBiDiStreamToStream");
function parseMultiaddr(ma) {
  const parts = ma.stringTuples();
  const { url, certhashes, remotePeer } = parts.reduce(
    (state, [proto, value]) => {
      switch (proto) {
        case getProtocol("ip6").code:
        case getProtocol("dns6").code:
          if (value?.includes(":") === true) {
            value = `[${value}]`;
          }
        case getProtocol("ip4").code:
        case getProtocol("dns4").code:
          if (state.seenHost || state.seenPort) {
            throw new Error("Invalid multiaddr, saw host and already saw the host or port");
          }
          return {
            ...state,
            url: `${state.url}${value ?? ""}`,
            seenHost: true
          };
        case getProtocol("quic").code:
        case getProtocol("quic-v1").code:
        case getProtocol("webtransport").code:
          if (!state.seenHost || !state.seenPort) {
            throw new Error("Invalid multiaddr, Didn't see host and port, but saw quic/webtransport");
          }
          return state;
        case getProtocol("udp").code:
          if (state.seenPort) {
            throw new Error("Invalid multiaddr, saw port but already saw the port");
          }
          return {
            ...state,
            url: `${state.url}:${value ?? ""}`,
            seenPort: true
          };
        case getProtocol("certhash").code:
          if (!state.seenHost || !state.seenPort) {
            throw new Error("Invalid multiaddr, saw the certhash before seeing the host and port");
          }
          return {
            ...state,
            certhashes: state.certhashes.concat([decodeCerthashStr(value ?? "")])
          };
        case getProtocol("p2p").code:
          return {
            ...state,
            remotePeer: peerIdFromString(value ?? "")
          };
        default:
          throw new Error(`unexpected component in multiaddr: ${proto} ${getProtocol(proto).name} ${value ?? ""} `);
      }
    },
    // All webtransport urls are https
    { url: "https://", seenHost: false, seenPort: false, certhashes: [] }
  );
  return { url, certhashes, remotePeer };
}
__name(parseMultiaddr, "parseMultiaddr");
function isSubset(set, maybeSubset) {
  const intersection = maybeSubset.filter((byteArray) => {
    return Boolean(set.find((otherByteArray) => {
      if (byteArray.length !== otherByteArray.length) {
        return false;
      }
      for (let index = 0; index < byteArray.length; index++) {
        if (otherByteArray[index] !== byteArray[index]) {
          return false;
        }
      }
      return true;
    }));
  });
  return intersection.length === maybeSubset.length;
}
__name(isSubset, "isSubset");
var WebTransportTransport = class {
  static {
    __name(this, "WebTransportTransport");
  }
  components;
  config;
  constructor(components, init = {}) {
    this.components = components;
    this.config = {
      maxInboundStreams: init.maxInboundStreams ?? 1e3
    };
  }
  [Symbol.toStringTag] = "@libp2p/webtransport";
  [symbol4] = true;
  async dial(ma, options) {
    log45("dialing %s", ma);
    const localPeer = this.components.peerId;
    if (localPeer === void 0) {
      throw new Error("Need a local peerid");
    }
    options = options ?? {};
    const { url, certhashes, remotePeer } = parseMultiaddr(ma);
    if (certhashes.length === 0) {
      throw new Error("Expected multiaddr to contain certhashes");
    }
    const wt = new WebTransport(`${url}/.well-known/libp2p-webtransport?type=noise`, {
      serverCertificateHashes: certhashes.map((certhash2) => ({
        algorithm: "sha-256",
        value: certhash2.digest
      }))
    });
    wt.closed.catch((error) => {
      log45.error("WebTransport transport closed due to:", error);
    });
    await wt.ready;
    if (remotePeer == null) {
      throw new Error("Need a target peerid");
    }
    if (!await this.authenticateWebTransport(wt, localPeer, remotePeer, certhashes)) {
      throw new Error("Failed to authenticate webtransport");
    }
    const maConn = {
      close: async (err) => {
        if (err != null) {
          log45("Closing webtransport with err:", err);
        }
        wt.close();
      },
      remoteAddr: ma,
      timeline: {
        open: Date.now()
      },
      // This connection is never used directly since webtransport supports native streams.
      ...inertDuplex()
    };
    wt.closed.catch((err) => {
      log45.error("WebTransport connection closed:", err);
      maConn.timeline.close = Date.now();
    });
    try {
      options?.signal?.throwIfAborted();
    } catch (e) {
      wt.close();
      throw e;
    }
    return options.upgrader.upgradeOutbound(maConn, { skipEncryption: true, muxerFactory: this.webtransportMuxer(wt), skipProtection: true });
  }
  async authenticateWebTransport(wt, localPeer, remotePeer, certhashes) {
    const stream = await wt.createBidirectionalStream();
    const writer = stream.writable.getWriter();
    const reader2 = stream.readable.getReader();
    await writer.ready;
    const duplex = {
      source: async function* () {
        while (true) {
          const val = await reader2.read();
          if (val.value != null) {
            yield val.value;
          }
          if (val.done === true) {
            break;
          }
        }
      }(),
      sink: async function(source) {
        for await (const chunk of source) {
          await writer.write(chunk);
        }
      }
    };
    const n = noise()();
    const { remoteExtensions } = await n.secureOutbound(localPeer, duplex, remotePeer);
    writer.close().catch((err) => {
      log45.error(`Failed to close authentication stream writer: ${err.message}`);
    });
    reader2.cancel().catch((err) => {
      log45.error(`Failed to close authentication stream reader: ${err.message}`);
    });
    if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map((ch) => ch.bytes))) {
      throw new Error("Our certhashes are not a subset of the remote's reported certhashes");
    }
    return true;
  }
  webtransportMuxer(wt) {
    let streamIDCounter = 0;
    const config = this.config;
    return {
      protocol: "webtransport",
      createStreamMuxer: (init) => {
        if (typeof init === "function") {
          init = { onIncomingStream: init };
        }
        const activeStreams = [];
        (async function() {
          const reader2 = wt.incomingBidirectionalStreams.getReader();
          while (true) {
            const { done, value: wtStream } = await reader2.read();
            if (done === true) {
              break;
            }
            if (activeStreams.length >= config.maxInboundStreams) {
              wtStream.writable.close().catch((err) => {
                log45.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
              });
              wtStream.readable.cancel().catch((err) => {
                log45.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
              });
            } else {
              const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), "inbound", activeStreams, init?.onStreamEnd);
              activeStreams.push(stream);
              init?.onIncomingStream?.(stream);
            }
          }
        })().catch(() => {
          log45.error("WebTransport failed to receive incoming stream");
        });
        const muxer = {
          protocol: "webtransport",
          streams: activeStreams,
          newStream: async (name14) => {
            const wtStream = await wt.createBidirectionalStream();
            const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? "outbound", activeStreams, init?.onStreamEnd);
            activeStreams.push(stream);
            return stream;
          },
          /**
           * Close or abort all tracked streams and stop the muxer
           */
          close: (err) => {
            if (err != null) {
              log45("Closing webtransport muxer with err:", err);
            }
            wt.close();
          },
          // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.
          ...inertDuplex()
        };
        try {
          init?.signal?.throwIfAborted();
        } catch (e) {
          wt.close();
          throw e;
        }
        return muxer;
      }
    };
  }
  createListener(options) {
    throw new Error("Webtransport servers are not supported in Node or the browser");
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid webtransport addresses.
   */
  filter(multiaddrs) {
    return multiaddrs.filter((ma) => ma.protoNames().includes("webtransport"));
  }
};
function webTransport(init = {}) {
  return (components) => new WebTransportTransport(components, init);
}
__name(webTransport, "webTransport");

// node_modules/ipns/dist/src/pb/ipns.js
var IpnsEntry;
(function(IpnsEntry2) {
  let ValidityType;
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.value != null) {
          w2.uint32(10);
          w2.bytes(obj.value);
        }
        if (obj.signature != null) {
          w2.uint32(18);
          w2.bytes(obj.signature);
        }
        if (obj.validityType != null) {
          w2.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w2);
        }
        if (obj.validity != null) {
          w2.uint32(34);
          w2.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w2.uint32(40);
          w2.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w2.uint32(48);
          w2.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w2.uint32(58);
          w2.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w2.uint32(66);
          w2.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w2.uint32(74);
          w2.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader2.bytes();
              break;
            case 2:
              obj.signature = reader2.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader2);
              break;
            case 4:
              obj.validity = reader2.bytes();
              break;
            case 5:
              obj.sequence = reader2.uint64();
              break;
            case 6:
              obj.ttl = reader2.uint64();
              break;
            case 7:
              obj.pubKey = reader2.bytes();
              break;
            case 8:
              obj.signatureV2 = reader2.bytes();
              break;
            case 9:
              obj.data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf3) => {
    return decodeMessage(buf3, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/index.js
var import_asn14 = __toESM(require_asn1(), 1);
var import_pbe2 = __toESM(require_pbe(), 1);

// node_modules/@libp2p/interface/dist/src/errors.js
var CodeError3 = class extends Error {
  static {
    __name(this, "CodeError");
  }
  code;
  props;
  constructor(message2, code16, props) {
    super(message2);
    this.code = code16;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/index.js
var import_forge11 = __toESM(require_forge(), 1);

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var ed25519_class_exports2 = {};
__export(ed25519_class_exports2, {
  Ed25519PrivateKey: () => Ed25519PrivateKey2,
  Ed25519PublicKey: () => Ed25519PublicKey2,
  generateKeyPair: () => generateKeyPair5,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed3,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey2,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey2
});

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js
var PUBLIC_KEY_BYTE_LENGTH2 = 32;
var PRIVATE_KEY_BYTE_LENGTH2 = 64;
var KEYS_BYTE_LENGTH2 = 32;
async function generateKey4() {
  const privateKeyRaw = ed25519.utils.randomPrivateKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys2(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
__name(generateKey4, "generateKey");
async function generateKeyFromSeed2(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH2) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys2(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
__name(generateKeyFromSeed2, "generateKeyFromSeed");
async function hashAndSign4(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH2);
  return ed25519.sign(msg, privateKeyRaw);
}
__name(hashAndSign4, "hashAndSign");
async function hashAndVerify4(publicKey, sig, msg) {
  return ed25519.verify(sig, msg, publicKey);
}
__name(hashAndVerify4, "hashAndVerify");
function concatKeys2(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH2);
  for (let i = 0; i < KEYS_BYTE_LENGTH2; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH2 + i] = publicKey[i];
  }
  return privateKey;
}
__name(concatKeys2, "concatKeys");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/webcrypto.js
var webcrypto_default2 = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto == null || nativeCrypto.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
var derivedEmptyPasswordKey2 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
function create20(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest13 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto5 = webcrypto_default2.get();
  keyLength *= 8;
  async function encrypt3(data, password) {
    const salt = crypto5.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto5.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString7(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto5.subtle.importKey("jwk", derivedEmptyPasswordKey2, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
        const runtimeDerivedEmptyPassword = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto5.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto5.subtle.importKey("jwk", derivedEmptyPasswordKey2, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
      const rawKey = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto5.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto5.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat3([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  __name(encrypt3, "encrypt");
  async function decrypt3(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString7(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
        const runtimeDerivedEmptyPassword = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto5.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto5.subtle.importKey("jwk", derivedEmptyPasswordKey2, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest13 } };
      const rawKey = await crypto5.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto5.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto5.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  __name(decrypt3, "decrypt");
  const cipher = {
    encrypt: encrypt3,
    decrypt: decrypt3
  };
  return cipher;
}
__name(create20, "create");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/exporter.js
async function exporter2(privateKey, password) {
  const cipher = create20();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base646.encode(encryptedKey);
}
__name(exporter2, "exporter");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType2;
(function(KeyType3) {
  KeyType3["RSA"] = "RSA";
  KeyType3["Ed25519"] = "Ed25519";
  KeyType3["Secp256k1"] = "Secp256k1";
})(KeyType2 || (KeyType2 = {}));
var __KeyTypeValues2;
(function(__KeyTypeValues3) {
  __KeyTypeValues3[__KeyTypeValues3["RSA"] = 0] = "RSA";
  __KeyTypeValues3[__KeyTypeValues3["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues3[__KeyTypeValues3["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues2 || (__KeyTypeValues2 = {}));
(function(KeyType3) {
  KeyType3.codec = () => {
    return enumeration(__KeyTypeValues2);
  };
})(KeyType2 || (KeyType2 = {}));
var PublicKey2;
(function(PublicKey3) {
  let _codec;
  PublicKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType2.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType2.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey3.encode = (obj) => {
    return encodeMessage(obj, PublicKey3.codec());
  };
  PublicKey3.decode = (buf3) => {
    return decodeMessage(buf3, PublicKey3.codec());
  };
})(PublicKey2 || (PublicKey2 = {}));
var PrivateKey2;
(function(PrivateKey3) {
  let _codec;
  PrivateKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType2.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType2.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey3.encode = (obj) => {
    return encodeMessage(obj, PrivateKey3.codec());
  };
  PrivateKey3.decode = (buf3) => {
    return decodeMessage(buf3, PrivateKey3.codec());
  };
})(PrivateKey2 || (PrivateKey2 = {}));

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var Ed25519PublicKey2 = class {
  static {
    __name(this, "Ed25519PublicKey");
  }
  _key;
  constructor(key) {
    this._key = ensureKey2(key, PUBLIC_KEY_BYTE_LENGTH2);
  }
  async verify(data, sig) {
    return hashAndVerify4(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey2.encode({
      Type: KeyType2.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2564.digest(this.bytes);
    return bytes3;
  }
};
var Ed25519PrivateKey2 = class {
  static {
    __name(this, "Ed25519PrivateKey");
  }
  _key;
  _publicKey;
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    this._key = ensureKey2(key, PRIVATE_KEY_BYTE_LENGTH2);
    this._publicKey = ensureKey2(publicKey, PUBLIC_KEY_BYTE_LENGTH2);
  }
  async sign(message2) {
    return hashAndSign4(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey2(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey2.encode({
      Type: KeyType2.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2564.digest(this.bytes);
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const encoding = identity6.digest(this.public.bytes);
    return base58btc6.encode(encoding.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format14 = "libp2p-key") {
    if (format14 === "libp2p-key") {
      return exporter2(this.bytes, password);
    } else {
      throw new CodeError3(`export format '${format14}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalEd25519PrivateKey2(bytes3) {
  if (bytes3.length > PRIVATE_KEY_BYTE_LENGTH2) {
    bytes3 = ensureKey2(bytes3, PRIVATE_KEY_BYTE_LENGTH2 + PUBLIC_KEY_BYTE_LENGTH2);
    const privateKeyBytes2 = bytes3.subarray(0, PRIVATE_KEY_BYTE_LENGTH2);
    const publicKeyBytes2 = bytes3.subarray(PRIVATE_KEY_BYTE_LENGTH2, bytes3.length);
    return new Ed25519PrivateKey2(privateKeyBytes2, publicKeyBytes2);
  }
  bytes3 = ensureKey2(bytes3, PRIVATE_KEY_BYTE_LENGTH2);
  const privateKeyBytes = bytes3.subarray(0, PRIVATE_KEY_BYTE_LENGTH2);
  const publicKeyBytes = bytes3.subarray(PUBLIC_KEY_BYTE_LENGTH2);
  return new Ed25519PrivateKey2(privateKeyBytes, publicKeyBytes);
}
__name(unmarshalEd25519PrivateKey2, "unmarshalEd25519PrivateKey");
function unmarshalEd25519PublicKey2(bytes3) {
  bytes3 = ensureKey2(bytes3, PUBLIC_KEY_BYTE_LENGTH2);
  return new Ed25519PublicKey2(bytes3);
}
__name(unmarshalEd25519PublicKey2, "unmarshalEd25519PublicKey");
async function generateKeyPair5() {
  const { privateKey, publicKey } = await generateKey4();
  return new Ed25519PrivateKey2(privateKey, publicKey);
}
__name(generateKeyPair5, "generateKeyPair");
async function generateKeyPairFromSeed3(seed) {
  const { privateKey, publicKey } = await generateKeyFromSeed2(seed);
  return new Ed25519PrivateKey2(privateKey, publicKey);
}
__name(generateKeyPairFromSeed3, "generateKeyPairFromSeed");
function ensureKey2(key, length21) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length21) {
    throw new CodeError3(`Key must be a Uint8Array of length ${length21}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
  }
  return key;
}
__name(ensureKey2, "ensureKey");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/util.js
var import_util19 = __toESM(require_util(), 1);
var import_jsbn2 = __toESM(require_jsbn(), 1);
var import_forge7 = __toESM(require_forge(), 1);
function bigIntegerToUintBase64url2(num, len) {
  let buf3 = Uint8Array.from(num.abs().toByteArray());
  buf3 = buf3[0] === 0 ? buf3.subarray(1) : buf3;
  if (len != null) {
    if (buf3.length > len)
      throw new Error("byte array longer than desired length");
    buf3 = concat3([new Uint8Array(len - buf3.length), buf3]);
  }
  return toString5(buf3, "base64url");
}
__name(bigIntegerToUintBase64url2, "bigIntegerToUintBase64url");
function base64urlToBigInteger2(str) {
  const buf3 = base64urlToBuffer2(str);
  return new import_forge7.default.jsbn.BigInteger(toString5(buf3, "base16"), 16);
}
__name(base64urlToBigInteger2, "base64urlToBigInteger");
function base64urlToBuffer2(str, len) {
  let buf3 = fromString7(str, "base64urlpad");
  if (len != null) {
    if (buf3.length > len)
      throw new Error("byte array longer than desired length");
    buf3 = concat3([new Uint8Array(len - buf3.length), buf3]);
  }
  return buf3;
}
__name(base64urlToBuffer2, "base64urlToBuffer");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js
var bits2 = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
var curveTypes2 = Object.keys(bits2);
var names3 = curveTypes2.join(" / ");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var rsa_class_exports2 = {};
__export(rsa_class_exports2, {
  MAX_KEY_SIZE: () => MAX_KEY_SIZE,
  RsaPrivateKey: () => RsaPrivateKey2,
  RsaPublicKey: () => RsaPublicKey2,
  fromJwk: () => fromJwk2,
  generateKeyPair: () => generateKeyPair6,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey2,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey2
});
var import_forge10 = __toESM(require_forge(), 1);
var import_sha5123 = __toESM(require_sha512(), 1);

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes3(length21) {
  if (isNaN(length21) || length21 <= 0) {
    throw new CodeError3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  }
  return randomBytes2(length21);
}
__name(randomBytes3, "randomBytes");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/jwk2pem.js
var import_rsa3 = __toESM(require_rsa(), 1);
var import_forge8 = __toESM(require_forge(), 1);
function convert2(key, types) {
  return types.map((t) => base64urlToBigInteger2(key[t]));
}
__name(convert2, "convert");
function jwk2priv2(key) {
  return import_forge8.default.pki.setRsaPrivateKey(...convert2(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
}
__name(jwk2priv2, "jwk2priv");
function jwk2pub2(key) {
  return import_forge8.default.pki.setRsaPublicKey(...convert2(key, ["n", "e"]));
}
__name(jwk2pub2, "jwk2pub");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
var rsa_utils_exports2 = {};
__export(rsa_utils_exports2, {
  jwkToPkcs1: () => jwkToPkcs12,
  jwkToPkix: () => jwkToPkix2,
  pkcs1ToJwk: () => pkcs1ToJwk2,
  pkixToJwk: () => pkixToJwk2
});
var import_asn13 = __toESM(require_asn1(), 1);
var import_rsa4 = __toESM(require_rsa(), 1);
var import_forge9 = __toESM(require_forge(), 1);
function pkcs1ToJwk2(bytes3) {
  const asn1 = import_forge9.default.asn1.fromDer(toString5(bytes3, "ascii"));
  const privateKey = import_forge9.default.pki.privateKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url2(privateKey.n),
    e: bigIntegerToUintBase64url2(privateKey.e),
    d: bigIntegerToUintBase64url2(privateKey.d),
    p: bigIntegerToUintBase64url2(privateKey.p),
    q: bigIntegerToUintBase64url2(privateKey.q),
    dp: bigIntegerToUintBase64url2(privateKey.dP),
    dq: bigIntegerToUintBase64url2(privateKey.dQ),
    qi: bigIntegerToUintBase64url2(privateKey.qInv),
    alg: "RS256"
  };
}
__name(pkcs1ToJwk2, "pkcs1ToJwk");
function jwkToPkcs12(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new CodeError3("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge9.default.pki.privateKeyToAsn1({
    n: base64urlToBigInteger2(jwk.n),
    e: base64urlToBigInteger2(jwk.e),
    d: base64urlToBigInteger2(jwk.d),
    p: base64urlToBigInteger2(jwk.p),
    q: base64urlToBigInteger2(jwk.q),
    dP: base64urlToBigInteger2(jwk.dp),
    dQ: base64urlToBigInteger2(jwk.dq),
    qInv: base64urlToBigInteger2(jwk.qi)
  });
  return fromString7(import_forge9.default.asn1.toDer(asn1).getBytes(), "ascii");
}
__name(jwkToPkcs12, "jwkToPkcs1");
function pkixToJwk2(bytes3) {
  const asn1 = import_forge9.default.asn1.fromDer(toString5(bytes3, "ascii"));
  const publicKey = import_forge9.default.pki.publicKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url2(publicKey.n),
    e: bigIntegerToUintBase64url2(publicKey.e)
  };
}
__name(pkixToJwk2, "pkixToJwk");
function jwkToPkix2(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new CodeError3("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge9.default.pki.publicKeyToAsn1({
    n: base64urlToBigInteger2(jwk.n),
    e: base64urlToBigInteger2(jwk.e)
  });
  return fromString7(import_forge9.default.asn1.toDer(asn1).getBytes(), "ascii");
}
__name(jwkToPkix2, "jwkToPkix");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js
async function generateKey5(bits3) {
  const pair2 = await webcrypto_default2.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits3,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey2(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
__name(generateKey5, "generateKey");
async function unmarshalPrivateKey4(key) {
  const privateKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate2(key)
  ];
  const keys = await exportKey2({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
__name(unmarshalPrivateKey4, "unmarshalPrivateKey");
async function hashAndSign5(key, msg) {
  const privateKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default2.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
  return new Uint8Array(sig, 0, sig.byteLength);
}
__name(hashAndSign5, "hashAndSign");
async function hashAndVerify5(key, sig, msg) {
  const publicKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto_default2.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
}
__name(hashAndVerify5, "hashAndVerify");
async function exportKey2(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new CodeError3("Private and public key are required", "ERR_INVALID_PARAMETERS");
  }
  return Promise.all([
    webcrypto_default2.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default2.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
__name(exportKey2, "exportKey");
async function derivePublicFromPrivate2(jwKey) {
  return webcrypto_default2.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
__name(derivePublicFromPrivate2, "derivePublicFromPrivate");
function convertKey2(key, pub, msg, handle2) {
  const fkey = pub ? jwk2pub2(key) : jwk2priv2(key);
  const fmsg = toString5(Uint8Array.from(msg), "ascii");
  const fomsg = handle2(fmsg, fkey);
  return fromString7(fomsg, "ascii");
}
__name(convertKey2, "convertKey");
function encrypt2(key, msg) {
  return convertKey2(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
}
__name(encrypt2, "encrypt");
function decrypt2(key, msg) {
  return convertKey2(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
}
__name(decrypt2, "decrypt");
function keySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new CodeError3("invalid key type", "ERR_INVALID_KEY_TYPE");
  } else if (jwk.n == null) {
    throw new CodeError3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
  }
  const bytes3 = fromString7(jwk.n, "base64url");
  return bytes3.length * 8;
}
__name(keySize, "keySize");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var MAX_KEY_SIZE = 8192;
var RsaPublicKey2 = class {
  static {
    __name(this, "RsaPublicKey");
  }
  _key;
  constructor(key) {
    this._key = key;
  }
  async verify(data, sig) {
    return hashAndVerify5(this._key, sig, data);
  }
  marshal() {
    return rsa_utils_exports2.jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey2.encode({
      Type: KeyType2.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(bytes3) {
    return encrypt2(this._key, bytes3);
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2564.digest(this.bytes);
    return bytes3;
  }
};
var RsaPrivateKey2 = class {
  static {
    __name(this, "RsaPrivateKey");
  }
  _key;
  _publicKey;
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes3(16);
  }
  async sign(message2) {
    return hashAndSign5(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw new CodeError3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey2(this._publicKey);
  }
  decrypt(bytes3) {
    return decrypt2(this._key, bytes3);
  }
  marshal() {
    return rsa_utils_exports2.jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey2.encode({
      Type: KeyType2.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2564.digest(this.bytes);
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash3 = await this.public.hash();
    return toString5(hash3, "base58btc");
  }
  /**
   * Exports the key into a password protected PEM format
   */
  async export(password, format14 = "pkcs-8") {
    if (format14 === "pkcs-8") {
      const buffer3 = new import_forge10.default.util.ByteBuffer(this.marshal());
      const asn1 = import_forge10.default.asn1.fromDer(buffer3);
      const privateKey = import_forge10.default.pki.privateKeyFromAsn1(asn1);
      const options = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return import_forge10.default.pki.encryptRsaPrivateKey(privateKey, password, options);
    } else if (format14 === "libp2p-key") {
      return exporter2(this.bytes, password);
    } else {
      throw new CodeError3(`export format '${format14}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
async function unmarshalRsaPrivateKey2(bytes3) {
  const jwk = rsa_utils_exports2.pkcs1ToJwk(bytes3);
  if (keySize(jwk) > MAX_KEY_SIZE) {
    throw new CodeError3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey4(jwk);
  return new RsaPrivateKey2(keys.privateKey, keys.publicKey);
}
__name(unmarshalRsaPrivateKey2, "unmarshalRsaPrivateKey");
function unmarshalRsaPublicKey2(bytes3) {
  const jwk = rsa_utils_exports2.pkixToJwk(bytes3);
  if (keySize(jwk) > MAX_KEY_SIZE) {
    throw new CodeError3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  return new RsaPublicKey2(jwk);
}
__name(unmarshalRsaPublicKey2, "unmarshalRsaPublicKey");
async function fromJwk2(jwk) {
  if (keySize(jwk) > MAX_KEY_SIZE) {
    throw new CodeError3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey4(jwk);
  return new RsaPrivateKey2(keys.privateKey, keys.publicKey);
}
__name(fromJwk2, "fromJwk");
async function generateKeyPair6(bits3) {
  if (bits3 > MAX_KEY_SIZE) {
    throw new CodeError3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await generateKey5(bits3);
  return new RsaPrivateKey2(keys.privateKey, keys.publicKey);
}
__name(generateKeyPair6, "generateKeyPair");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var secp256k1_class_exports2 = {};
__export(secp256k1_class_exports2, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey2,
  Secp256k1PublicKey: () => Secp256k1PublicKey2,
  generateKeyPair: () => generateKeyPair7,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey2,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey2
});

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
__name(validateSigVerOpts, "validateSigVerOpts");
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: endo2, Fp: Fp3, a } = opts;
  if (endo2) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo2 !== "object" || typeof endo2.beta !== "bigint" || typeof endo2.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
__name(validatePointOpts, "validatePointOpts");
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    static {
      __name(this, "DERErr");
    }
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s: s2 };
  },
  hexFromSig(sig) {
    const slice3 = /* @__PURE__ */ __name((s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3, "slice");
    const h2 = /* @__PURE__ */ __name((num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }, "h");
    const s2 = slice3(h2(sig.s));
    const r = slice3(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r}02${sl}${s2}`;
  }
};
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n7 = BigInt(2);
var _3n4 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE3 = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE3;
  const toBytes4 = CURVE3.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes4(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes = CURVE3.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y: y2 };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE3;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
  }
  __name(weierstrassEquation, "weierstrassEquation");
  if (!Fp3.eql(Fp3.sqr(CURVE3.Gy), weierstrassEquation(CURVE3.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder2(num) {
    return inRange(num, _1n9, CURVE3.n);
  }
  __name(isWithinCurveOrder2, "isWithinCurveOrder");
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE3;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex3(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes4("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod4(num, N);
    aInRange("private key", num, _1n9, N);
    return num;
  }
  __name(normPrivateKeyToScalar, "normPrivateKeyToScalar");
  function assertPrjPoint(other) {
    if (!(other instanceof Point4))
      throw new Error("ProjectivePoint expected");
  }
  __name(assertPrjPoint, "assertPrjPoint");
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y2, pz: z } = p;
    if (Fp3.eql(z, Fp3.ONE))
      return { x, y: y2 };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z);
    const ax = Fp3.mul(x, iz);
    const ay = Fp3.mul(y2, iz);
    const zz = Fp3.mul(z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE3.allowInfinityPoint && !Fp3.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y: y2 } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp3.sqr(y2);
    const right = weierstrassEquation(x);
    if (!Fp3.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point4 {
    static {
      __name(this, "Point");
    }
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y: y2 } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y2))
        throw new Error("invalid affine point");
      if (p instanceof Point4)
        throw new Error("projective point not allowed");
      const is0 = /* @__PURE__ */ __name((i) => Fp3.eql(i, Fp3.ZERO), "is0");
      if (is0(x) && is0(y2))
        return Point4.ZERO;
      return new Point4(x, y2, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point4.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point4.fromAffine(fromBytes(ensureBytes4("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point4.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point4(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE3;
      const b3 = Fp3.mul(b, _3n4);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point4(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE3.a;
      const b3 = Fp3.mul(CURVE3.b, _3n4);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point4(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point4.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point4.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      aInRange("scalar", sc, _0n9, CURVE3.n);
      const I = Point4.ZERO;
      if (sc === _0n9)
        return I;
      if (sc === _1n9)
        return this;
      const { endo: endo2 } = CURVE3;
      if (!endo2)
        return wnaf.unsafeLadder(this, sc);
      let { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d2 = this;
      while (k1 > _0n9 || k2 > _0n9) {
        if (k1 & _1n9)
          k1p = k1p.add(d2);
        if (k2 & _1n9)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n9;
        k2 >>= _1n9;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point4(Fp3.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2, n: N } = CURVE3;
      aInRange("scalar", scalar, _1n9, N);
      let point, fake;
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point4(Fp3.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point4.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point4.BASE;
      const mul = /* @__PURE__ */ __name((P, a2) => a2 === _0n9 || a2 === _1n9 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2), "mul");
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE3;
      if (cofactor === _1n9)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point4, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE3;
      if (cofactor === _1n9)
        return this;
      if (clearCofactor)
        return clearCofactor(Point4, this);
      return this.multiplyUnsafe(CURVE3.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes4(Point4, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex3(this.toRawBytes(isCompressed));
    }
  }
  Point4.BASE = new Point4(CURVE3.Gx, CURVE3.Gy, Fp3.ONE);
  Point4.ZERO = new Point4(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE3.nBitLength;
  const wnaf = wNAF(Point4, CURVE3.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE: CURVE3,
    ProjectivePoint: Point4,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder: isWithinCurveOrder2
  };
}
__name(weierstrassPoints, "weierstrassPoints");
function validateOpts3(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
__name(validateOpts3, "validateOpts");
function weierstrass2(curveDef) {
  const CURVE3 = validateOpts3(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE3;
  const compressedLen2 = Fp3.BYTES + 1;
  const uncompressedLen2 = 2 * Fp3.BYTES + 1;
  function modN(a) {
    return mod4(a, CURVE_ORDER);
  }
  __name(modN, "modN");
  function invN(a) {
    return invert3(a, CURVE_ORDER);
  }
  __name(invN, "invN");
  const { ProjectivePoint: Point4, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder: isWithinCurveOrder2 } = weierstrassPoints({
    ...CURVE3,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes4;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen2 && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n9, Fp3.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y3;
        try {
          y3 = Fp3.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n9) === _1n9;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp3.neg(y3);
        return { x, y: y3 };
      } else if (len === uncompressedLen2 && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen2} compressed bytes or ${uncompressedLen2} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = /* @__PURE__ */ __name((num) => bytesToHex3(numberToBytesBE(num, CURVE3.nByteLength)), "numToNByteStr");
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n9;
    return number3 > HALF;
  }
  __name(isBiggerThanHalfOrder, "isBiggerThanHalfOrder");
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  __name(normalizeS, "normalizeS");
  const slcNum = /* @__PURE__ */ __name((b, from46, to) => bytesToNumberBE(b.slice(from46, to)), "slcNum");
  class Signature3 {
    static {
      __name(this, "Signature");
    }
    constructor(r, s2, recovery) {
      this.r = r;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE3.nByteLength;
      hex = ensureBytes4("compactSignature", hex, l * 2);
      return new Signature3(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s: s2 } = DER.toSig(ensureBytes4("DER", hex));
      return new Signature3(r, s2);
    }
    assertValidity() {
      aInRange("r", this.r, _1n9, CURVE_ORDER);
      aInRange("s", this.s, _1n9, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature3(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes4("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE3.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point4.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q = Point4.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature3(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes3(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes3(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils3 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length21 = getMinHashLength(CURVE3.n);
      return mapHashToField(CURVE3.randomBytes(length21), CURVE3.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point4.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey3(privateKey, isCompressed = true) {
    return Point4.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  __name(getPublicKey3, "getPublicKey");
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen2 || len === uncompressedLen2;
    if (str)
      return len === 2 * compressedLen2 || len === 2 * uncompressedLen2;
    if (item instanceof Point4)
      return true;
    return false;
  }
  __name(isProbPub, "isProbPub");
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point4.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  __name(getSharedSecret, "getSharedSecret");
  const bits2int2 = CURVE3.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE3.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE3.bits2int_modN || function(bytes3) {
    return modN(bits2int2(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE3.nBitLength);
  function int2octets2(num) {
    aInRange(`num < 2^${CURVE3.nBitLength}`, num, _0n9, ORDER_MASK);
    return numberToBytesBE(num, CURVE3.nByteLength);
  }
  __name(int2octets2, "int2octets");
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes4 } = CURVE3;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes4("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes4("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets2(d2), int2octets2(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes4(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes4("extraEntropy", e));
    }
    const seed = concatBytes4(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int2(kBytes);
      if (!isWithinCurveOrder2(k))
        return;
      const ik = invN(k);
      const q = Point4.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n9)
        return;
      const s2 = modN(ik * modN(m2 + r * d2));
      if (s2 === _0n9)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n9);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature3(r, normS, recovery);
    }
    __name(k2sig, "k2sig");
    return { seed, k2sig };
  }
  __name(prepSig, "prepSig");
  const defaultSigOpts = { lowS: CURVE3.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE3.lowS, prehash: false };
  function sign4(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE3;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  __name(sign4, "sign");
  Point4.BASE._setWindowSize(8);
  function verify3(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes4("msgHash", msgHash);
    publicKey = ensureBytes4("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(opts);
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes2(sg)) {
        try {
          _sig = Signature3.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature3.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s3 } = sg;
        _sig = new Signature3(r2, s3);
      } else {
        throw new Error("PARSE");
      }
      P = Point4.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE3.hash(msgHash);
    const { r, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is3 = invN(s2);
    const u1 = modN(h2 * is3);
    const u2 = modN(r * is3);
    const R = Point4.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  __name(verify3, "verify");
  return {
    CURVE: CURVE3,
    getPublicKey: getPublicKey3,
    getSharedSecret,
    sign: sign4,
    verify: verify3,
    ProjectivePoint: Point4,
    Signature: Signature3,
    utils: utils3
  };
}
__name(weierstrass2, "weierstrass");

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes3(...msgs)),
    randomBytes: randomBytes2
  };
}
__name(getHash, "getHash");
function createCurve(curveDef, defHash) {
  const create23 = /* @__PURE__ */ __name((hash3) => weierstrass2({ ...curveDef, ...getHash(hash3) }), "create");
  return Object.freeze({ ...create23(defHash), create: create23 });
}
__name(createCurve, "createCurve");

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n10 = BigInt(1);
var _2n8 = BigInt(2);
var divNearest2 = /* @__PURE__ */ __name((a, b) => (a + b / _2n8) / b, "divNearest");
function sqrtMod2(y2) {
  const P = secp256k1P;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P;
  const b3 = b2 * b2 * y2 % P;
  const b6 = pow23(b3, _3n5, P) * b3 % P;
  const b9 = pow23(b6, _3n5, P) * b3 % P;
  const b11 = pow23(b9, _2n8, P) * b2 % P;
  const b22 = pow23(b11, _11n, P) * b11 % P;
  const b44 = pow23(b22, _22n, P) * b22 % P;
  const b88 = pow23(b44, _44n, P) * b44 % P;
  const b176 = pow23(b88, _88n, P) * b88 % P;
  const b220 = pow23(b176, _44n, P) * b44 % P;
  const b223 = pow23(b220, _3n5, P) * b3 % P;
  const t1 = pow23(b223, _23n, P) * b22 % P;
  const t2 = pow23(t1, _6n, P) * b2 % P;
  const root = pow23(t2, _2n8, P);
  if (!Fp2.eql(Fp2.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
__name(sqrtMod2, "sqrtMod");
var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n10 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b2 * k, n);
      const c2 = divNearest2(-b1 * k, n);
      let k1 = mod4(k - c1 * a1 - c2 * a2, n);
      let k2 = mod4(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha25611);
var _0n10 = BigInt(0);
var Point3 = secp256k1.ProjectivePoint;

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/secp256k1.js
function generateKey6() {
  return secp256k1.utils.randomPrivateKey();
}
__name(generateKey6, "generateKey");
async function hashAndSign6(key, msg) {
  const { digest: digest13 } = await sha2564.digest(msg);
  try {
    const signature = secp256k1.sign(digest13, key);
    return signature.toDERRawBytes();
  } catch (err) {
    throw new CodeError3(String(err), "ERR_INVALID_INPUT");
  }
}
__name(hashAndSign6, "hashAndSign");
async function hashAndVerify6(key, sig, msg) {
  try {
    const { digest: digest13 } = await sha2564.digest(msg);
    return secp256k1.verify(sig, digest13, key);
  } catch (err) {
    throw new CodeError3(String(err), "ERR_INVALID_INPUT");
  }
}
__name(hashAndVerify6, "hashAndVerify");
function compressPublicKey2(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
__name(compressPublicKey2, "compressPublicKey");
function validatePrivateKey2(key) {
  try {
    secp256k1.getPublicKey(key, true);
  } catch (err) {
    throw new CodeError3(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
__name(validatePrivateKey2, "validatePrivateKey");
function validatePublicKey2(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
  } catch (err) {
    throw new CodeError3(String(err), "ERR_INVALID_PUBLIC_KEY");
  }
}
__name(validatePublicKey2, "validatePublicKey");
function computePublicKey2(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new CodeError3(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
__name(computePublicKey2, "computePublicKey");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var Secp256k1PublicKey2 = class {
  static {
    __name(this, "Secp256k1PublicKey");
  }
  _key;
  constructor(key) {
    validatePublicKey2(key);
    this._key = key;
  }
  async verify(data, sig) {
    return hashAndVerify6(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey2(this._key);
  }
  get bytes() {
    return PublicKey2.encode({
      Type: KeyType2.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2564.digest(this.bytes);
    return bytes3;
  }
};
var Secp256k1PrivateKey2 = class {
  static {
    __name(this, "Secp256k1PrivateKey");
  }
  _key;
  _publicKey;
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey2(key);
    validatePrivateKey2(this._key);
    validatePublicKey2(this._publicKey);
  }
  async sign(message2) {
    return hashAndSign6(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey2(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey2.encode({
      Type: KeyType2.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals7(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes3 } = await sha2564.digest(this.bytes);
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash3 = await this.public.hash();
    return toString5(hash3, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format14 = "libp2p-key") {
    if (format14 === "libp2p-key") {
      return exporter2(this.bytes, password);
    } else {
      throw new CodeError3(`export format '${format14}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalSecp256k1PrivateKey2(bytes3) {
  return new Secp256k1PrivateKey2(bytes3);
}
__name(unmarshalSecp256k1PrivateKey2, "unmarshalSecp256k1PrivateKey");
function unmarshalSecp256k1PublicKey2(bytes3) {
  return new Secp256k1PublicKey2(bytes3);
}
__name(unmarshalSecp256k1PublicKey2, "unmarshalSecp256k1PublicKey");
async function generateKeyPair7() {
  const privateKeyBytes = generateKey6();
  return new Secp256k1PrivateKey2(privateKeyBytes);
}
__name(generateKeyPair7, "generateKeyPair");

// node_modules/ipns/node_modules/@libp2p/crypto/dist/src/keys/index.js
var supportedKeys2 = {
  rsa: rsa_class_exports2,
  ed25519: ed25519_class_exports2,
  secp256k1: secp256k1_class_exports2
};
function unsupportedKey2(type) {
  const supported = Object.keys(supportedKeys2).join(" / ");
  return new CodeError3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
__name(unsupportedKey2, "unsupportedKey");
function unmarshalPublicKey3(buf3) {
  const decoded = PublicKey2.decode(buf3);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType2.RSA:
      return supportedKeys2.rsa.unmarshalRsaPublicKey(data);
    case KeyType2.Ed25519:
      return supportedKeys2.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType2.Secp256k1:
      return supportedKeys2.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey2(decoded.Type ?? "unknown");
  }
}
__name(unmarshalPublicKey3, "unmarshalPublicKey");

// node_modules/@libp2p/logger/dist/src/index.js
var import_debug17 = __toESM(require_browser(), 1);
import_debug17.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc6.baseEncode(v);
};
import_debug17.default.formatters.t = (v) => {
  return v == null ? "undefined" : base326.baseEncode(v);
};
import_debug17.default.formatters.m = (v) => {
  return v == null ? "undefined" : base646.baseEncode(v);
};
import_debug17.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug17.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug17.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug17.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger19(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger19, "createDisabledLogger");
function logger20(name14) {
  let trace = createDisabledLogger19(`${name14}:trace`);
  if (import_debug17.default.enabled(`${name14}:trace`) && import_debug17.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug17.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug17.default)(name14), {
    error: (0, import_debug17.default)(`${name14}:error`),
    trace
  });
}
__name(logger20, "logger");

// node_modules/@libp2p/interface/dist/src/peer-id/index.js
var symbol6 = Symbol.for("@libp2p/peer-id");

// node_modules/ipns/node_modules/@libp2p/peer-id/dist/src/index.js
var inspect3 = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder2 = Object.values(bases3).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases3.identity.decoder);
var LIBP2P_KEY_CODE2 = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH2 = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH2 = 37;
var PeerIdImpl2 = class {
  static {
    __name(this, "PeerIdImpl");
  }
  type;
  multihash;
  privateKey;
  publicKey;
  string;
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  [symbol6] = true;
  toString() {
    if (this.string == null) {
      this.string = base58btc6.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID5.createV1(LIBP2P_KEY_CODE2, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals7(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString2(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals7(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect3]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl2 = class extends PeerIdImpl2 {
  static {
    __name(this, "RSAPeerIdImpl");
  }
  type = "RSA";
  publicKey;
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl2 = class extends PeerIdImpl2 {
  static {
    __name(this, "Ed25519PeerIdImpl");
  }
  type = "Ed25519";
  publicKey;
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl2 = class extends PeerIdImpl2 {
  static {
    __name(this, "Secp256k1PeerIdImpl");
  }
  type = "secp256k1";
  publicKey;
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromString2(str, decoder) {
  decoder = decoder ?? baseDecoder2;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode26(base58btc6.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl2({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl2({ multihash });
    } else {
      return new RSAPeerIdImpl2({ multihash });
    }
  }
  return peerIdFromBytes2(baseDecoder2.decode(str));
}
__name(peerIdFromString2, "peerIdFromString");
function peerIdFromBytes2(buf3) {
  try {
    const multihash = decode26(buf3);
    if (multihash.code === identity6.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH2) {
        return new Ed25519PeerIdImpl2({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH2) {
        return new Secp256k1PeerIdImpl2({ multihash });
      }
    }
    if (multihash.code === sha2564.code) {
      return new RSAPeerIdImpl2({ multihash });
    }
  } catch {
    return peerIdFromCID2(CID5.decode(buf3));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
__name(peerIdFromBytes2, "peerIdFromBytes");
function peerIdFromCID2(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2564.code) {
    return new RSAPeerIdImpl2({ multihash: cid.multihash });
  } else if (multihash.code === identity6.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH2) {
      return new Ed25519PeerIdImpl2({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH2) {
      return new Secp256k1PeerIdImpl2({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
__name(peerIdFromCID2, "peerIdFromCID");
async function peerIdFromKeys2(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH2) {
    return new Ed25519PeerIdImpl2({ multihash: create5(identity6.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH2) {
    return new Secp256k1PeerIdImpl2({ multihash: create5(identity6.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl2({ multihash: await sha2564.digest(publicKey), publicKey, privateKey });
}
__name(peerIdFromKeys2, "peerIdFromKeys");

// node_modules/ipns/node_modules/cborg/lib/is.js
var typeofs2 = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames2 = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs2.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer3(value)) {
    return "Buffer";
  }
  const objectType = getObjectType2(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
__name(is2, "is");
function isBuffer3(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
__name(isBuffer3, "isBuffer");
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames2.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
__name(getObjectType2, "getObjectType");

// node_modules/ipns/node_modules/cborg/lib/token.js
var Type2 = class {
  static {
    __name(this, "Type");
  }
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name14, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name14;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type2.uint = new Type2(0, "uint", true);
Type2.negint = new Type2(1, "negint", true);
Type2.bytes = new Type2(2, "bytes", true);
Type2.string = new Type2(3, "string", true);
Type2.array = new Type2(4, "array", false);
Type2.map = new Type2(5, "map", false);
Type2.tag = new Type2(6, "tag", false);
Type2.float = new Type2(7, "float", true);
Type2.false = new Type2(7, "false", true);
Type2.true = new Type2(7, "true", true);
Type2.null = new Type2(7, "null", true);
Type2.undefined = new Type2(7, "undefined", true);
Type2.break = new Type2(7, "break", true);
var Token2 = class {
  static {
    __name(this, "Token");
  }
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/ipns/node_modules/cborg/lib/byte-utils.js
var useBuffer2 = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
var textDecoder13 = new TextDecoder();
var textEncoder14 = new TextEncoder();
function isBuffer4(buf3) {
  return useBuffer2 && globalThis.Buffer.isBuffer(buf3);
}
__name(isBuffer4, "isBuffer");
function asU8A2(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer4(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
__name(asU8A2, "asU8A");
var toString18 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start, end) => {
    return end - start > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes3.subarray(start, end)).toString("utf8")
    ) : utf8Slice2(bytes3, start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start, end) => {
    return end - start > 64 ? textDecoder13.decode(bytes3.subarray(start, end)) : utf8Slice2(bytes3, start, end);
  }
);
var fromString18 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string8) => {
    return string8.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string8)
    ) : utf8ToBytes5(string8);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string8) => {
    return string8.length > 64 ? textEncoder14.encode(string8) : utf8ToBytes5(string8);
  }
);
var slice2 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start, end) => {
    if (isBuffer4(bytes3)) {
      return new Uint8Array(bytes3.subarray(start, end));
    }
    return bytes3.slice(start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start, end) => {
    return bytes3.slice(start, end);
  }
);
var concat6 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length21) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A2(globalThis.Buffer.concat(chunks, length21));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length21) => {
    const out = new Uint8Array(length21);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc4 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
function compare3(b1, b2) {
  if (isBuffer4(b1) && isBuffer4(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
__name(compare3, "compare");
function utf8ToBytes5(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
__name(utf8ToBytes5, "utf8ToBytes");
function utf8Slice2(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
__name(utf8Slice2, "utf8Slice");
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
__name(decodeCodePointsArray2, "decodeCodePointsArray");

// node_modules/ipns/node_modules/cborg/lib/bl.js
var defaultChunkSize2 = 256;
var Bl2 = class {
  static {
    __name(this, "Bl");
  }
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize2) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes3) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes3.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes3, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
        topChunk = alloc4(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes3, 0);
      } else {
        this.chunks.push(bytes3);
        this.maxCursor += bytes3.length;
      }
    }
    this.cursor += bytes3.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice2(chunk, 0, this.cursor);
      }
    } else {
      byts = concat6(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/ipns/node_modules/cborg/lib/common.js
var decodeErrPrefix2 = "CBOR decode error:";
var encodeErrPrefix2 = "CBOR encode error:";
var uintMinorPrefixBytes2 = [];
uintMinorPrefixBytes2[23] = 1;
uintMinorPrefixBytes2[24] = 2;
uintMinorPrefixBytes2[25] = 3;
uintMinorPrefixBytes2[26] = 5;
uintMinorPrefixBytes2[27] = 9;
function assertEnoughData2(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix2} not enough data for type`);
  }
}
__name(assertEnoughData2, "assertEnoughData");

// node_modules/ipns/node_modules/cborg/lib/0uint.js
var uintBoundaries2 = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint82(data, offset, options) {
  assertEnoughData2(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries2[0]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint82, "readUint8");
function readUint162(data, offset, options) {
  assertEnoughData2(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries2[1]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint162, "readUint16");
function readUint322(data, offset, options) {
  assertEnoughData2(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries2[2]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint322, "readUint32");
function readUint642(data, offset, options) {
  assertEnoughData2(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries2[3]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
}
__name(readUint642, "readUint64");
function decodeUint82(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
}
__name(decodeUint82, "decodeUint8");
function decodeUint162(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
}
__name(decodeUint162, "decodeUint16");
function decodeUint322(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
}
__name(decodeUint322, "decodeUint32");
function decodeUint642(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
}
__name(decodeUint642, "decodeUint64");
function encodeUint2(buf3, token) {
  return encodeUintValue2(buf3, 0, token.value);
}
__name(encodeUint2, "encodeUint");
function encodeUintValue2(buf3, major, uint) {
  if (uint < uintBoundaries2[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries2[1]) {
    const nuint = Number(uint);
    buf3.push([major | 24, nuint]);
  } else if (uint < uintBoundaries2[2]) {
    const nuint = Number(uint);
    buf3.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries2[3]) {
    const nuint = Number(uint);
    buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries2[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf3.push(set);
    } else {
      throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
    }
  }
}
__name(encodeUintValue2, "encodeUintValue");
encodeUint2.encodedSize = /* @__PURE__ */ __name(function encodedSize9(token) {
  return encodeUintValue2.encodedSize(token.value);
}, "encodedSize");
encodeUintValue2.encodedSize = /* @__PURE__ */ __name(function encodedSize10(uint) {
  if (uint < uintBoundaries2[0]) {
    return 1;
  }
  if (uint < uintBoundaries2[1]) {
    return 2;
  }
  if (uint < uintBoundaries2[2]) {
    return 3;
  }
  if (uint < uintBoundaries2[3]) {
    return 5;
  }
  return 9;
}, "encodedSize");
encodeUint2.compareTokens = /* @__PURE__ */ __name(function compareTokens4(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
}, "compareTokens");

// node_modules/ipns/node_modules/cborg/lib/1negint.js
function decodeNegint82(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
}
__name(decodeNegint82, "decodeNegint8");
function decodeNegint162(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
}
__name(decodeNegint162, "decodeNegint16");
function decodeNegint322(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
}
__name(decodeNegint322, "decodeNegint32");
var neg1b2 = BigInt(-1);
var pos1b2 = BigInt(1);
function decodeNegint642(data, pos, _minor, options) {
  const int = readUint642(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token2(Type2.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  return new Token2(Type2.negint, neg1b2 - BigInt(int), 9);
}
__name(decodeNegint642, "decodeNegint64");
function encodeNegint2(buf3, token) {
  const negint = token.value;
  const unsigned3 = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  encodeUintValue2(buf3, token.type.majorEncoded, unsigned3);
}
__name(encodeNegint2, "encodeNegint");
encodeNegint2.encodedSize = /* @__PURE__ */ __name(function encodedSize11(token) {
  const negint = token.value;
  const unsigned3 = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  if (unsigned3 < uintBoundaries2[0]) {
    return 1;
  }
  if (unsigned3 < uintBoundaries2[1]) {
    return 2;
  }
  if (unsigned3 < uintBoundaries2[2]) {
    return 3;
  }
  if (unsigned3 < uintBoundaries2[3]) {
    return 5;
  }
  return 9;
}, "encodedSize");
encodeNegint2.compareTokens = /* @__PURE__ */ __name(function compareTokens5(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
}, "compareTokens");

// node_modules/ipns/node_modules/cborg/lib/2bytes.js
function toToken5(data, pos, prefix, length21) {
  assertEnoughData2(data, pos, prefix + length21);
  const buf3 = slice2(data, pos + prefix, pos + prefix + length21);
  return new Token2(Type2.bytes, buf3, prefix + length21);
}
__name(toToken5, "toToken");
function decodeBytesCompact2(data, pos, minor, _options) {
  return toToken5(data, pos, 1, minor);
}
__name(decodeBytesCompact2, "decodeBytesCompact");
function decodeBytes82(data, pos, _minor, options) {
  return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
}
__name(decodeBytes82, "decodeBytes8");
function decodeBytes162(data, pos, _minor, options) {
  return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
}
__name(decodeBytes162, "decodeBytes16");
function decodeBytes322(data, pos, _minor, options) {
  return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
}
__name(decodeBytes322, "decodeBytes32");
function decodeBytes642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
  }
  return toToken5(data, pos, 9, l);
}
__name(decodeBytes642, "decodeBytes64");
function tokenBytes2(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type2.string ? fromString18(token.value) : token.value;
  }
  return token.encodedBytes;
}
__name(tokenBytes2, "tokenBytes");
function encodeBytes2(buf3, token) {
  const bytes3 = tokenBytes2(token);
  encodeUintValue2(buf3, token.type.majorEncoded, bytes3.length);
  buf3.push(bytes3);
}
__name(encodeBytes2, "encodeBytes");
encodeBytes2.encodedSize = /* @__PURE__ */ __name(function encodedSize12(token) {
  const bytes3 = tokenBytes2(token);
  return encodeUintValue2.encodedSize(bytes3.length) + bytes3.length;
}, "encodedSize");
encodeBytes2.compareTokens = /* @__PURE__ */ __name(function compareTokens6(tok1, tok2) {
  return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
}, "compareTokens");
function compareBytes2(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare3(b1, b2);
}
__name(compareBytes2, "compareBytes");

// node_modules/ipns/node_modules/cborg/lib/3string.js
function toToken6(data, pos, prefix, length21, options) {
  const totLength = prefix + length21;
  assertEnoughData2(data, pos, totLength);
  const tok = new Token2(Type2.string, toString18(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice2(data, pos + prefix, pos + totLength);
  }
  return tok;
}
__name(toToken6, "toToken");
function decodeStringCompact2(data, pos, minor, options) {
  return toToken6(data, pos, 1, minor, options);
}
__name(decodeStringCompact2, "decodeStringCompact");
function decodeString82(data, pos, _minor, options) {
  return toToken6(data, pos, 2, readUint82(data, pos + 1, options), options);
}
__name(decodeString82, "decodeString8");
function decodeString162(data, pos, _minor, options) {
  return toToken6(data, pos, 3, readUint162(data, pos + 1, options), options);
}
__name(decodeString162, "decodeString16");
function decodeString322(data, pos, _minor, options) {
  return toToken6(data, pos, 5, readUint322(data, pos + 1, options), options);
}
__name(decodeString322, "decodeString32");
function decodeString642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
  }
  return toToken6(data, pos, 9, l, options);
}
__name(decodeString642, "decodeString64");
var encodeString2 = encodeBytes2;

// node_modules/ipns/node_modules/cborg/lib/4array.js
function toToken7(_data, _pos, prefix, length21) {
  return new Token2(Type2.array, length21, prefix);
}
__name(toToken7, "toToken");
function decodeArrayCompact2(data, pos, minor, _options) {
  return toToken7(data, pos, 1, minor);
}
__name(decodeArrayCompact2, "decodeArrayCompact");
function decodeArray82(data, pos, _minor, options) {
  return toToken7(data, pos, 2, readUint82(data, pos + 1, options));
}
__name(decodeArray82, "decodeArray8");
function decodeArray162(data, pos, _minor, options) {
  return toToken7(data, pos, 3, readUint162(data, pos + 1, options));
}
__name(decodeArray162, "decodeArray16");
function decodeArray322(data, pos, _minor, options) {
  return toToken7(data, pos, 5, readUint322(data, pos + 1, options));
}
__name(decodeArray322, "decodeArray32");
function decodeArray642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
  }
  return toToken7(data, pos, 9, l);
}
__name(decodeArray642, "decodeArray64");
function decodeArrayIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken7(data, pos, 1, Infinity);
}
__name(decodeArrayIndefinite2, "decodeArrayIndefinite");
function encodeArray2(buf3, token) {
  encodeUintValue2(buf3, Type2.array.majorEncoded, token.value);
}
__name(encodeArray2, "encodeArray");
encodeArray2.compareTokens = encodeUint2.compareTokens;
encodeArray2.encodedSize = /* @__PURE__ */ __name(function encodedSize13(token) {
  return encodeUintValue2.encodedSize(token.value);
}, "encodedSize");

// node_modules/ipns/node_modules/cborg/lib/5map.js
function toToken8(_data, _pos, prefix, length21) {
  return new Token2(Type2.map, length21, prefix);
}
__name(toToken8, "toToken");
function decodeMapCompact2(data, pos, minor, _options) {
  return toToken8(data, pos, 1, minor);
}
__name(decodeMapCompact2, "decodeMapCompact");
function decodeMap82(data, pos, _minor, options) {
  return toToken8(data, pos, 2, readUint82(data, pos + 1, options));
}
__name(decodeMap82, "decodeMap8");
function decodeMap162(data, pos, _minor, options) {
  return toToken8(data, pos, 3, readUint162(data, pos + 1, options));
}
__name(decodeMap162, "decodeMap16");
function decodeMap322(data, pos, _minor, options) {
  return toToken8(data, pos, 5, readUint322(data, pos + 1, options));
}
__name(decodeMap322, "decodeMap32");
function decodeMap642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
  }
  return toToken8(data, pos, 9, l);
}
__name(decodeMap642, "decodeMap64");
function decodeMapIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken8(data, pos, 1, Infinity);
}
__name(decodeMapIndefinite2, "decodeMapIndefinite");
function encodeMap2(buf3, token) {
  encodeUintValue2(buf3, Type2.map.majorEncoded, token.value);
}
__name(encodeMap2, "encodeMap");
encodeMap2.compareTokens = encodeUint2.compareTokens;
encodeMap2.encodedSize = /* @__PURE__ */ __name(function encodedSize14(token) {
  return encodeUintValue2.encodedSize(token.value);
}, "encodedSize");

// node_modules/ipns/node_modules/cborg/lib/6tag.js
function decodeTagCompact2(_data, _pos, minor, _options) {
  return new Token2(Type2.tag, minor, 1);
}
__name(decodeTagCompact2, "decodeTagCompact");
function decodeTag82(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
}
__name(decodeTag82, "decodeTag8");
function decodeTag162(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
}
__name(decodeTag162, "decodeTag16");
function decodeTag322(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
}
__name(decodeTag322, "decodeTag32");
function decodeTag642(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
}
__name(decodeTag642, "decodeTag64");
function encodeTag2(buf3, token) {
  encodeUintValue2(buf3, Type2.tag.majorEncoded, token.value);
}
__name(encodeTag2, "encodeTag");
encodeTag2.compareTokens = encodeUint2.compareTokens;
encodeTag2.encodedSize = /* @__PURE__ */ __name(function encodedSize15(token) {
  return encodeUintValue2.encodedSize(token.value);
}, "encodedSize");

// node_modules/ipns/node_modules/cborg/lib/7float.js
var MINOR_FALSE2 = 20;
var MINOR_TRUE2 = 21;
var MINOR_NULL2 = 22;
var MINOR_UNDEFINED2 = 23;
function decodeUndefined2(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token2(Type2.null, null, 1);
  }
  return new Token2(Type2.undefined, void 0, 1);
}
__name(decodeUndefined2, "decodeUndefined");
function decodeBreak2(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return new Token2(Type2.break, void 0, 1);
}
__name(decodeBreak2, "decodeBreak");
function createToken2(value, bytes3, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
    }
  }
  return new Token2(Type2.float, value, bytes3);
}
__name(createToken2, "createToken");
function decodeFloat162(data, pos, _minor, options) {
  return createToken2(readFloat162(data, pos + 1), 3, options);
}
__name(decodeFloat162, "decodeFloat16");
function decodeFloat322(data, pos, _minor, options) {
  return createToken2(readFloat322(data, pos + 1), 5, options);
}
__name(decodeFloat322, "decodeFloat32");
function decodeFloat642(data, pos, _minor, options) {
  return createToken2(readFloat642(data, pos + 1), 9, options);
}
__name(decodeFloat642, "decodeFloat64");
function encodeFloat2(buf3, token, options) {
  const float = token.value;
  if (float === false) {
    buf3.push([Type2.float.majorEncoded | MINOR_FALSE2]);
  } else if (float === true) {
    buf3.push([Type2.float.majorEncoded | MINOR_TRUE2]);
  } else if (float === null) {
    buf3.push([Type2.float.majorEncoded | MINOR_NULL2]);
  } else if (float === void 0) {
    buf3.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat162(float);
      decoded = readFloat162(ui8a2, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a2[0] = 249;
        buf3.push(ui8a2.slice(0, 3));
        success = true;
      } else {
        encodeFloat322(float);
        decoded = readFloat322(ui8a2, 1);
        if (float === decoded) {
          ui8a2[0] = 250;
          buf3.push(ui8a2.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat642(float);
      decoded = readFloat642(ui8a2, 1);
      ui8a2[0] = 251;
      buf3.push(ui8a2.slice(0, 9));
    }
  }
}
__name(encodeFloat2, "encodeFloat");
encodeFloat2.encodedSize = /* @__PURE__ */ __name(function encodedSize16(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat162(float);
    let decoded = readFloat162(ui8a2, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat322(float);
    decoded = readFloat322(ui8a2, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
}, "encodedSize");
var buffer2 = new ArrayBuffer(9);
var dataView2 = new DataView(buffer2, 1);
var ui8a2 = new Uint8Array(buffer2, 0);
function encodeFloat162(inp) {
  if (inp === Infinity) {
    dataView2.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView2.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView2.setUint16(0, 32256, false);
  } else {
    dataView2.setFloat32(0, inp);
    const valu32 = dataView2.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView2.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView2.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
__name(encodeFloat162, "encodeFloat16");
function readFloat162(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix2} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
__name(readFloat162, "readFloat16");
function encodeFloat322(inp) {
  dataView2.setFloat32(0, inp, false);
}
__name(encodeFloat322, "encodeFloat32");
function readFloat322(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix2} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
__name(readFloat322, "readFloat32");
function encodeFloat642(inp) {
  dataView2.setFloat64(0, inp, false);
}
__name(encodeFloat642, "encodeFloat64");
function readFloat642(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix2} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
__name(readFloat642, "readFloat64");
encodeFloat2.compareTokens = encodeUint2.compareTokens;

// node_modules/ipns/node_modules/cborg/lib/jump.js
function invalidMinor2(data, pos, minor) {
  throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
__name(invalidMinor2, "invalidMinor");
function errorer2(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix2} ${msg}`);
  };
}
__name(errorer2, "errorer");
var jump2 = [];
for (let i = 0; i <= 23; i++) {
  jump2[i] = invalidMinor2;
}
jump2[24] = decodeUint82;
jump2[25] = decodeUint162;
jump2[26] = decodeUint322;
jump2[27] = decodeUint642;
jump2[28] = invalidMinor2;
jump2[29] = invalidMinor2;
jump2[30] = invalidMinor2;
jump2[31] = invalidMinor2;
for (let i = 32; i <= 55; i++) {
  jump2[i] = invalidMinor2;
}
jump2[56] = decodeNegint82;
jump2[57] = decodeNegint162;
jump2[58] = decodeNegint322;
jump2[59] = decodeNegint642;
jump2[60] = invalidMinor2;
jump2[61] = invalidMinor2;
jump2[62] = invalidMinor2;
jump2[63] = invalidMinor2;
for (let i = 64; i <= 87; i++) {
  jump2[i] = decodeBytesCompact2;
}
jump2[88] = decodeBytes82;
jump2[89] = decodeBytes162;
jump2[90] = decodeBytes322;
jump2[91] = decodeBytes642;
jump2[92] = invalidMinor2;
jump2[93] = invalidMinor2;
jump2[94] = invalidMinor2;
jump2[95] = errorer2("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump2[i] = decodeStringCompact2;
}
jump2[120] = decodeString82;
jump2[121] = decodeString162;
jump2[122] = decodeString322;
jump2[123] = decodeString642;
jump2[124] = invalidMinor2;
jump2[125] = invalidMinor2;
jump2[126] = invalidMinor2;
jump2[127] = errorer2("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump2[i] = decodeArrayCompact2;
}
jump2[152] = decodeArray82;
jump2[153] = decodeArray162;
jump2[154] = decodeArray322;
jump2[155] = decodeArray642;
jump2[156] = invalidMinor2;
jump2[157] = invalidMinor2;
jump2[158] = invalidMinor2;
jump2[159] = decodeArrayIndefinite2;
for (let i = 160; i <= 183; i++) {
  jump2[i] = decodeMapCompact2;
}
jump2[184] = decodeMap82;
jump2[185] = decodeMap162;
jump2[186] = decodeMap322;
jump2[187] = decodeMap642;
jump2[188] = invalidMinor2;
jump2[189] = invalidMinor2;
jump2[190] = invalidMinor2;
jump2[191] = decodeMapIndefinite2;
for (let i = 192; i <= 215; i++) {
  jump2[i] = decodeTagCompact2;
}
jump2[216] = decodeTag82;
jump2[217] = decodeTag162;
jump2[218] = decodeTag322;
jump2[219] = decodeTag642;
jump2[220] = invalidMinor2;
jump2[221] = invalidMinor2;
jump2[222] = invalidMinor2;
jump2[223] = invalidMinor2;
for (let i = 224; i <= 243; i++) {
  jump2[i] = errorer2("simple values are not supported");
}
jump2[244] = invalidMinor2;
jump2[245] = invalidMinor2;
jump2[246] = invalidMinor2;
jump2[247] = decodeUndefined2;
jump2[248] = errorer2("simple values are not supported");
jump2[249] = decodeFloat162;
jump2[250] = decodeFloat322;
jump2[251] = decodeFloat642;
jump2[252] = invalidMinor2;
jump2[253] = invalidMinor2;
jump2[254] = invalidMinor2;
jump2[255] = decodeBreak2;
var quick2 = [];
for (let i = 0; i < 24; i++) {
  quick2[i] = new Token2(Type2.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick2[31 - i] = new Token2(Type2.negint, i, 1);
}
quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
quick2[96] = new Token2(Type2.string, "", 1);
quick2[128] = new Token2(Type2.array, 0, 1);
quick2[160] = new Token2(Type2.map, 0, 1);
quick2[244] = new Token2(Type2.false, false, 1);
quick2[245] = new Token2(Type2.true, true, 1);
quick2[246] = new Token2(Type2.null, null, 1);

// node_modules/ipns/node_modules/cborg/lib/encode.js
function makeCborEncoders2() {
  const encoders = [];
  encoders[Type2.uint.major] = encodeUint2;
  encoders[Type2.negint.major] = encodeNegint2;
  encoders[Type2.bytes.major] = encodeBytes2;
  encoders[Type2.string.major] = encodeString2;
  encoders[Type2.array.major] = encodeArray2;
  encoders[Type2.map.major] = encodeMap2;
  encoders[Type2.tag.major] = encodeTag2;
  encoders[Type2.float.major] = encodeFloat2;
  return encoders;
}
__name(makeCborEncoders2, "makeCborEncoders");
var cborEncoders2 = makeCborEncoders2();
var buf2 = new Bl2();
var Ref2 = class _Ref {
  static {
    __name(this, "Ref");
  }
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix2} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens2 = {
  null: new Token2(Type2.null, null),
  undefined: new Token2(Type2.undefined, void 0),
  true: new Token2(Type2.true, true),
  false: new Token2(Type2.false, false),
  emptyArray: new Token2(Type2.array, 0),
  emptyMap: new Token2(Type2.map, 0)
};
var typeEncoders2 = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token2(Type2.float, obj);
    } else if (obj >= 0) {
      return new Token2(Type2.uint, obj);
    } else {
      return new Token2(Type2.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token2(Type2.uint, obj);
    } else {
      return new Token2(Type2.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token2(Type2.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token2(Type2.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens2.true : simpleTokens2.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens2.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens2.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token2(Type2.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [simpleTokens2.emptyArray, new Token2(Type2.break)];
      }
      return simpleTokens2.emptyArray;
    }
    refStack = Ref2.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens2(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [new Token2(Type2.array, obj.length), entries, new Token2(Type2.break)];
    }
    return [new Token2(Type2.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length21 = isMap ? obj.size : keys.length;
    if (!length21) {
      if (options.addBreakTokens === true) {
        return [simpleTokens2.emptyMap, new Token2(Type2.break)];
      }
      return simpleTokens2.emptyMap;
    }
    refStack = Ref2.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens2(key, options, refStack),
        objectToTokens2(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries2(entries, options);
    if (options.addBreakTokens) {
      return [new Token2(Type2.map, length21), entries, new Token2(Type2.break)];
    }
    return [new Token2(Type2.map, length21), entries];
  }
};
typeEncoders2.Map = typeEncoders2.Object;
typeEncoders2.Buffer = typeEncoders2.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
}
function objectToTokens2(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders2[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders2[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
__name(objectToTokens2, "objectToTokens");
function sortMapEntries2(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
__name(sortMapEntries2, "sortMapEntries");

// node_modules/ipns/node_modules/cborg/lib/decode.js
var defaultDecodeOptions2 = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser2 = class {
  static {
    __name(this, "Tokeniser");
  }
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick2[byt];
    if (token === void 0) {
      const decoder = jump2[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE2 = Symbol.for("DONE");
var BREAK2 = Symbol.for("BREAK");
function tokenToArray2(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject2(tokeniser, options);
    if (value === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
    }
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
__name(tokenToArray2, "tokenToArray");
function tokenToMap2(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject2(tokeniser, options);
    if (key === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
    }
    if (key === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix2} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject2(tokeniser, options);
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
__name(tokenToMap2, "tokenToMap");
function tokensToObject2(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE2;
  }
  const token = tokeniser.next();
  if (token.type === Type2.break) {
    return BREAK2;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type2.array) {
    return tokenToArray2(token, tokeniser, options);
  }
  if (token.type === Type2.map) {
    return tokenToMap2(token, tokeniser, options);
  }
  if (token.type === Type2.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject2(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
__name(tokensToObject2, "tokensToObject");
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions2, options);
  const tokeniser = options.tokenizer || new Tokeniser2(data, options);
  const decoded = tokensToObject2(tokeniser, options);
  if (decoded === DONE2) {
    throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
  }
  if (decoded === BREAK2) {
    throw new Error(`${decodeErrPrefix2} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
__name(decodeFirst, "decodeFirst");
function decode92(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
  }
  return decoded;
}
__name(decode92, "decode");

// node_modules/ipns/dist/src/utils.js
var import_err_code4 = __toESM(require_err_code(), 1);

// node_modules/ipns/dist/src/errors.js
var ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
var ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
var ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
var ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
var ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
var ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
var ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
var ERR_RECORD_TOO_LARGE = "ERR_RECORD_TOO_LARGE";

// node_modules/ipns/dist/src/utils.js
var log46 = logger20("ipns:utils");
var IPNS_PREFIX = fromString7("/ipns/");
function parseRFC33392(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m2 = String(time).trim().match(rfc3339Matcher);
  if (m2 == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m2[1], 10);
  const month = parseInt(m2[2], 10) - 1;
  const date = parseInt(m2[3], 10);
  const hour2 = parseInt(m2[4], 10);
  const minute4 = parseInt(m2[5], 10);
  const second4 = parseInt(m2[6], 10);
  const millisecond = parseInt(m2[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute4, second4, millisecond));
}
__name(parseRFC33392, "parseRFC3339");
var extractPublicKey = /* @__PURE__ */ __name(async (peerId, entry) => {
  if (entry == null || peerId == null) {
    const error = new Error("one or more of the provided parameters are not defined");
    log46.error(error);
    throw (0, import_err_code4.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey3(entry.pubKey);
    } catch (err) {
      log46.error(err);
      throw err;
    }
    const otherId = await peerIdFromKeys2(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw (0, import_err_code4.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.publicKey != null) {
    pubKey = unmarshalPublicKey3(peerId.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw (0, import_err_code4.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
}, "extractPublicKey");
var ipnsEntryDataForV2Sig = /* @__PURE__ */ __name((data) => {
  const entryData = fromString7("ipns-signature:");
  return concat3([entryData, data]);
}, "ipnsEntryDataForV2Sig");
var unmarshal = /* @__PURE__ */ __name((buf3) => {
  const message2 = IpnsEntry.decode(buf3);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  return {
    value: message2.value ?? new Uint8Array(0),
    signature: message2.signature ?? new Uint8Array(0),
    validityType: message2.validityType ?? IpnsEntry.ValidityType.EOL,
    validity: message2.validity ?? new Uint8Array(0),
    sequence: message2.sequence ?? 0n,
    pubKey: message2.pubKey,
    ttl: message2.ttl ?? void 0,
    signatureV2: message2.signatureV2,
    data: message2.data
  };
}, "unmarshal");
var peerIdFromRoutingKey = /* @__PURE__ */ __name((key) => {
  return peerIdFromBytes2(key.slice(IPNS_PREFIX.length));
}, "peerIdFromRoutingKey");
var parseCborData = /* @__PURE__ */ __name((buf3) => {
  const data = decode92(buf3);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw (0, import_err_code4.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
}, "parseCborData");

// node_modules/ipns/dist/src/selector.js
function ipnsSelector(key, data) {
  const entries = data.map((buf3, index) => ({
    entry: IpnsEntry.decode(buf3),
    index
  }));
  entries.sort((a, b) => {
    if (a.entry.signatureV2 != null && b.entry.signatureV2 == null) {
      return -1;
    } else if (a.entry.signatureV2 == null && b.entry.signatureV2 != null) {
      return 1;
    }
    const aSeq = a.entry.sequence ?? 0n;
    const bSeq = b.entry.sequence ?? 0n;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    const aValidty = a.entry.validity ?? new Uint8Array(0);
    const bValidty = b.entry.validity ?? new Uint8Array(0);
    const entryAValidityDate = parseRFC33392(toString5(aValidty));
    const entryBValidityDate = parseRFC33392(toString5(bValidty));
    if (entryAValidityDate.getTime() > entryBValidityDate.getTime()) {
      return -1;
    }
    if (entryAValidityDate.getTime() < entryBValidityDate.getTime()) {
      return 1;
    }
    return 0;
  });
  return entries[0].index;
}
__name(ipnsSelector, "ipnsSelector");

// node_modules/ipns/dist/src/validator.js
var import_err_code5 = __toESM(require_err_code(), 1);
var log47 = logger20("ipns:validator");
var MAX_RECORD_SIZE = 1024 * 10;
var validate2 = /* @__PURE__ */ __name(async (publicKey, entry) => {
  const { value, validityType, validity } = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 != null && entry.data != null) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    throw (0, import_err_code5.default)(new Error("missing data or signatureV2"), ERR_SIGNATURE_VERIFICATION);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log47.error("record signature verification failed");
    throw (0, import_err_code5.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC33392(toString5(validity));
    } catch (e) {
      log47.error("unrecognized validity format (not an rfc3339 format)");
      throw (0, import_err_code5.default)(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log47.error("record has expired");
      throw (0, import_err_code5.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType != null) {
    log47.error("unrecognized validity type");
    throw (0, import_err_code5.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log47("ipns entry for %b is valid", value);
}, "validate");
var validateCborDataMatchesPbData = /* @__PURE__ */ __name((entry) => {
  if (entry.data == null) {
    throw (0, import_err_code5.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals7(data.Value, entry.value)) {
    throw (0, import_err_code5.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals7(data.Validity, entry.validity)) {
    throw (0, import_err_code5.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw (0, import_err_code5.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw (0, import_err_code5.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw (0, import_err_code5.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
}, "validateCborDataMatchesPbData");
async function ipnsValidator(key, marshalledData) {
  if (marshalledData.byteLength > MAX_RECORD_SIZE) {
    throw (0, import_err_code5.default)(new Error("record too large"), ERR_RECORD_TOO_LARGE);
  }
  const peerId = peerIdFromRoutingKey(key);
  const receivedEntry = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId, receivedEntry);
  await validate2(pubKey, receivedEntry);
}
__name(ipnsValidator, "ipnsValidator");

// node_modules/libp2p/dist/src/autonat/index.js
var import_events28 = __toESM(require_events(), 1);

// node_modules/libp2p/dist/src/autonat/constants.js
var PROTOCOL_PREFIX2 = "libp2p";
var PROTOCOL_NAME = "autonat";
var PROTOCOL_VERSION = "1.0.0";
var TIMEOUT = 3e4;
var STARTUP_DELAY = 5e3;
var REFRESH_INTERVAL = 6e4;
var MAX_INBOUND_STREAMS = 1;
var MAX_OUTBOUND_STREAMS = 1;

// node_modules/libp2p/dist/src/autonat/pb/index.js
var Message6;
(function(Message7) {
  let MessageType2;
  (function(MessageType3) {
    MessageType3["DIAL"] = "DIAL";
    MessageType3["DIAL_RESPONSE"] = "DIAL_RESPONSE";
  })(MessageType2 = Message7.MessageType || (Message7.MessageType = {}));
  let __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["DIAL"] = 0] = "DIAL";
    __MessageTypeValues2[__MessageTypeValues2["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType3) {
    MessageType3.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(MessageType2 = Message7.MessageType || (Message7.MessageType = {}));
  let ResponseStatus;
  (function(ResponseStatus2) {
    ResponseStatus2["OK"] = "OK";
    ResponseStatus2["E_DIAL_ERROR"] = "E_DIAL_ERROR";
    ResponseStatus2["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
    ResponseStatus2["E_BAD_REQUEST"] = "E_BAD_REQUEST";
    ResponseStatus2["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
  })(ResponseStatus = Message7.ResponseStatus || (Message7.ResponseStatus = {}));
  let __ResponseStatusValues;
  (function(__ResponseStatusValues2) {
    __ResponseStatusValues2[__ResponseStatusValues2["OK"] = 0] = "OK";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
    __ResponseStatusValues2[__ResponseStatusValues2["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
    __ResponseStatusValues2[__ResponseStatusValues2["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
  })(__ResponseStatusValues || (__ResponseStatusValues = {}));
  (function(ResponseStatus2) {
    ResponseStatus2.codec = () => {
      return enumeration(__ResponseStatusValues);
    };
  })(ResponseStatus = Message7.ResponseStatus || (Message7.ResponseStatus = {}));
  let PeerInfo;
  (function(PeerInfo2) {
    let _codec2;
    PeerInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.id != null) {
            w2.uint32(10);
            w2.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              w2.uint32(18);
              w2.bytes(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {
            addrs: []
          };
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.addrs.push(reader2.bytes());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    PeerInfo2.encode = (obj) => {
      return encodeMessage(obj, PeerInfo2.codec());
    };
    PeerInfo2.decode = (buf3) => {
      return decodeMessage(buf3, PeerInfo2.codec());
    };
  })(PeerInfo = Message7.PeerInfo || (Message7.PeerInfo = {}));
  let Dial;
  (function(Dial2) {
    let _codec2;
    Dial2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.peer != null) {
            w2.uint32(10);
            Message7.PeerInfo.codec().encode(obj.peer, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {};
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.peer = Message7.PeerInfo.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Dial2.encode = (obj) => {
      return encodeMessage(obj, Dial2.codec());
    };
    Dial2.decode = (buf3) => {
      return decodeMessage(buf3, Dial2.codec());
    };
  })(Dial = Message7.Dial || (Message7.Dial = {}));
  let DialResponse;
  (function(DialResponse2) {
    let _codec2;
    DialResponse2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.status != null) {
            w2.uint32(8);
            Message7.ResponseStatus.codec().encode(obj.status, w2);
          }
          if (obj.statusText != null) {
            w2.uint32(18);
            w2.string(obj.statusText);
          }
          if (obj.addr != null) {
            w2.uint32(26);
            w2.bytes(obj.addr);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader2, length21) => {
          const obj = {};
          const end = length21 == null ? reader2.len : reader2.pos + length21;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.status = Message7.ResponseStatus.codec().decode(reader2);
                break;
              case 2:
                obj.statusText = reader2.string();
                break;
              case 3:
                obj.addr = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    DialResponse2.encode = (obj) => {
      return encodeMessage(obj, DialResponse2.codec());
    };
    DialResponse2.decode = (buf3) => {
      return decodeMessage(buf3, DialResponse2.codec());
    };
  })(DialResponse = Message7.DialResponse || (Message7.DialResponse = {}));
  let _codec;
  Message7.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          Message7.MessageType.codec().encode(obj.type, w2);
        }
        if (obj.dial != null) {
          w2.uint32(18);
          Message7.Dial.codec().encode(obj.dial, w2);
        }
        if (obj.dialResponse != null) {
          w2.uint32(26);
          Message7.DialResponse.codec().encode(obj.dialResponse, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message7.MessageType.codec().decode(reader2);
              break;
            case 2:
              obj.dial = Message7.Dial.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.dialResponse = Message7.DialResponse.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message7.encode = (obj) => {
    return encodeMessage(obj, Message7.codec());
  };
  Message7.decode = (buf3) => {
    return decodeMessage(buf3, Message7.codec());
  };
})(Message6 || (Message6 = {}));

// node_modules/libp2p/dist/src/autonat/index.js
var log48 = logger6("libp2p:autonat");
var REQUIRED_SUCCESSFUL_DIALS = 4;
var DefaultAutoNATService = class {
  static {
    __name(this, "DefaultAutoNATService");
  }
  components;
  startupDelay;
  refreshInterval;
  protocol;
  timeout;
  maxInboundStreams;
  maxOutboundStreams;
  verifyAddressTimeout;
  started;
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.startupDelay = init.startupDelay ?? STARTUP_DELAY;
    this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
    this._verifyExternalAddresses = this._verifyExternalAddresses.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleIncomingAutonatStream(data).catch((err) => {
        log48.error("error handling incoming autonat stream", err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    });
    this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.startupDelay);
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    clearTimeout(this.verifyAddressTimeout);
    this.started = false;
  }
  /**
   * Handle an incoming AutoNAT request
   */
  async handleIncomingAutonatStream(data) {
    const signal = anySignal([AbortSignal.timeout(this.timeout)]);
    try {
      (0, import_events28.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    const ourHosts = this.components.addressManager.getAddresses().map((ma) => ma.toOptions().host);
    try {
      const source = abortableDuplex(data.stream, signal);
      const self2 = this;
      await pipe(
        source,
        (source2) => decode21(source2),
        async function* (stream) {
          const buf3 = await src_default12(stream);
          if (buf3 == null) {
            log48("no message received");
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_BAD_REQUEST,
                statusText: "No message was sent"
              }
            });
            return;
          }
          let request;
          try {
            request = Message6.decode(buf3);
          } catch (err) {
            log48.error("could not decode message", err);
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_BAD_REQUEST,
                statusText: "Could not decode message"
              }
            });
            return;
          }
          const dialRequest = request.dial;
          if (dialRequest == null) {
            log48.error("dial was missing from message");
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_BAD_REQUEST,
                statusText: "No Dial message found in message"
              }
            });
            return;
          }
          let peerId;
          const peer = dialRequest.peer;
          if (peer == null || peer.id == null) {
            log48.error("PeerId missing from message");
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_BAD_REQUEST,
                statusText: "missing peer info"
              }
            });
            return;
          }
          try {
            peerId = peerIdFromBytes(peer.id);
          } catch (err) {
            log48.error("invalid PeerId", err);
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_BAD_REQUEST,
                statusText: "bad peer id"
              }
            });
            return;
          }
          log48("incoming request from %p", peerId);
          if (!data.connection.remotePeer.equals(peerId)) {
            log48("target peer %p did not equal sending peer %p", peerId, data.connection.remotePeer);
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_BAD_REQUEST,
                statusText: "peer id mismatch"
              }
            });
            return;
          }
          const multiaddrs = peer.addrs.map((buf4) => multiaddr(buf4)).filter((ma) => {
            const isFromSameHost = ma.toOptions().host === data.connection.remoteAddr.toOptions().host;
            log48.trace("request to dial %s was sent from %s is same host %s", ma, data.connection.remoteAddr, isFromSameHost);
            return isFromSameHost;
          }).filter((ma) => {
            const host = ma.toOptions().host;
            const isPublicIp = !(private_ip_default(host) ?? false);
            log48.trace("host %s was public %s", host, isPublicIp);
            return isPublicIp;
          }).filter((ma) => {
            const host = ma.toOptions().host;
            const isNotOurHost = !ourHosts.includes(host);
            log48.trace("host %s was not our host %s", host, isNotOurHost);
            return isNotOurHost;
          }).filter((ma) => {
            const isSupportedTransport = Boolean(self2.components.transportManager.transportForMultiaddr(ma));
            log48.trace("transport for %s is supported %s", ma, isSupportedTransport);
            return isSupportedTransport;
          }).map((ma) => {
            if (ma.getPeerId() == null) {
              ma = ma.encapsulate(`/p2p/${peerId.toString()}`);
            }
            return ma;
          });
          if (multiaddrs.length === 0) {
            log48("no valid multiaddrs for %p in message", peerId);
            yield Message6.encode({
              type: Message6.MessageType.DIAL_RESPONSE,
              dialResponse: {
                status: Message6.ResponseStatus.E_DIAL_REFUSED,
                statusText: "no dialable addresses"
              }
            });
            return;
          }
          log48("dial multiaddrs %s for peer %p", multiaddrs.map((ma) => ma.toString()).join(", "), peerId);
          let errorMessage = "";
          let lastMultiaddr = multiaddrs[0];
          for await (const multiaddr2 of multiaddrs) {
            let connection;
            lastMultiaddr = multiaddr2;
            try {
              connection = await self2.components.connectionManager.openConnection(multiaddr2, {
                signal
              });
              if (!connection.remoteAddr.equals(multiaddr2)) {
                log48.error("tried to dial %s but dialed %s", multiaddr2, connection.remoteAddr);
                throw new Error("Unexpected remote address");
              }
              log48("Success %p", peerId);
              yield Message6.encode({
                type: Message6.MessageType.DIAL_RESPONSE,
                dialResponse: {
                  status: Message6.ResponseStatus.OK,
                  addr: connection.remoteAddr.decapsulateCode(getProtocol("p2p").code).bytes
                }
              });
              return;
            } catch (err) {
              log48("could not dial %p", peerId, err);
              errorMessage = err.message;
            } finally {
              if (connection != null) {
                await connection.close();
              }
            }
          }
          yield Message6.encode({
            type: Message6.MessageType.DIAL_RESPONSE,
            dialResponse: {
              status: Message6.ResponseStatus.E_DIAL_ERROR,
              statusText: errorMessage,
              addr: lastMultiaddr.bytes
            }
          });
        },
        (source2) => encode16(source2),
        // pipe to the stream, not the abortable source other wise we
        // can't tell the remote when a dial timed out..
        data.stream
      );
    } catch (err) {
      log48.error("error handling incoming autonat stream", err);
    } finally {
      signal.clear();
    }
  }
  _verifyExternalAddresses() {
    void this.verifyExternalAddresses().catch((err) => {
      log48.error("error verifying external address", err);
    });
  }
  /**
   * Our multicodec topology noticed a new peer that supports autonat
   */
  async verifyExternalAddresses() {
    clearTimeout(this.verifyAddressTimeout);
    if (!this.isStarted()) {
      return;
    }
    const addressManager = this.components.addressManager;
    const multiaddrs = addressManager.getObservedAddrs().filter((ma) => {
      const options = ma.toOptions();
      return !(private_ip_default(options.host) ?? false);
    });
    if (multiaddrs.length === 0) {
      log48("no public addresses found, not requesting verification");
      this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);
      return;
    }
    const signal = AbortSignal.timeout(this.timeout);
    try {
      (0, import_events28.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    const self2 = this;
    try {
      log48("verify multiaddrs %s", multiaddrs.map((ma) => ma.toString()).join(", "));
      const request = Message6.encode({
        type: Message6.MessageType.DIAL,
        dial: {
          peer: {
            id: this.components.peerId.toBytes(),
            addrs: multiaddrs.map((map3) => map3.bytes)
          }
        }
      });
      const randomPeer = await createEd25519PeerId();
      const randomCid = randomPeer.toBytes();
      const results = {};
      const networkSegments = [];
      const verifyAddress = /* @__PURE__ */ __name(async (peer) => {
        try {
          log48("asking %p to verify multiaddr", peer.id);
          const connection = await self2.components.connectionManager.openConnection(peer.id, {
            signal
          });
          const stream = await connection.newStream(this.protocol, {
            signal
          });
          const source = abortableDuplex(stream, signal);
          const buf3 = await pipe([request], (source2) => encode16(source2), source, (source2) => decode21(source2), async (stream2) => src_default12(stream2));
          if (buf3 == null) {
            log48("no response received from %p", connection.remotePeer);
            return void 0;
          }
          const response = Message6.decode(buf3);
          if (response.type !== Message6.MessageType.DIAL_RESPONSE || response.dialResponse == null) {
            log48("invalid autonat response from %p", connection.remotePeer);
            return void 0;
          }
          if (response.dialResponse.status === Message6.ResponseStatus.OK) {
            const options = connection.remoteAddr.toOptions();
            let segment;
            if (options.family === 4) {
              const octets = options.host.split(".");
              segment = octets[0];
            } else if (options.family === 6) {
              const octets = options.host.split(":");
              segment = octets[0];
            } else {
              log48('remote address "%s" was not IP4 or IP6?', options.host);
              return void 0;
            }
            if (networkSegments.includes(segment)) {
              log48("already have response from network segment %d - %s", segment, options.host);
              return void 0;
            }
            networkSegments.push(segment);
          }
          return response.dialResponse;
        } catch (err) {
          log48.error("error asking remote to verify multiaddr", err);
        }
      }, "verifyAddress");
      for await (const dialResponse of parallel(src_default9(this.components.peerRouting.getClosestPeers(randomCid, {
        signal
      }), (peer) => async () => verifyAddress(peer)), {
        concurrency: REQUIRED_SUCCESSFUL_DIALS
      })) {
        try {
          if (dialResponse == null) {
            continue;
          }
          const addr = dialResponse.addr == null ? multiaddrs[0] : multiaddr(dialResponse.addr);
          log48("autonat response for %a is %s", addr, dialResponse.status);
          if (dialResponse.status === Message6.ResponseStatus.E_BAD_REQUEST) {
            continue;
          }
          if (dialResponse.status === Message6.ResponseStatus.E_DIAL_REFUSED) {
            continue;
          }
          if (dialResponse.addr == null && multiaddrs.length > 1) {
            continue;
          }
          if (!multiaddrs.some((ma) => ma.equals(addr))) {
            log48("peer reported %a as %s but it was not in our observed address list", addr, dialResponse.status);
            continue;
          }
          const addrStr = addr.toString();
          if (results[addrStr] == null) {
            results[addrStr] = { success: 0, failure: 0 };
          }
          if (dialResponse.status === Message6.ResponseStatus.OK) {
            results[addrStr].success++;
          } else if (dialResponse.status === Message6.ResponseStatus.E_DIAL_ERROR) {
            results[addrStr].failure++;
          }
          if (results[addrStr].success === REQUIRED_SUCCESSFUL_DIALS) {
            log48("%a is externally dialable", addr);
            addressManager.confirmObservedAddr(addr);
            return;
          }
          if (results[addrStr].failure === REQUIRED_SUCCESSFUL_DIALS) {
            log48("%a is not externally dialable", addr);
            addressManager.removeObservedAddr(addr);
            return;
          }
        } catch (err) {
          log48.error("could not verify external address", err);
        }
      }
    } finally {
      this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);
    }
  }
};
function autoNATService(init = {}) {
  return (components) => {
    return new DefaultAutoNATService(components, init);
  };
}
__name(autoNATService, "autoNATService");

// node_modules/libp2p/dist/src/circuit-relay/server/index.js
var import_events30 = __toESM(require_events(), 1);

// node_modules/libp2p/dist/src/circuit-relay/constants.js
var second3 = 1e3;
var minute3 = 60 * second3;
var ADVERTISE_BOOT_DELAY = 15 * minute3;
var ADVERTISE_TTL = 30 * minute3;
var CIRCUIT_PROTO_CODE = 290;
var RELAY_RENDEZVOUS_NS = "/libp2p/relay";
var DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second3;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute3;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var RELAY_TAG = "circuit-relay-relay";
var DEFAULT_DURATION_LIMIT = 2 * minute3;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second3;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second3;

// node_modules/libp2p/dist/src/circuit-relay/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type3;
  (function(Type4) {
    Type4["RESERVE"] = "RESERVE";
    Type4["CONNECT"] = "CONNECT";
    Type4["STATUS"] = "STATUS";
  })(Type3 = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w2);
        }
        if (obj.peer != null) {
          w2.uint32(18);
          Peer2.codec().encode(obj.peer, w2);
        }
        if (obj.reservation != null) {
          w2.uint32(26);
          Reservation.codec().encode(obj.reservation, w2);
        }
        if (obj.limit != null) {
          w2.uint32(34);
          Limit.codec().encode(obj.limit, w2);
        }
        if (obj.status != null) {
          w2.uint32(40);
          Status.codec().encode(obj.status, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = HopMessage2.Type.codec().decode(reader2);
              break;
            case 2:
              obj.peer = Peer2.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.reservation = Reservation.codec().decode(reader2, reader2.uint32());
              break;
            case 4:
              obj.limit = Limit.codec().decode(reader2, reader2.uint32());
              break;
            case 5:
              obj.status = Status.codec().decode(reader2);
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf3) => {
    return decodeMessage(buf3, HopMessage2.codec());
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type3;
  (function(Type4) {
    Type4["CONNECT"] = "CONNECT";
    Type4["STATUS"] = "STATUS";
  })(Type3 = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w2);
        }
        if (obj.peer != null) {
          w2.uint32(18);
          Peer2.codec().encode(obj.peer, w2);
        }
        if (obj.limit != null) {
          w2.uint32(26);
          Limit.codec().encode(obj.limit, w2);
        }
        if (obj.status != null) {
          w2.uint32(32);
          Status.codec().encode(obj.status, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = StopMessage2.Type.codec().decode(reader2);
              break;
            case 2:
              obj.peer = Peer2.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.limit = Limit.codec().decode(reader2, reader2.uint32());
              break;
            case 4:
              obj.status = Status.codec().decode(reader2);
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf3) => {
    return decodeMessage(buf3, StopMessage2.codec());
  };
})(StopMessage || (StopMessage = {}));
var Peer2;
(function(Peer3) {
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          id: new Uint8Array(0),
          addrs: []
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader2.bytes();
              break;
            case 2:
              obj.addrs.push(reader2.bytes());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf3) => {
    return decodeMessage(buf3, Peer3.codec());
  };
})(Peer2 || (Peer2 = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w2.uint32(8);
          w2.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (obj.voucher != null) {
          w2.uint32(26);
          w2.bytes(obj.voucher);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.expire = reader2.uint64();
              break;
            case 2:
              obj.addrs.push(reader2.bytes());
              break;
            case 3:
              obj.voucher = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf3) => {
    return decodeMessage(buf3, Reservation2.codec());
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.duration != null) {
          w2.uint32(8);
          w2.uint32(obj.duration);
        }
        if (obj.data != null) {
          w2.uint32(16);
          w2.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {};
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.duration = reader2.uint32();
              break;
            case 2:
              obj.data = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf3) => {
    return decodeMessage(buf3, Limit2.codec());
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w2.uint32(24);
          w2.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          relay: new Uint8Array(0),
          peer: new Uint8Array(0),
          expiration: 0n
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.relay = reader2.bytes();
              break;
            case 2:
              obj.peer = reader2.bytes();
              break;
            case 3:
              obj.expiration = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf3) => {
    return decodeMessage(buf3, ReservationVoucher2.codec());
  };
})(ReservationVoucher || (ReservationVoucher = {}));

// node_modules/libp2p/node_modules/multiformats/vendor/varint.js
var encode_118 = encode77;
var MSB20 = 128;
var REST20 = 127;
var MSBALL18 = ~REST20;
var INT18 = Math.pow(2, 31);
function encode77(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT18) {
    out[offset++] = num & 255 | MSB20;
    num /= 128;
  }
  while (num & MSBALL18) {
    out[offset++] = num & 255 | MSB20;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode77.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode77, "encode");
var decode93 = read20;
var MSB$118 = 128;
var REST$118 = 127;
function read20(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read20.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$118) << shift : (b & REST$118) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$118);
  read20.bytes = counter - offset;
  return res;
}
__name(read20, "read");
var N121 = Math.pow(2, 7);
var N221 = Math.pow(2, 14);
var N321 = Math.pow(2, 21);
var N421 = Math.pow(2, 28);
var N521 = Math.pow(2, 35);
var N621 = Math.pow(2, 42);
var N721 = Math.pow(2, 49);
var N820 = Math.pow(2, 56);
var N920 = Math.pow(2, 63);
var length20 = /* @__PURE__ */ __name(function(value) {
  return value < N121 ? 1 : value < N221 ? 2 : value < N321 ? 3 : value < N421 ? 4 : value < N521 ? 5 : value < N621 ? 6 : value < N721 ? 7 : value < N820 ? 8 : value < N920 ? 9 : 10;
}, "length");
var varint21 = {
  encode: encode_118,
  decode: decode93,
  encodingLength: length20
};
var _brrp_varint18 = varint21;
var varint_default18 = _brrp_varint18;

// node_modules/libp2p/node_modules/multiformats/src/varint.js
var decode94 = /* @__PURE__ */ __name((data, offset = 0) => {
  const code16 = varint_default18.decode(data, offset);
  return [code16, varint_default18.decode.bytes];
}, "decode");
var encodeTo18 = /* @__PURE__ */ __name((int, target, offset = 0) => {
  varint_default18.encode(int, target, offset);
  return target;
}, "encodeTo");
var encodingLength19 = /* @__PURE__ */ __name((int) => {
  return varint_default18.encodingLength(int);
}, "encodingLength");

// node_modules/libp2p/node_modules/multiformats/src/hashes/digest.js
var create22 = /* @__PURE__ */ __name((code16, digest13) => {
  const size = digest13.byteLength;
  const sizeOffset = encodingLength19(code16);
  const digestOffset = sizeOffset + encodingLength19(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo18(code16, bytes3, 0);
  encodeTo18(size, bytes3, sizeOffset);
  bytes3.set(digest13, digestOffset);
  return new Digest18(code16, size, digest13, bytes3);
}, "create");
var decode95 = /* @__PURE__ */ __name((multihash) => {
  const bytes3 = coerce11(multihash);
  const [code16, sizeOffset] = decode94(bytes3);
  const [size, digestOffset] = decode94(bytes3.subarray(sizeOffset));
  const digest13 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest13.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest18(code16, size, digest13, bytes3);
}, "decode");
var equals35 = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals18(a.bytes, data.bytes);
  }
}, "equals");
var Digest18 = class {
  static {
    __name(this, "Digest");
  }
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code16, size, digest13, bytes3) {
    this.code = code16;
    this.size = size;
    this.digest = digest13;
    this.bytes = bytes3;
  }
};

// node_modules/libp2p/node_modules/multiformats/src/cid.js
var format13 = /* @__PURE__ */ __name((link, base42) => {
  const { bytes: bytes3, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV014(
        bytes3,
        baseCache13(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base42 || base58btc11.encoder
      );
    default:
      return toStringV114(
        bytes3,
        baseCache13(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base42 || base3210.encoder
      );
  }
}, "format");
var cache15 = /* @__PURE__ */ new WeakMap();
var baseCache13 = /* @__PURE__ */ __name((cid) => {
  const baseCache14 = cache15.get(cid);
  if (baseCache14 == null) {
    const baseCache15 = /* @__PURE__ */ new Map();
    cache15.set(cid, baseCache15);
    return baseCache15;
  }
  return baseCache14;
}, "baseCache");
var CID14 = class _CID {
  static {
    __name(this, "CID");
  }
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code16, multihash, bytes3) {
    this.code = code16;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code16, multihash } = this;
        if (code16 !== DAG_PB_CODE14) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE14) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code16, digest: digest13 } = this.multihash;
        const multihash = create22(code16, digest13);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals35(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base42) {
    return format13(this, base42);
  }
  toJSON() {
    return { "/": format13(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code16, multihash, bytes: bytes3 } = value;
      return new _CID(
        version4,
        code16,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes3 || encodeCID14(version4, code16, multihash.bytes)
      );
    } else if (value[cidSymbol14] === true) {
      const { version: version4, multihash, code: code16 } = value;
      const digest13 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode95(multihash)
      );
      return _CID.create(version4, code16, digest13);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code16, digest13) {
    if (typeof code16 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest13.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code16 !== DAG_PB_CODE14) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE14}) block encoding`
          );
        } else {
          return new _CID(version4, code16, digest13, digest13.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID14(version4, code16, digest13.bytes);
        return new _CID(version4, code16, digest13, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest13) {
    return _CID.create(0, DAG_PB_CODE14, digest13);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code16, digest13) {
    return _CID.create(1, code16, digest13);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce11(
      bytes3.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest13 = new Digest18(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest13
    ) : _CID.createV1(specs.codec, digest13);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = /* @__PURE__ */ __name(() => {
      const [i, length21] = decode94(initialBytes.subarray(offset));
      offset += length21;
      return i;
    }, "next");
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE14
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base42) {
    const [prefix, bytes3] = parseCIDtoBytes14(source, base42);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache13(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes14 = /* @__PURE__ */ __name((source, base42) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base42 || base58btc11;
      return [
        /** @type {Prefix} */
        base58btc11.prefix,
        decoder.decode(`${base58btc11.prefix}${source}`)
      ];
    }
    case base58btc11.prefix: {
      const decoder = base42 || base58btc11;
      return [
        /** @type {Prefix} */
        base58btc11.prefix,
        decoder.decode(source)
      ];
    }
    case base3210.prefix: {
      const decoder = base42 || base3210;
      return [
        /** @type {Prefix} */
        base3210.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base42 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base42.decode(source)
      ];
    }
  }
}, "parseCIDtoBytes");
var toStringV014 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  if (prefix !== base58btc11.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3).slice(1);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV0");
var toStringV114 = /* @__PURE__ */ __name((bytes3, cache16, base42) => {
  const { prefix } = base42;
  const cid = cache16.get(prefix);
  if (cid == null) {
    const cid2 = base42.encode(bytes3);
    cache16.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}, "toStringV1");
var DAG_PB_CODE14 = 112;
var SHA_256_CODE14 = 18;
var encodeCID14 = /* @__PURE__ */ __name((version4, code16, multihash) => {
  const codeOffset = encodingLength19(version4);
  const hashOffset = codeOffset + encodingLength19(code16);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo18(version4, bytes3, 0);
  encodeTo18(code16, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}, "encodeCID");
var cidSymbol14 = Symbol.for("@ipld/js-cid/CID");

// node_modules/libp2p/node_modules/multiformats/src/hashes/hasher.js
var from44 = /* @__PURE__ */ __name(({ name: name14, code: code16, encode: encode79 }) => new Hasher16(name14, code16, encode79), "from");
var Hasher16 = class {
  static {
    __name(this, "Hasher");
  }
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name14, code16, encode79) {
    this.name = name14;
    this.code = code16;
    this.encode = encode79;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create22(this.code, result) : result.then((digest13) => create22(this.code, digest13));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/libp2p/node_modules/multiformats/src/hashes/sha2-browser.js
var sha16 = /* @__PURE__ */ __name((name14) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name14, data))
), "sha");
var sha25617 = from44({
  name: "sha2-256",
  code: 18,
  encode: sha16("SHA-256")
});
var sha51217 = from44({
  name: "sha2-512",
  code: 19,
  encode: sha16("SHA-512")
});

// node_modules/libp2p/dist/src/circuit-relay/utils.js
var log49 = logger6("libp2p:circuit-relay:utils");
async function namespaceToCid(namespace) {
  const bytes3 = new TextEncoder().encode(namespace);
  const hash3 = await sha25617.digest(bytes3);
  return CID14.createV0(hash3);
}
__name(namespaceToCid, "namespaceToCid");
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}
__name(getExpirationMilliseconds, "getExpirationMilliseconds");

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2(), 1);

// node_modules/libp2p/dist/src/circuit-relay/server/advert-service.js
var log50 = logger6("libp2p:circuit-relay:advert-service");

// node_modules/libp2p/dist/src/circuit-relay/server/index.js
var log51 = logger6("libp2p:circuit-relay:server");

// node_modules/@libp2p/utils/node_modules/@libp2p/logger/dist/src/index.js
var import_debug18 = __toESM(require_browser(), 1);

// node_modules/@libp2p/utils/node_modules/multiformats/vendor/base-x.js
function base41(ALPHABET, name14) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode79(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length21 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      pbegin++;
    }
    var it2 = size - length21;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode79, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length21 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length21 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length21;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode97(string8) {
    var buffer3 = decodeUnsafe(string8);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name14} character`);
  }
  __name(decode97, "decode");
  return {
    encode: encode79,
    decodeUnsafe,
    decode: decode97
  };
}
__name(base41, "base");
var src29 = base41;
var _brrp__multiformats_scope_baseX29 = src29;
var base_x_default29 = _brrp__multiformats_scope_baseX29;

// node_modules/@libp2p/utils/node_modules/multiformats/src/bytes.js
var empty31 = new Uint8Array(0);
var coerce31 = /* @__PURE__ */ __name((o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}, "coerce");

// node_modules/@libp2p/utils/node_modules/multiformats/src/bases/base.js
var Encoder30 = class {
  static {
    __name(this, "Encoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name14, prefix, baseEncode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder31 = class {
  static {
    __name(this, "Decoder");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or30(this, decoder);
  }
};
var ComposedDecoder29 = class {
  static {
    __name(this, "ComposedDecoder");
  }
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or30(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or30 = /* @__PURE__ */ __name((left, right) => new ComposedDecoder29(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
), "or");
var Codec29 = class {
  static {
    __name(this, "Codec");
  }
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name14, prefix, baseEncode, baseDecode) {
    this.name = name14;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder30(name14, prefix, baseEncode);
    this.decoder = new Decoder31(name14, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from45 = /* @__PURE__ */ __name(({ name: name14, prefix, encode: encode79, decode: decode97 }) => new Codec29(name14, prefix, encode79, decode97), "from");
var baseX29 = /* @__PURE__ */ __name(({ prefix, name: name14, alphabet: alphabet11 }) => {
  const { encode: encode79, decode: decode97 } = base_x_default29(alphabet11, name14);
  return from45({
    prefix,
    name: name14,
    encode: encode79,
    /**
     * @param {string} text
     */
    decode: (text) => coerce31(decode97(text))
  });
}, "baseX");
var decode96 = /* @__PURE__ */ __name((string8, alphabet11, bitsPerChar, name14) => {
  const codes8 = {};
  for (let i = 0; i < alphabet11.length; ++i) {
    codes8[alphabet11[i]] = i;
  }
  let end = string8.length;
  while (string8[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits3 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes8[string8[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name14} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits3 += bitsPerChar;
    if (bits3 >= 8) {
      bits3 -= 8;
      out[written++] = 255 & buffer3 >> bits3;
    }
  }
  if (bits3 >= bitsPerChar || 255 & buffer3 << 8 - bits3) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}, "decode");
var encode78 = /* @__PURE__ */ __name((data, alphabet11, bitsPerChar) => {
  const pad = alphabet11[alphabet11.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits3 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits3 += 8;
    while (bits3 > bitsPerChar) {
      bits3 -= bitsPerChar;
      out += alphabet11[mask & buffer3 >> bits3];
    }
  }
  if (bits3) {
    out += alphabet11[mask & buffer3 << bitsPerChar - bits3];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
}, "encode");
var rfc464829 = /* @__PURE__ */ __name(({ name: name14, prefix, bitsPerChar, alphabet: alphabet11 }) => {
  return from45({
    prefix,
    name: name14,
    encode(input) {
      return encode78(input, alphabet11, bitsPerChar);
    },
    decode(input) {
      return decode96(input, alphabet11, bitsPerChar, name14);
    }
  });
}, "rfc4648");

// node_modules/@libp2p/utils/node_modules/multiformats/src/bases/base58.js
var base58btc29 = baseX29({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr29 = baseX29({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/utils/node_modules/multiformats/src/bases/base32.js
var base3228 = rfc464829({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper28 = rfc464829({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad28 = rfc464829({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper28 = rfc464829({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex28 = rfc464829({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper28 = rfc464829({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad28 = rfc464829({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper28 = rfc464829({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z28 = rfc464829({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/utils/node_modules/multiformats/src/bases/base64.js
var base6428 = rfc464829({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad28 = rfc464829({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url28 = rfc464829({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad28 = rfc464829({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/utils/node_modules/@libp2p/logger/dist/src/index.js
import_debug18.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc29.baseEncode(v);
};
import_debug18.default.formatters.t = (v) => {
  return v == null ? "undefined" : base3228.baseEncode(v);
};
import_debug18.default.formatters.m = (v) => {
  return v == null ? "undefined" : base6428.baseEncode(v);
};
import_debug18.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug18.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug18.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug18.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger20(namespace) {
  const logger22 = /* @__PURE__ */ __name(() => {
  }, "logger");
  logger22.enabled = false;
  logger22.color = "";
  logger22.diff = 0;
  logger22.log = () => {
  };
  logger22.namespace = namespace;
  logger22.destroy = () => true;
  logger22.extend = () => logger22;
  return logger22;
}
__name(createDisabledLogger20, "createDisabledLogger");
function logger21(name14) {
  let trace = createDisabledLogger20(`${name14}:trace`);
  if (import_debug18.default.enabled(`${name14}:trace`) && import_debug18.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug18.default)(`${name14}:trace`);
  }
  return Object.assign((0, import_debug18.default)(name14), {
    error: (0, import_debug18.default)(`${name14}:error`),
    trace
  });
}
__name(logger21, "logger");

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
var log52 = logger21("libp2p:stream:converter");
function streamToMaConnection(props, options = {}) {
  const { stream, remoteAddr } = props;
  const { sink, source } = stream;
  const mapSource = async function* () {
    for await (const list of source) {
      if (list instanceof Uint8Array) {
        yield list;
      } else {
        yield* list;
      }
    }
  }();
  const maConn = {
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
        await close();
      } catch (err) {
        if (err.type !== "aborted") {
          log52(err);
        }
      }
    },
    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    async close() {
      await sink(async function* () {
        yield new Uint8Array(0);
      }());
      await close();
    }
  };
  async function close() {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
    await Promise.resolve();
  }
  __name(close, "close");
  return maConn;
}
__name(streamToMaConnection, "streamToMaConnection");

// node_modules/libp2p/dist/src/circuit-relay/transport/discovery.js
var log53 = logger6("libp2p:circuit-relay:discover-relays");
var RelayDiscovery = class extends EventEmitter6 {
  static {
    __name(this, "RelayDiscovery");
  }
  peerId;
  peerStore;
  contentRouting;
  registrar;
  started;
  topologyId;
  constructor(components) {
    super();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.contentRouting = components.contentRouting;
    this.registrar = components.registrar;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, createTopology({
      onConnect: (peerId) => {
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    }));
    void this.discover().catch((err) => {
      log53.error("error listening on relays", err);
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network
   */
  async discover() {
    log53("searching peer store for relays");
    const peers = await this.peerStore.all({
      filters: [
        // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
        (peer) => {
          return peer.protocols.includes(RELAY_V2_HOP_CODEC);
        }
      ],
      orders: [
        () => Math.random() < 0.5 ? 1 : -1
      ]
    });
    for (const peer of peers) {
      log53("found relay peer %p in content peer store", peer.id);
      this.safeDispatchEvent("relay:discover", { detail: peer.id });
    }
    log53("found %d relay peers in peer store", peers.length);
    try {
      log53("searching content routing for relays");
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      let found = 0;
      for await (const provider of this.contentRouting.findProviders(cid)) {
        if (provider.multiaddrs.length > 0 && !provider.id.equals(this.peerId)) {
          const peerId = provider.id;
          found++;
          await this.peerStore.merge(peerId, {
            multiaddrs: provider.multiaddrs
          });
          log53("found relay peer %p in content routing", peerId);
          this.safeDispatchEvent("relay:discover", { detail: peerId });
        }
      }
      log53("found %d relay peers in content routing", found);
    } catch (err) {
      log53.error("failed when finding relays on the network", err);
    }
  }
};

// node_modules/libp2p/dist/src/circuit-relay/transport/listener.js
var log54 = logger6("libp2p:circuit-relay:transport:listener");
var CircuitRelayTransportListener = class extends EventEmitter6 {
  static {
    __name(this, "CircuitRelayTransportListener");
  }
  connectionManager;
  relayStore;
  listeningAddrs;
  constructor(components) {
    super();
    this.connectionManager = components.connectionManager;
    this.relayStore = components.relayStore;
    this.listeningAddrs = new PeerMap();
    this.relayStore.addEventListener("relay:removed", (evt) => {
      this.#removeRelayPeer(evt.detail);
    });
  }
  async listen(addr) {
    log54("listen on %s", addr);
    const relayPeerStr = addr.getPeerId();
    let relayConn;
    if (relayPeerStr != null) {
      const relayPeer = peerIdFromString(relayPeerStr);
      const connections = this.connectionManager.getConnectionsMap().get(relayPeer) ?? [];
      if (connections.length > 0) {
        relayConn = connections[0];
      }
    }
    if (relayConn == null) {
      const addrString = addr.toString().split("/p2p-circuit").find((a) => a !== "");
      const ma = multiaddr(addrString);
      relayConn = await this.connectionManager.openConnection(ma);
    }
    if (!this.relayStore.hasReservation(relayConn.remotePeer)) {
      await this.relayStore.addRelay(relayConn.remotePeer, "configured");
      return;
    }
    const reservation = this.relayStore.getReservation(relayConn.remotePeer);
    if (reservation == null) {
      throw new CodeError("Did not have reservation after making reservation", "ERR_NO_RESERVATION");
    }
    if (this.listeningAddrs.has(relayConn.remotePeer)) {
      log54("already listening on relay %p", relayConn.remotePeer);
      return;
    }
    this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map((buf3) => {
      return multiaddr(buf3).encapsulate("/p2p-circuit");
    }));
    this.safeDispatchEvent("listening", {});
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  async close() {
  }
  #removeRelayPeer(peerId) {
    const had = this.listeningAddrs.has(peerId);
    this.listeningAddrs.delete(peerId);
    if (had) {
      this.safeDispatchEvent("close", {});
    }
  }
};
function createListener2(options) {
  return new CircuitRelayTransportListener(options);
}
__name(createListener2, "createListener");

// node_modules/libp2p/dist/src/circuit-relay/transport/reservation-store.js
var log55 = logger6("libp2p:circuit-relay:transport:reservation-store");
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var ReservationStore2 = class extends EventEmitter6 {
  static {
    __name(this, "ReservationStore");
  }
  peerId;
  connectionManager;
  transportManager;
  peerStore;
  events;
  reserveQueue;
  reservations;
  maxDiscoveredRelays;
  maxReservationQueueLength;
  started;
  constructor(components, init) {
    super();
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.maxDiscoveredRelays = init?.discoverRelays ?? 0;
    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? 100;
    this.started = false;
    this.reserveQueue = new PeerJobQueue({
      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY
    });
    this.events.addEventListener("peer:disconnect", (evt) => {
      this.#removeRelay(evt.detail);
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = true;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed connection
   * to the remote, and the remote peer speaks the hop protocol, try to reserve a slot
   * on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      log55("not trying to use self as relay");
      return;
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      log55("not adding relay as the queue is full");
      return;
    }
    if (this.reserveQueue.hasJob(peerId)) {
      log55("relay peer is already in the reservation queue");
      return;
    }
    log55("add relay %p", peerId);
    await this.reserveQueue.add(async () => {
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            log55("already have reservation on relay peer %p and it expires in more than 10 minutes", peerId);
            return;
          }
          clearTimeout(existingReservation.timeout);
          this.reservations.delete(peerId);
        }
        if (type === "discovered" && [...this.reservations.values()].reduce((acc, curr) => {
          if (curr.type === "discovered") {
            acc++;
          }
          return acc;
        }, 0) >= this.maxDiscoveredRelays) {
          log55("already have enough discovered relays");
          return;
        }
        const connection = await this.connectionManager.openConnection(peerId);
        if (connection.remoteAddr.protoNames().includes("p2p-circuit")) {
          log55("not creating reservation over relayed connection");
          return;
        }
        const reservation = await this.#createReservation(connection);
        log55("created reservation on relay peer %p", peerId);
        const expiration = getExpirationMilliseconds(reservation.expire);
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.addRelay(peerId, type).catch((err) => {
            log55.error("could not refresh reservation to relay %p", peerId, err);
          });
        }, timeoutDuration);
        this.reservations.set(peerId, {
          timeout,
          reservation,
          type
        });
        await this.peerStore.merge(peerId, {
          tags: {
            [RELAY_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        await this.transportManager.listen([multiaddr(`/p2p/${peerId.toString()}/p2p-circuit`)]);
      } catch (err) {
        log55.error("could not reserve slot on %p", peerId, err);
        this.reservations.delete(peerId);
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    return this.reservations.get(peerId)?.reservation;
  }
  async #createReservation(connection) {
    log55("requesting reservation from %s", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_HOP_CODEC);
    const pbstr = pbStream(stream);
    const hopstr = pbstr.pb(HopMessage);
    hopstr.write({ type: HopMessage.Type.RESERVE });
    let response;
    try {
      response = await hopstr.read();
    } catch (err) {
      log55.error("error parsing reserve message response from %p because", connection.remotePeer, err);
      throw err;
    } finally {
      stream.close();
    }
    if (response.status === Status.OK && response.reservation != null) {
      return response.reservation;
    }
    const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
    log55.error(errMsg);
    throw new Error(errMsg);
  }
  /**
   * Remove listen relay
   */
  #removeRelay(peerId) {
    const existingReservation = this.reservations.get(peerId);
    if (existingReservation == null) {
      return;
    }
    log55("connection to relay %p closed, removing reservation from local store", peerId);
    clearTimeout(existingReservation.timeout);
    this.reservations.delete(peerId);
    this.safeDispatchEvent("relay:removed", { detail: peerId });
    if (this.reservations.size < this.maxDiscoveredRelays) {
      log55("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
      this.safeDispatchEvent("relay:not-enough-relays", {});
    }
  }
};

// node_modules/libp2p/dist/src/circuit-relay/transport/index.js
var log56 = logger6("libp2p:circuit-relay:transport");
var isValidStop = /* @__PURE__ */ __name((request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
}, "isValidStop");
var defaults = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS
};
var CircuitRelayTransport = class {
  static {
    __name(this, "CircuitRelayTransport");
  }
  discovery;
  registrar;
  peerStore;
  connectionManager;
  peerId;
  upgrader;
  addressManager;
  connectionGater;
  reservationStore;
  maxInboundStopStreams;
  maxOutboundStopStreams;
  started;
  constructor(components, init) {
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.peerId = components.peerId;
    this.upgrader = components.upgrader;
    this.addressManager = components.addressManager;
    this.connectionGater = components.connectionGater;
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    if (init.discoverRelays != null && init.discoverRelays > 0) {
      this.discovery = new RelayDiscovery(components);
      this.discovery.addEventListener("relay:discover", (evt) => {
        this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
          log56.error("could not add discovered relay %p", evt.detail, err);
        });
      });
    }
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.discover().catch((err) => {
        log56.error("could not discover relays", err);
      });
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await this.reservationStore.start();
    await this.discovery?.start();
    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {
      void this.onStop(data).catch((err) => {
        log56.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams
    });
    this.started = true;
  }
  async stop() {
    this.discovery?.stop();
    await this.reservationStore.stop();
    await this.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  [symbol4] = true;
  [Symbol.toStringTag] = "libp2p/circuit-relay-v2";
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options = {}) {
    if (ma.protoCodes().filter((code16) => code16 === CIRCUIT_PROTO_CODE).length !== 1) {
      const errMsg = "Invalid circuit relay address";
      log56.error(errMsg, ma);
      throw new CodeError(errMsg, codes5.ERR_RELAYED_DIAL);
    }
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`;
      log56.error(errMsg);
      throw new CodeError(errMsg, codes5.ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      relayConnection = await this.connectionManager.openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    let stream;
    try {
      stream = await relayConnection.newStream([RELAY_V2_HOP_CODEC]);
      return await this.connectV2({
        stream,
        connection: relayConnection,
        destinationPeer,
        destinationAddr,
        relayAddr,
        ma,
        disconnectOnFailure
      });
    } catch (err) {
      log56.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${relayPeer.toString()} failed`, err);
      if (stream != null) {
        stream.abort(err);
      }
      disconnectOnFailure && await relayConnection.close();
      throw err;
    }
  }
  async connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure }) {
    try {
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toBytes(),
          addrs: [multiaddr(destinationAddr).bytes]
        }
      });
      const status = await hopstr.read();
      if (status.status !== Status.OK) {
        throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`, codes5.ERR_HOP_REQUEST_FAILED);
      }
      const maConn = streamToMaConnection({
        stream: pbstr.unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`)
      });
      log56("new outbound connection %s", maConn.remoteAddr);
      return await this.upgrader.upgradeOutbound(maConn);
    } catch (err) {
      log56.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err);
      disconnectOnFailure && await connection.close();
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options) {
    return createListener2({
      connectionManager: this.connectionManager,
      relayStore: this.reservationStore
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial on
   *
   * @param {Multiaddr[]} multiaddrs
   * @returns {Multiaddr[]}
   */
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop({ connection, stream }) {
    const pbstr = pbStream(stream);
    const request = await pbstr.readPB(StopMessage);
    log56("received circuit v2 stop protocol request from %s", connection.remotePeer);
    if (request?.type === void 0) {
      return;
    }
    const stopstr = pbstr.pb(StopMessage);
    log56("new circuit relay v2 stop stream from %s", connection.remotePeer);
    if (request.type !== StopMessage.Type.CONNECT) {
      log56.error("invalid stop connect request via peer %s", connection.remotePeer);
      stopstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
      return;
    }
    if (!isValidStop(request)) {
      log56.error("invalid stop connect request via peer %s", connection.remotePeer);
      stopstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE });
      return;
    }
    const remotePeerId = peerIdFromBytes(request.peer.id);
    if (await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
      stopstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    stopstr.write({ type: StopMessage.Type.STATUS, status: Status.OK });
    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
    const localAddr = this.addressManager.getAddresses()[0];
    const maConn = streamToMaConnection({
      stream: pbstr.unwrap(),
      remoteAddr,
      localAddr
    });
    log56("new inbound connection %s", maConn.remoteAddr);
    await this.upgrader.upgradeInbound(maConn);
    log56("%s connection %s upgraded", "inbound", maConn.remoteAddr);
  }
};
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}
__name(circuitRelayTransport, "circuitRelayTransport");

// node_modules/libp2p/dist/src/version.js
var version2 = "0.45.9";

// node_modules/libp2p/dist/src/identify/consts.js
var AGENT_VERSION = `js-libp2p/${version2}`;
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

// node_modules/libp2p/dist/src/identify/identify.js
var import_events35 = __toESM(require_events(), 1);

// node_modules/libp2p/dist/src/identify/pb/message.js
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.protocolVersion != null) {
          w2.uint32(42);
          w2.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w2.uint32(50);
          w2.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w2.uint32(10);
          w2.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w2.uint32(34);
          w2.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w2.uint32(26);
            w2.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w2.uint32(66);
          w2.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length21) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length21 == null ? reader2.len : reader2.pos + length21;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader2.string();
              break;
            case 6:
              obj.agentVersion = reader2.string();
              break;
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader2.bytes());
              break;
            case 4:
              obj.observedAddr = reader2.bytes();
              break;
            case 3:
              obj.protocols.push(reader2.string());
              break;
            case 8:
              obj.signedPeerRecord = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf3) => {
    return decodeMessage(buf3, Identify2.codec());
  };
})(Identify || (Identify = {}));

// node_modules/libp2p/dist/src/identify/identify.js
var log57 = logger6("libp2p:identify");
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var defaultValues2 = {
  protocolPrefix: "ipfs",
  agentVersion: AGENT_VERSION,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48
  timeout: 6e4,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxPushIncomingStreams: 1,
  maxPushOutgoingStreams: 1,
  maxObservedAddresses: 10,
  maxIdentifyMessageSize: 8192
};
var DefaultIdentifyService = class {
  static {
    __name(this, "DefaultIdentifyService");
  }
  identifyProtocolStr;
  identifyPushProtocolStr;
  host;
  started;
  timeout;
  peerId;
  peerStore;
  registrar;
  connectionManager;
  addressManager;
  maxInboundStreams;
  maxOutboundStreams;
  maxPushIncomingStreams;
  maxPushOutgoingStreams;
  maxIdentifyMessageSize;
  maxObservedAddresses;
  events;
  constructor(components, init) {
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.events = components.events;
    this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues2.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues2.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? defaultValues2.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues2.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues2.maxOutboundStreams;
    this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues2.maxPushIncomingStreams;
    this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues2.maxPushOutgoingStreams;
    this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues2.maxIdentifyMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues2.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: init.agentVersion ?? defaultValues2.agentVersion
    };
    components.events.addEventListener("connection:open", (evt) => {
      const connection = evt.detail;
      this.identify(connection).catch((err) => {
        log57.error("error during identify trigged by connection:open", err);
      });
    });
    components.events.addEventListener("self:peer:update", (evt) => {
      void this.push().catch((err) => {
        log57.error(err);
      });
    });
    if (this.host.agentVersion === AGENT_VERSION) {
      if (isNode || isElectronMain) {
        this.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
      } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
        this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
      }
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString7(this.host.agentVersion),
        ProtocolVersion: fromString7(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err) => {
        log57.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    });
    await this.registrar.handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err) => {
        log57.error(err);
      });
    }, {
      maxInboundStreams: this.maxPushIncomingStreams,
      maxOutboundStreams: this.maxPushOutgoingStreams
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.identifyProtocolStr);
    await this.registrar.unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  /**
   * Send an Identify Push update to the list of connections
   */
  async pushToConnections(connections) {
    const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
    const peerRecord = new PeerRecord2({
      peerId: this.peerId,
      multiaddrs: listenAddresses
    });
    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);
    const supportedProtocols = this.registrar.getProtocols();
    const peer = await this.peerStore.get(this.peerId);
    const agentVersion = toString5(peer.metadata.get("AgentVersion") ?? fromString7(this.host.agentVersion));
    const protocolVersion = toString5(peer.metadata.get("ProtocolVersion") ?? fromString7(this.host.protocolVersion));
    const pushes = connections.map(async (connection) => {
      let stream;
      const signal = AbortSignal.timeout(this.timeout);
      try {
        (0, import_events35.setMaxListeners)?.(Infinity, signal);
      } catch {
      }
      try {
        stream = await connection.newStream([this.identifyPushProtocolStr], {
          signal
        });
        const source = abortableDuplex(stream, signal);
        await source.sink(pipe([Identify.encode({
          listenAddrs: listenAddresses.map((ma) => ma.bytes),
          signedPeerRecord: signedPeerRecord.marshal(),
          protocols: supportedProtocols,
          agentVersion,
          protocolVersion
        })], (source2) => encode16(source2)));
      } catch (err) {
        log57.error("could not push identify update to peer", err);
      } finally {
        if (stream != null) {
          stream.close();
        }
      }
    });
    await Promise.all(pushes);
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    await Promise.all(this.connectionManager.getConnections().map(async (conn) => {
      try {
        const peer = await this.peerStore.get(conn.remotePeer);
        if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
          return;
        }
        connections.push(conn);
      } catch (err) {
        if (err.code !== codes5.ERR_NOT_FOUND) {
          throw err;
        }
      }
    }));
    await this.pushToConnections(connections);
  }
  async _identify(connection, options = {}) {
    let stream;
    const signal = anySignal([AbortSignal.timeout(this.timeout), options?.signal]);
    try {
      (0, import_events35.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    try {
      stream = await connection.newStream([this.identifyProtocolStr], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const data = await pipe([], source, (source2) => decode21(source2, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => src_default12(source2));
      if (data == null) {
        throw new CodeError("No data could be retrieved", codes5.ERR_CONNECTION_ENDED);
      }
      try {
        return Identify.decode(data);
      } catch (err) {
        throw new CodeError(String(err), codes5.ERR_INVALID_MESSAGE);
      }
    } finally {
      if (stream != null) {
        stream.close();
      }
      signal.clear();
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new CodeError("public key was missing from identify message", codes5.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw new CodeError("identified peer does not match the expected peer", codes5.ERR_INVALID_PEER);
    }
    if (this.peerId.equals(id)) {
      throw new CodeError("identified peer is our own peer id?", codes5.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    log57("identify completed for peer %p and protocols %o", id, protocols);
    log57("our observed address is %s", cleanObservedAddr);
    if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
      log57("storing our observed address %s", cleanObservedAddr?.toString());
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    const signedPeerRecord = await this.#consumeIdentifyMessage(connection.remotePeer, message2);
    const result = {
      peerId: id,
      protocolVersion: message2.protocolVersion,
      agentVersion: message2.agentVersion,
      publicKey: message2.publicKey,
      listenAddrs: message2.listenAddrs.map((buf3) => multiaddr(buf3)),
      observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
      protocols: message2.protocols,
      signedPeerRecord
    };
    this.events.safeDispatchEvent("peer:identify", { detail: result });
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    try {
      (0, import_events35.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    try {
      const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);
        signedPeerRecord = envelope.marshal().subarray();
      }
      const message2 = Identify.encode({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols: peerData.protocols
      });
      const source = abortableDuplex(stream, signal);
      const msgWithLenPrefix = pipe([message2], (source2) => encode16(source2));
      await source.sink(msgWithLenPrefix);
    } catch (err) {
      log57.error("could not respond to identify request", err);
    } finally {
      stream.close();
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async _handlePush(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const source = abortableDuplex(stream, AbortSignal.timeout(this.timeout));
      const pb = pbStream(source, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      });
      const message2 = await pb.readPB(Identify);
      await this.#consumeIdentifyMessage(connection.remotePeer, message2);
    } catch (err) {
      log57.error("received invalid message", err);
      return;
    } finally {
      stream.close();
    }
    log57("handled push from %p", connection.remotePeer);
  }
  async #consumeIdentifyMessage(remotePeer, message2) {
    log57("received identify from %p", remotePeer);
    if (message2 == null) {
      throw new Error("Message was null or undefined");
    }
    const peer = {
      addresses: message2.listenAddrs.map((buf3) => ({
        isCertified: false,
        multiaddr: multiaddr(buf3)
      })),
      protocols: message2.protocols,
      metadata: /* @__PURE__ */ new Map(),
      peerRecordEnvelope: message2.signedPeerRecord
    };
    let output3;
    if (message2.signedPeerRecord != null) {
      log57("received signedPeerRecord in push from %p", remotePeer);
      let peerRecordEnvelope = message2.signedPeerRecord;
      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord2.DOMAIN);
      let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      if (!peerRecord.peerId.equals(envelope.peerId)) {
        throw new Error("signing key does not match PeerId in the PeerRecord");
      }
      if (!remotePeer.equals(peerRecord.peerId)) {
        throw new Error("signing key does not match remote PeerId");
      }
      let existingPeer;
      try {
        existingPeer = await this.peerStore.get(peerRecord.peerId);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (existingPeer != null) {
        peer.metadata = existingPeer.metadata;
        if (existingPeer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
          const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log57("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            peerRecord = storedRecord;
            peerRecordEnvelope = existingPeer.peerRecordEnvelope;
          }
        }
      }
      peer.peerRecordEnvelope = peerRecordEnvelope;
      peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }));
      output3 = {
        seq: peerRecord.seqNumber,
        addresses: peerRecord.multiaddrs
      };
    } else {
      log57("%p did not send a signed peer record", remotePeer);
    }
    if (message2.agentVersion != null) {
      peer.metadata.set("AgentVersion", fromString7(message2.agentVersion));
    }
    if (message2.protocolVersion != null) {
      peer.metadata.set("ProtocolVersion", fromString7(message2.protocolVersion));
    }
    await this.peerStore.patch(remotePeer, peer);
    return output3;
  }
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
__name(getCleanMultiaddr, "getCleanMultiaddr");

// node_modules/libp2p/dist/src/identify/index.js
function identifyService(init = {}) {
  return (components) => new DefaultIdentifyService(components, init);
}
__name(identifyService, "identifyService");

// node_modules/helia/dist/src/utils/bootstrappers.js
var bootstrapConfig = {
  list: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
  ]
};

// node_modules/helia/dist/src/utils/libp2p-defaults.browser.js
function libp2pDefaults() {
  return {
    addresses: {
      listen: [
        "/webrtc"
      ]
    },
    transports: [
      webRTC(),
      webRTCDirect(),
      webTransport(),
      webSockets(),
      circuitRelayTransport({
        discoverRelays: 1
      })
    ],
    connectionEncryption: [
      noise()
    ],
    streamMuxers: [
      yamux(),
      mplex()
    ],
    peerDiscovery: [
      bootstrap(bootstrapConfig)
    ],
    contentRouters: [
      ipniContentRouting("https://cid.contact")
    ],
    services: {
      identify: identifyService(),
      autoNAT: autoNATService(),
      pubsub: gossipsub(),
      dht: kadDHT({
        clientMode: true,
        validators: {
          ipns: ipnsValidator
        },
        selectors: {
          ipns: ipnsSelector
        }
      })
    }
  };
}
__name(libp2pDefaults, "libp2pDefaults");

// node_modules/helia/dist/src/utils/libp2p.js
async function createLibp2p2(datastore, options) {
  const defaults2 = libp2pDefaults();
  options = options ?? {};
  return createLibp2p({
    datastore,
    ...defaults2,
    ...options,
    start: false
  });
}
__name(createLibp2p2, "createLibp2p");

// node_modules/helia/dist/src/version.js
var version3 = "1.3.12";
var name13 = "helia";

// node_modules/helia/dist/src/index.js
var log58 = logger("helia");
async function createHelia(init = {}) {
  const datastore = init.datastore ?? new MemoryDatastore();
  const blockstore = init.blockstore ?? new MemoryBlockstore();
  let libp2p;
  if (isLibp2p(init.libp2p)) {
    libp2p = init.libp2p;
  } else {
    libp2p = await createLibp2p2(datastore, init.libp2p);
  }
  const helia = new HeliaImpl({
    ...init,
    datastore,
    blockstore,
    libp2p
  });
  if (init.start !== false) {
    await helia.start();
  }
  if (helia.libp2p.isStarted()) {
    await addHeliaToAgentVersion(helia);
  } else {
    helia.libp2p.addEventListener("start", () => {
      addHeliaToAgentVersion(helia).catch((err) => {
        log58.error("could not add Helia to agent version", err);
      });
    });
  }
  return helia;
}
__name(createHelia, "createHelia");
function isLibp2p(obj) {
  if (obj == null) {
    return false;
  }
  const funcs = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
  return funcs.every((m2) => typeof obj[m2] === "function");
}
__name(isLibp2p, "isLibp2p");
async function addHeliaToAgentVersion(helia) {
  const peer = await helia.libp2p.peerStore.get(helia.libp2p.peerId);
  const versionBuf = peer.metadata.get("AgentVersion");
  if (versionBuf == null) {
    return;
  }
  let versionStr = new TextDecoder().decode(versionBuf);
  if (versionStr.match(/js-libp2p\/\d+\.\d+\.\d+\sUserAgent=/) == null) {
    return;
  }
  if (versionStr.includes(name13)) {
    versionStr = `${name13}/${version3} ${versionStr.split(" ").slice(1).join(" ")}`;
  } else {
    versionStr = `${name13}/${version3} ${versionStr}`;
  }
  await helia.libp2p.peerStore.merge(helia.libp2p.peerId, {
    metadata: {
      AgentVersion: new TextEncoder().encode(versionStr)
    }
  });
}
__name(addHeliaToAgentVersion, "addHeliaToAgentVersion");
export {
  createHelia
};
/*! Bundled license information:

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@libp2p/webtransport/dist/src/index.js:
  (*! TODO unclear how to add backpressure here? *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
